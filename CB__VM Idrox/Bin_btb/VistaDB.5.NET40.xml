<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VistaDB.5.NET40</name>
    </assembly>
    <members>
        <member name="T:VistaDB.Extra.VistaDBDataTable">
            <summary>
            Represents dynamic cursor for VistaDB table. May also be used as Data 
            Source for data bound operation on forms.
            </summary>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.#ctor(VistaDB.DDA.IVistaDBDatabase,System.String)">
            <summary>
            Initializes a new instance of the VistaDBDataTable class.
            </summary>
            <param name="db">Instance of opened VistaDB Database</param>
            <param name="tableName">Table name</param>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.#ctor(VistaDB.DDA.IVistaDBDatabase,System.String,System.Boolean,System.Boolean,System.String,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the VistaDBDataTable class.
            </summary>
            <param name="db">Instance of opened VistaDB Database</param>
            <param name="tableName">Table name</param>
            <param name="exclusive">Table open mode</param>
            <param name="readOnly">Read-only mode flag</param>
            <param name="indexName">Active index name</param>
            <param name="cacheSize">Cache size for table cursor</param>
            <param name="optimisticLocking">Optimistic locking flag</param>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.Close">
            <summary>
            Close opened table
            </summary>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.SetFilter(System.String,System.Boolean)">
            <summary>
            Set filter expression on the current table and try to optimize it when optimize parameter is set
            </summary>
            <param name="expression">Filter expression</param>
            <param name="optimize">Try to optimize filter using and existing indexes</param>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.Find(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Find the key in the current opened database and set found row to the first place in the cache.
            </summary>
            <param name="keyExpr">The script to use in engine for order 
            to evaluate the key to look for in index </param>
            <param name="idxName">Index name to look for key</param>
            <param name="partMach">Try to find first partial matching, when exact matching is absent</param>
            <param name="softPos">Try to position on the first row that follows by non-found key</param>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.ClearFilter">
            <summary>
            Reset all filters from in opened table
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.SetScope(System.String,System.String)">
            <summary>
            Set scope in active index of opened table
            </summary>
            <param name="lowExpr">The script to use by engine in order to evaluate low scope key</param>
            <param name="highExpr">The script to use by engine in order to evaluate high scope key</param>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.ClearScope">
            <summary>
            Reset scope in active index 
            </summary>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.SetActiveIndex(System.String,System.Int32)">
            <summary>
            Set active index in the current table
            </summary>
            <param name="indexName">Name of active index that pivots current row order</param>
            <param name="selectedRow">"Current row position"</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Extra.VistaDBDataTable.GetCurrentRowId(System.Int64)">
            <summary>
            Return rowID of current row
            </summary>
        </member>
        <member name="E:VistaDB.Extra.VistaDBDataTable.ListChanged">
            <summary>
            Occurs when the list or an item in the list changes. 
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.ActiveIndex">
            <summary>
            Name of active index that pivots current row order
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.State">
            <summary>
            Return current state of row cache
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.Count">
            <summary>
            Gets the number of elements contained in the ICollection.
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.GetExtendedNames">
            <summary>
            Property returns array of extended column names from the table
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.Exclusive">
            <summary>
            Indicates access mode to the table
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.TableSchema">
            <summary>
            Returns schema of the opened table
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.OptimisticLock">
            <summary>
            Gets or sets locking mode
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.ReadOnly">
            <summary>
            Gets or sets a value that indicates whether the table can be edited
            </summary>
        </member>
        <member name="P:VistaDB.Extra.VistaDBDataTable.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets if this table is participating within Synchronization Services.  
            This table cannot be altered or deleted by user if it enrolled in a sync with another machine.
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBDDAEventDelegate">
            <summary>
            The user's defined event handler to raise by event
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDDAEventDelegate.Type">
            <summary>
            Event type
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDDAEventDelegate.EventDelegate">
            <summary>
            Event callback delegate
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDDAEventDelegate.UsersData">
            <summary>
            User's defined object
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.Build">
            <summary>
            The actual BUILD number as displayed on the site and changelogs.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.Release">
            <summary>
            The numerical value for a patch release.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.Major">
            <summary>
            Major Version - This is 5 for the VistaDB 5 engine.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.Minor">
            <summary>
            Minor Version - The product revision code.  It would be 0 for VistaDB 5.0
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.AssemblyMajor">
            <summary>
            Assembly Major Version - The product revision code for the engine assembly.  Normally the same as the file Major version.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.AssemblyMinor">
            <summary>
            Assembly Minor Version - The product revision code for the engine assembly.  Normally the same as the file Minor version.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.OlderLockExtension">
            <summary>
            Old lock extension for locking non-exclusive read-only access to a VistaDB 3 database.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.OldLockExtension">
            <summary>
            Old lock extension for locking non-exclusive read-only access to a VistaDB 4 database.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.LockExtension">
            <summary>
            Lock extension for locking non-exclusive access to VistaDB 5 and later database formats.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.ProviderInvariantName">
            <summary>
            The invariant name for the provider
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.ProviderRegisteredName">
            <summary>
            The registered/display name for the provider
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.Edition">
            <summary>
            Debug edition
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.Configuration">
            <summary>
            Debug release configuration was used
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.VersionString">
            <summary>
            Short version string for engine assembly version.
            </summary>
        </member>
        <member name="F:VistaDB.Build.Information.BuildString">
            <summary>
            Full version string for use as file version and non-library-type assembly versions.
            </summary>
        </member>
        <member name="M:VistaDB.Build.Information.GetThisAssemblyFileVersion">
            <summary>
            Read the AssemblyFileVersion attribute to get the version string of this assembly.
            </summary>
            <returns>The version string read from the first AssemblyFileVersion attribute found, or the assembly version
            if the attribute is not available (or empty string if even that could not be read).</returns>
        </member>
        <member name="T:VistaDB.Diagnostic.LogLevel">
            <summary>
            Enumerates the selections for the level of logging the VistaDB engine will perform (if logging is connected).
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.LogLevel.None">
            <summary>
            Place-holder value when logging is disabled.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.LogLevel.Normal">
            <summary>
            Normal logging should have essentially no performance impact and only light log noise level.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.LogLevel.Detailed">
            <summary>
            Detailed logging should have little or no performance impact but can produce a noisier log for more details.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.LogLevel.Debug">
            <summary>
            Debug logging can have a performance impact and produce volumninous log data for debugging purposes.
            </summary>
        </member>
        <member name="T:VistaDB.Diagnostic.TraceLogger">
            <summary>
            An ILog implementation for the intrinsic .NET Trace logger
            </summary>
            <remarks>To route VistaDB diagnostic information to any registered trace listener create an instance of this
            object and pass it to <a cref="M:VistaDB.Diagnostic.Logging.Add(VistaDB.Diagnostic.ILog)">Logging.Add</a>.  Control the amount of information
            logged by setting the log level on the <a cref="T:VistaDB.Diagnostic.Logging">Logging class.</a> </remarks>
            <seealso cref="T:VistaDB.Diagnostic.Logging"/>
            <seealso cref="T:VistaDB.Diagnostic.ILog"/>
        </member>
        <member name="T:VistaDB.Diagnostic.ILog">
            <summary>
            Implemented by callers that want to record diagnostic information for VistaDB
            </summary>
        </member>
        <member name="M:VistaDB.Diagnostic.ILog.WriteMessage(System.Diagnostics.TraceEventType,System.Int32,System.Exception,System.String,System.String,System.String,System.String)">
            <summary>
            Write a complete log message to the log, optionally extended with XML details and broadest API features.
            </summary>
            <param name="severity">The severity enum value of the log message.</param>
            <param name="skipFrames">The number of stack frames back to the original logging method.</param>
            <param name="exception">An Exception object attached to this log message, or null if none.</param>
            <param name="detailsXml">An XML document (as a string) with extended details about the message.</param>
            <param name="category">The application subsystem or logging category that the log message is associated with,
            which supports a dot-delimited hierarchy.</param>
            <param name="caption">A simple single-line message caption.</param>
            <param name="description">Additional multi-line descriptive message (or may be null)</param>
        </member>
        <member name="M:VistaDB.Diagnostic.TraceLogger.WriteMessage(System.Diagnostics.TraceEventType,System.Int32,System.Exception,System.String,System.String,System.String,System.String)">
            <summary>
            Write a complete log message to the log, optionally extended with XML details and broadest API features.
            </summary>
            <param name="severity">The severity enum value of the log message.</param>
            <param name="skipFrames">The number of stack frames back to the original logging method.</param>
            <param name="exception">An Exception object attached to this log message, or null if none.</param>
            <param name="detailsXml">An XML document (as a string) with extended details about the message.</param>
            <param name="category">The application subsystem or logging category that the log message is associated with,
            which supports a dot-delimited hierarchy.</param>
            <param name="caption">A simple single-line message caption.</param>
            <param name="description">Additional multi-line descriptive message (or may be null)</param>
        </member>
        <member name="T:VistaDB.Provider.VistaDBPipe">
            <summary>
            The data channel to send data from CLR Proc or CLR Trigger to the caller
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBPipe.Send(VistaDB.Provider.VistaDBDataReader)">
            <summary>
            Sends a multi-row result-set directly to the caller
            </summary>
            <param name="reader">The multi-row result-set to be sent to the caller</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBPipe.Send(System.String)">
            <summary>
            Sends string message
            </summary>
            <param name="message">the message to send</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBPipe.Send(VistaDB.Compatibility.SqlServer.SqlDataRecord)">
            <summary>
            Sends the custom result set to the caller
            </summary>
            <param name="record">VistaDB.Compatibility.SqlServer.SqlDataRecord object to send</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBPipe.SendResultsStart(VistaDB.Compatibility.SqlServer.SqlDataRecord)">
            <summary>
            
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBPipe.SendResultsEnd">
            <summary>
            Sends the custom result set to the caller
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBPipe.SendResultsRow(VistaDB.Compatibility.SqlServer.SqlDataRecord)">
            <summary>
            
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBPipe.ExecuteAndSend(VistaDB.Provider.VistaDBCommand)">
            <summary>
            Executes the command passed as a parameter and sends the results to the caller.
            </summary>
            <param name="command">The VistaDB.Provider.VistaDBCommand object to be executed</param>
        </member>
        <member name="T:VistaDB.Diagnostic.Logging">
            <summary>
            Allows applications to connect to the internal diagnostics of VistaDB.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Logging.LogCategorySchema">
            <summary>
            Working with schema 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Logging.LogCategoryCore">
            <summary>
            Internals to VistaDB that don't fit in another category
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Logging.LogCategoryEngine">
            <summary>
            Working with Data (select, insert, update, delete)
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Logging.LogCategoryStorage">
            <summary>
            Storing and caching data, low level IO
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Logging.LogCategoryPack">
            <summary>
            Logging specifically related to the pack or repair processes
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Logging.LogCategoryOptimizer">
            <summary>
            The query optimizer / rewriter
            </summary>
        </member>
        <member name="M:VistaDB.Diagnostic.Logging.Add(VistaDB.Diagnostic.ILog)">
            <summary>
            Register a new logging target
            </summary>
            <param name="loggingTarget"></param>
        </member>
        <member name="M:VistaDB.Diagnostic.Logging.Remove(VistaDB.Diagnostic.ILog)">
            <summary>
            Unregister the provided logging instance
            </summary>
            <param name="loggingTarget"></param>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Diagnostic.Logging.LoggingLevel">
            <summary>
            Gets or sets the logging level.  (Set to LogLevel.None to disable logging.)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.AlterList">
            <summary>
            List of changes applied to old columns
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.BinarySerializer">
            <summary>
            Provides basic binary serialization for platform independent simple serialization, used in verifying licensing.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.Boolean)">
            <summary>
            Write the host value to the stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.Boolean)">
            <summary>
            Serialize a boolean value to a byte array with a single byte
            </summary>
            <param name="hostValue"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.Guid)">
            <summary>
            Serialize a GUID to a stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.Guid)">
            <summary>
            Serialize a GUID to a 16 byte array
            </summary>
            <param name="hostValue"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.String)">
            <summary>
            Serialize a string to a byte array
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue"></param>
            <remarks>Serializes the length in the first byte then each character with one byte character encoding</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.String)">
            <summary>
            Serialize a string to a byte array
            </summary>
            <param name="hostValue"></param>
            <returns>The byte array for the string</returns>
            <remarks>Serializes the length in the first byte then each character with one byte character encoding</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.DateTime)">
            <summary>
            Serialize a date time to a stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue"></param>
            <returns></returns>
            <remarks>Uses the date time offset encoding with the local time zone.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.DateTime)">
            <summary>
            Serialize a date time to a byte array
            </summary>
            <param name="hostValue"></param>
            <returns></returns>
            <remarks>Uses the date time offset encoding with the local time zone.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.DateTimeOffset)">
            <summary>
            Serialize a date time and offset
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue"></param>
            <returns></returns>
            <remarks>Encodes the date time offset as a string in ISO 8601 standard formatting</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.DateTimeOffset)">
            <summary>
            Serialize a date time and offset to a byte array.
            </summary>
            <param name="hostValue"></param>
            <returns></returns>
            <remarks>Encodes the date time offset as a string in ISO 8601 standard formatting</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.Int64)">
            <summary>
            Write the host value to the provided stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.Int64)">
            <summary>
            Create a network-byte-order array of the host value
            </summary>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.UInt64)">
            <summary>
            Create a network-byte-order array of the host value
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.UInt64)">
            <summary>
            Create a network-byte-order array of the host value
            </summary>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.Int32)">
            <summary>
            Write the host value to the stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.Int32)">
            <summary>
            Create a network-byte-order array of the host value
            </summary>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.UInt32)">
            <summary>
            Write the host value to the stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.UInt32)">
            <summary>
            Create a network-byte-order array of the host value
            </summary>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.Int16)">
            <summary>
            Write the host value to the stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue">The host value to be serialized</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.Int16)">
            <summary>
            Create a network-byte-order array of the host value
            </summary>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.IO.Stream,System.UInt16)">
            <summary>
            Write the host value to the stream
            </summary>
            <param name="stream">The stream to write to</param>
            <param name="hostValue">The host value to be serialized</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.SerializeValue(System.UInt16)">
            <summary>
            Create a network-byte-order array of the host value
            </summary>
            <param name="hostValue">The host value to be serialized</param>
            <returns>A byte aray of each byte of the value in network byte order</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.Int64@)">
            <summary>
            Convert a network byte order array to host value
            </summary>
            <param name="networkBytes">Network order byte array of the long</param>
            <param name="hostValue">The converted long from the network byte array</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.UInt64@)">
            <summary>
            Convert a network byte order array to host value
            </summary>
            <param name="networkBytes">Network order byte array of the long</param>
            <param name="hostValue">The converted long from the network byte array</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.Int32@)">
            <summary>
            Convert a network byte order array to host value
            </summary>
            <param name="networkBytes">Network order byte array of the long</param>
            <param name="hostValue">The converted long from the network byte array</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.UInt32@)">
            <summary>
            Convert a network byte order array to host value
            </summary>
            <param name="networkBytes">Network order byte array of the long</param>
            <param name="hostValue">The converted long from the network byte array</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.Int16@)">
            <summary>
            Convert a network byte order array to host value
            </summary>
            <param name="networkBytes">Network order byte array of the long</param>
            <param name="hostValue">The converted long from the network byte array</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.UInt16@)">
            <summary>
            Convert a network byte order array to host value
            </summary>
            <param name="networkBytes">Network order byte array of the long</param>
            <param name="hostValue">The converted long from the network byte array</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.DateTime@)">
            <summary>
            Deserialize a date and time value from the provided stream
            </summary>
            <param name="networkBytes"></param>
            <param name="hostValue"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.DateTimeOffset@)">
            <summary>
            Deserialize a date time offset value from the provided stream
            </summary>
            <param name="networkBytes"></param>
            <param name="hostValue"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.Guid@)">
            <summary>
            Deserialize a GUID value from the provided stream
            </summary>
            <param name="networkBytes"></param>
            <param name="hostValue"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.Boolean@)">
            <summary>
            Deserialize a boolean value from the provided stream
            </summary>
            <param name="networkBytes"></param>
            <param name="hostValue"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinarySerializer.DeserializeValue(System.IO.Stream,System.String@)">
            <summary>
            Deserialize a string value from the provided stream
            </summary>
            <param name="networkBytes"></param>
            <param name="hostValue"></param>
        </member>
        <member name="T:VistaDB.Engine.Core.Cryptography.BlowFish">
             <summary>
             BlowFish Encryption/decryption
             http://www.schneier.com/blowfish.html
             Author C-code : Paul Kocher
             E-mail : pck@netcom.com
             Date : 1997
            
             Description: C# implementation of the Blowfish algorithm 
             converted from C
             </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.ClrHosting">
            <summary>
            Maps CLR names to assemblies
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.InsensitiveHashtable.#ctor(System.Int32)">
            <summary>
            It is good practice to set an initial capacity on Hashtables if you know they are going to be large or small
            The default size is 10 and when you reach 11 it doubles it size, but forces a complete rebuild of the Hashtable (slow)
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.ClrHosting.GetMethod(System.String,System.Reflection.Assembly)">
            <summary>
            Use reflection to get necessary method
            </summary>
            <param name="clrHostedProcedure">Full name of clr hosted procedure</param>
            <param name="assembly">assembly to analyze</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.ClrHosting.ClrProcedure.Execute(System.Object[])">
            <summary>
            Execute the procedure with the given parameters
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.ClrHosting.ClrProcedure.Execute">
            <summary>
            Execute the procedure with the given parameters
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.CreateEntry(VistaDB.VistaDBType,VistaDB.VistaDBType)">
            <summary>
            Calculates an index at which to retreive or store a value into an array based on a given conversion pair.
            </summary>
            <param name="srcType"></param>
            <param name="dstType"></param>
            <returns>returns the index into an array that contains the appropriate method for the conversion</returns>
            <remarks></remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.CopyInternalValue(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            A special handler for "conversions" which can just copy the internal value object across.
            </summary>
            <param name="srcValue"></param>
            <param name="dstValue"></param>
            <param name="culture"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToByte(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a Byte. This was nice and simple, but SQL Server allows you to convert 
            an empty string as 0.  But Parse() goes boom if you send it an empty string.
            So I had to add some manual checks to convert it to 0 if the string is 0 length so we match SQL Server.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToInt16(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to an Int16. This was nice and simple, but SQL Server allows you to convert 
            an empty string as 0.  But Parse() goes boom if you send it an empty string.
            So I had to add some manual checks to convert it to 0 if the string is 0 length so we match SQL Server.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToInt32(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to an Int32. This was nice and simple, but SQL Server allows you to convert 
            an empty string as 0.  But Parse() goes boom if you send it an empty string.
            So I had to add some manual checks to convert it to 0 if the string is 0 length so we match SQL Server.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToInt64(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to an Int64. This was nice and simple, but SQL Server allows you to convert 
            an empty string as 0.  But Parse() goes boom if you send it an empty string.
            So I had to add some manual checks to convert it to 0 if the string is 0 length so we match SQL Server.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToSingle(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a single. This was nice and simple, but SQL Server allows you to convert 
            an empty string to a float as 0.  But single.Parse() goes boom if you send it an empty string.
            So I had to add some manual checks to convert it to 0 if the string is 0 length so we match SQL Server.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToDouble(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a double. This was nice and simple, but SQL Server allows you to convert 
            an empty string to a double as 0.  But double.Parse() goes boom if you send it an empty string.
            So I had to add some manual checks to convert it to 0 if the string is 0 length so we match SQL Server.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToDecimal(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a decimal. This was nice and simple, but SQL Server allows you to convert 
            an empty string to a double but not a decimal.  This code throws an exception if the string is empty.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.GetAsDateTimeOffset(System.String,System.Globalization.CultureInfo)">
            <summary>
            Parse a string representing a date and/or time into a DateTimeOffset value.
            </summary>
            <param name="strDateTime"></param>
            <param name="culture"></param>
            <returns></returns>
            <remarks>SQL Server allows you to convert an empty string to a datetime as 1900-01-01.  But DateTime.Parse()
            fails if you send it an empty string.  So it has to have some manual checks to convert it if the string is
            length 0 so that we match SQL Server.  However, .NET parsing does not make it possible to get this default
            date when parsing from a string with culture sensitivity and full flexibility, so VistaDB defaults the date
            to today's date when parsing a string (except for an empty string which gets 1900-1-1).
            Conversion from the new TIME data type will correctly map to the SQL Server default date.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToDateTime(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a DateTime. 
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToDateTimeOffset(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a DateTime. 
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToDate(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a Date.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToTime(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a Time.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CrossConversion.NCharToBit(VistaDB.Engine.Internal.IValue,VistaDB.Engine.Internal.IValue,System.Globalization.CultureInfo)">
            <summary>
            Convert an NChar to a bit. This was nice and simple, but SQL Server allows you to convert 
            an empty string to a bit.  But Parse() goes boom if you send it an empty string.
            So I had to add some manual checks to convert it if the string is 0 length so we match SQL Server.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Database">
            <summary>
            High level storage to hold database meta information about tables, indexes,
            relationships, triggers, etc. To do quick metadata access Database object has clustered
            table schema. Every row includes metakey that points to a user table or table object.
            The meta key is "objectTypeId (e.g. table, index, constraint etc..); parentId (e.g. for
            index it's parent table header position in file); objectName"
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.DataStorage">
            <summary>
            General data storage. Manages any set of rows
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.name">
            <summary>
            Storage name
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.alias">
            <summary>
            Storage alias
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.header">
            <summary>
            Storage header object
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.currentRow">
            <summary>
            Current row. This is up-to date row data for current row position
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.satelliteRow">
            <summary>
            Counterpart row data for current row. This is the row data to be a
            temporarily buffered current row data or new data in update/append operations
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.topRow">
            <summary>
            Current top scope border.
            If current row is less or equal to this row, then
            bgnOfData flag is set
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.bottomRow">
            <summary>
            Current bottom scope border.
            If current row is greater or equal to this row, then
            endOfData flag is set
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.defaultRow">
            <summary>
            Extra row to keep default column values in
            in update and insert operations.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.bgnOfData">
            <summary>
            The flag shows that top of dataset is reached
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.endOfData">
            <summary>
            The flag shows that bottom of dataset is reached
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.updateBufferStatus">
            <summary>
            The flag signals to read from storage into currentRow buffer.
            Otherwise row is assumed to have up to date status
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.currentOperation">
            <summary>
            Flag signals about current operation proceeding on current row
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.storageHandle">
            <summary>
            This data storage handle
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.lockStorageHandle">
            <summary>
            Associated storage handle to use by locks
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.wrapperDatabase">
            <summary>
            Wrapper database storage
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.shared">
            <summary>
            Data storage could be shared
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.shareReadOnly">
            <summary>
            Data storage could be shared for read-only access
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.readOnly">
            <summary>
            Data storage instance could be read only
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.asynchCounter">
            <summary>
            Current row position synchronization that is
            the difference between logical row position
            in the recordset it is requested to be set and
            current row position.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.ordinaryFilters">
            <summary>
            list of ordinal filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.optimizedFilters">
            <summary>
            list of optimized filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.beforeCreateFilters">
            <summary>
            list of 'before' append filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.afterCreateFilters">
            <summary>
            list of 'after' append filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.beforeUpdateFilters">
            <summary>
            list of 'before' update filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.afterUpdateFilters">
            <summary>
            list of 'after' update filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.afterDeleteFilters">
            <summary>
            list of 'after' delete filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.translationList">
            <summary>
            List of rules to export/import row
            to/from the row in another data storage
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.silence">
            <summary>
            Suppress row creation exception when duplicate key found
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.connection">
            <summary>
            Parent connection
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.lockTimeOut">
            <summary>
            Timeout in microseconds
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.lockManager">
            <summary>
            Managed list of any locks applied to the data storage.
            These locks are managed in memory and do not
            followed by physical file locks always
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.forcedBeforeAppend">
            <summary>
            The flag forces not to check the 'before' append filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.forcedAfterAppend">
            <summary>
            The flag forces not to check the 'after' append filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.forcedBeforeUpdate">
            <summary>
            The flag forces not to check the 'before' update filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.forcedAfterUpdate">
            <summary>
            The flag forces not to check the 'after' update filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.forcedAfterDelete">
            <summary>
            The flag forces not to check the 'after' delete filters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.relationships">
            <summary>
            List of links supported between this and another data storages
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.activeLinks">
            <summary>
            The flag is used to optimize bypassing of inactive relationships.
            This flag is also artificially forced on or off by FreezeRelationships to turn off
            referential integrity.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.encryption">
            <summary>
            Encryption/decryption algorithm used by data storage
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.finalization">
            <summary>
            Helper variable allowing interruption for infinite finalization loops caused 
            by walking through inheriting and parent/child objects
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.#ctor(System.String,System.String,VistaDB.Engine.Internal.DirectConnection,VistaDB.Engine.Core.Database,VistaDB.Engine.Core.Cryptography.Encryption,VistaDB.Engine.Core.DataStorage)">
            <summary>
            Create data storage instance and open or create respective file
            </summary>
            <param name="fileName">Name of this data storage. It may be the file name this data storage resides</param>
            <param name="aliasName">Alias assigned to the data storage</param>
            <param name="connection">Parent connection</param>
            <param name="wrapperDatabase">Database storage that wrappers this storage</param>
            <param name="encryption">Encryption to use</param>
            <param name="clonedStorage">The storage this instance is clone of</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LookForColumn(System.Char[],System.Int32,System.Boolean)">
            <summary>
            Looks for column by column name in default row. 
            The name is looked at input character buffer starting from offset
            </summary>
            <param name="buffer">Character buffer</param>
            <param name="offset">offset to look for column name from</param>
            <param name="containSpaces">name could contain white spaces</param>
            <returns>Column instance from default row</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LookForColumn(System.String)">
            <summary>
            Looks for column by column name in default row. Column name can contain spaces
            </summary>
            <param name="name">Column name</param>
            <returns>Column instance from default row</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OpenStorage(VistaDB.Engine.Core.IO.StorageHandle.StorageMode,System.UInt64)">
            <summary>
            Open data storage in specified mode
            </summary>
            <param name="openMode">Data storage access mode</param>
            <param name="headerPosition">Position of data storage header</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.CreateStorage(VistaDB.Engine.Core.IO.StorageHandle.StorageMode,System.UInt64,System.Boolean)">
            <summary>
            Create storage and postpone or flush file update operations
            </summary>
            <param name="accessMode">access mode to use for new storage</param>
            <param name="headerPosition">Position of data storage header</param>
            <param name="commit">If true, changes will be applied immediately</param>
            <returns>Creation status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.CloseStorage">
            <summary>
            Close storage
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DeclareNewStorage(System.Object)">
            <summary>
            Sometime we do not need create storage but have to declare about its future creation only.
            That means creation process is just postponed, but some information that will be used in future 
            should be collected currently. That is done by DeclareNewStorage method
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.SetFreeCluster(System.UInt64,System.Int32)">
            <summary>
            Mark free space apartment by cluster in free space map
            </summary>
            <param name="clusterId">Position of the cluster in the file</param>
            <param name="pageCount">Page number allocated by the cluster</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.GetFreeCluster(System.Int32)">
            <summary>
            Request the free cluster
            </summary>
            <param name="pageCount">Page number allocated by the cluster</param>
            <returns>Position of the cluster in the file</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.Import(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Import data from source storage to this one
            </summary>
            <param name="sourceStorage">Source storage to import from</param>
            <param name="interruptOnError">Signals to interrupt import process when an error happens while importing a row</param>
            <returns>Import status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.Export(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Export data from this storage to destination one
            </summary>
            <param name="destinationStorage">Destination storage to export data</param>
            <param name="interruptOnError">Signals to interrupt export process when an error happens</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ZapStorage(System.Boolean)">
            <summary>
            Delete all rows in this storage
            </summary>
            <returns>Proceeding status</returns>
            <param name="commit">If it is set, changes should be applied immediately</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.CleanUpDiskSpace(System.Boolean)">
            <summary>
            Execute clearing the file space allocated to this data storage
            </summary>
            <param name="commit">Apply changes to file immediately</param>
            <returns>Cleaning status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.SetRelationship(VistaDB.Engine.Core.DataStorage,VistaDB.Engine.Core.DataStorage,VistaDB.Engine.Core.Relationships.Type,VistaDB.Engine.Core.Scripting.EvalStack,System.Boolean)">
            <summary>
            Add relationship with another data storage. For example, it should be set 
            to activate relationships between index and rowset data storages
            </summary>
            <param name="masterStorage">Master storage the link is evaluated from</param>
            <param name="slaveStorage">Slave storage the link is attached to</param>
            <param name="linkType">The kind of link</param>
            <param name="linkProcessing">The link evaluation process</param>
            <param name="maxPriority">Treat this relationship at first order</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ResetRelationship(VistaDB.Engine.Core.DataStorage,VistaDB.Engine.Core.DataStorage)">
            <summary>
            Delete relationship from relationships treated by this data storage
            </summary>
            <param name="masterStorage">Master storage the link is evaluated from</param>
            <param name="slaveStorage">Slave storage the link is attached to</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.GetColumnValue(System.Int32,VistaDB.VistaDBType,VistaDB.Engine.Core.Row)">
            <summary>
            Get column value from current row
            </summary>
            <param name="rowIndex">Column index in the row</param>
            <param name="crossType">Data type to convert to</param>
            <param name="sourceRow">The row to get column value from</param>
            <returns>Related column value in source row</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.PutColumnValue(System.Int32,VistaDB.VistaDBType,VistaDB.Engine.Core.Row,VistaDB.Engine.Internal.IValue)">
            <summary>
            Put column value to satellite row before update, insert operations
            </summary>
            <param name="rowIndex">Column index in destination row</param>
            <param name="crossType">Data type to convert before putting to the destination row</param>
            <param name="destinationRow">The destination row to put column to</param>
            <param name="columnValue">Column value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LockRow(System.UInt32,System.Boolean)">
            <summary>
            Lock row by row id
            </summary>
            <param name="rowId">Row id to lock</param>
            <param name="userLock">User lock mark</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnLockRow(System.UInt32,System.Boolean,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="rowId"></param>
            <param name="userLock"></param>
            <param name="actualLock">Upon return points out the actual lock made in file or cache</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.UnlockRow(System.UInt32,System.Boolean,System.Boolean)">
            <summary>
            Unlock row by row id
            </summary>
            <param name="rowId">Row id to unlock</param>
            <param name="userLock">user lock mark</param>
            <param name="instantly">Apply lock immediately. Don't postpone it</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LockStorage">
            <summary>
            Lock the whole storage
            </summary>
            <returns>Successfully locked status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnLockStorage">
            <summary>
            
            </summary>
            <returns>check new version status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.UnlockStorage(System.Boolean)">
            <summary>
            Unlock the whole storage
            </summary>
            <param name="doNotWaitForSynch">Apply unlock immediately, if lock counter is zero. Don't postpone it until unlock synchronization done</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LowLevelLockRow(System.UInt32)">
            <summary>
            Lock row according to lock specification. Apply lock to respective place of the storage
            </summary>
            <param name="rowId">Row id to lock</param>
            <returns>Successfully locked status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LowLevelUnlockRow(System.UInt32)">
            <summary>
            Unlock row according to lock specification
            </summary>
            <param name="rowId">Row id to lock</param>
            <returns>Successfully locked status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LowLevelLockStorage(System.UInt64,System.Int32)">
            <summary>
            Lock storage according to lock specification
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.LowLevelUnlockStorage(System.UInt64,System.Int32)">
            <summary>
            Unlock storage according to lock specification
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ClearCurrentRow">
            <summary>
            Clear data in current row
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ClearSatteliteRow">
            <summary>
            Clear data in satellite row
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.BlockCreateGenerators(VistaDB.Engine.Core.Row)">
            <summary>
            Deactivate default value generators when respective column value have already been set in insertion
            </summary>
            <param name="newRow">Satellite row, containing new values is expected here</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.BlockUpdateGenerators(VistaDB.Engine.Core.Row)">
            <summary>
            Deactivate default value generators when respective 
            column value have already been updated in updates
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.Top">
            <summary>
            Move to the first logical row reference
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.Bottom">
            <summary>
            Move to the last logical row reference
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.Synch">
            <summary>
            synchronize physical row entry according to the current logical position
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ResetAsynch">
            <summary>
            Reset asynchronous counter value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ImportRow(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row)">
            <summary>
            Import row from source storage to satellite row of this storage
            </summary>
            <param name="sourceRow">Source row</param>
            <param name="destinationRow">Destination row</param>
            <returns>Importing status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ActivateLinks">
            <summary>
            Turn on referential integrity for the storage based upon the relationships list.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.CreateLinks">
            <summary>
            Create referential integrity linked structures for the storage based upon the relationships list.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.UpdateLinks">
            <summary>
            Update referential integrity links for the storage based upon the relationships list.
            Each relationships Update() function is called to allow them to update.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DeleteLinks">
            <summary>
            Remove referential integrity linked relationships for the storage based upon the relationships list.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.CommitLinkFrom(VistaDB.Engine.Core.DataStorage)">
            <summary>
            Commit the foreign key links from another table.  This could be a foreign key or another type of relationship 
            (On Update / On Delete / etc)
            </summary>
            <param name="externalStorage"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoAfterConstruction(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Finalizes instance construction by descendant objects
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoCreateHeaderInstance(System.Int32,System.Globalization.CultureInfo,VistaDB.Engine.Core.DataStorage)">
            <summary>
            Called by DataStorage to create header instance by descendants. 
            Descendants should override this method if they need
            to manage related header class
            </summary>
            <param name="pageSize">Page size used by data storage</param>
            <param name="culture">Culture info used by data storage</param>
            <param name="clonedStorage">The data storage this instance is clone of</param>
            <returns>Storage header object</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoAllocateCurrentRow">
            <summary>
            Virtual method should instantiate CurrentRow object instance by the descendants
            </summary>
            <returns>CurrentRow instance</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoAllocateSatteliteRow">
            <summary>
            Virtual method should instantiate SatteliteRow object instance by the descendants.
            By default it instantiates the Row structure that is the copy of CurrentRow
            </summary>
            <returns>SatteliteRow instance</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoAllocateTopRow">
            <summary>
            Virtual method should instantiate TopRow object instance by the descendants.
            By default it instantiates the Row structure that is the copy of CurrentRow
            </summary>
            <returns>TopRow instance</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoAllocateBottomRow">
            <summary>
            Virtual method should instantiate BottomRow object instance by the descendants.
            By default it instantiates the Row structure that is the copy of CurrentRow
            </summary>
            <returns>BottomRow instance</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoAllocateDefaultRow">
            <summary>
            Instantiate meta row information
            </summary>
            <returns>IMetaRow instance</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnActivateHeader(System.UInt64)">
            <summary>
            Descendants should overload this method to do related work
            </summary>
            <param name="position">Header position in file</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnCreateHeader(System.UInt64)">
            <summary>
            Descendants should overload this method to do related work
            </summary>
            <param name="position">File position the header data is located</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnDeactivateHeader">
            <summary>
            Descendants should overload this method to do related work
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnAllocateColumns">
            <summary>
            The descendants should overload this method to do related work
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnDeallocateColumns">
            <summary>
            The descendants should overload this method to do related work
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnAllocateRows">
            <summary>
            The descendants should overload this method to do related work
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnDeallocateRows">
            <summary>
            The descendants should overload this method to do related work
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnOpenStorage(VistaDB.Engine.Core.IO.StorageHandle.StorageMode,System.UInt64)">
            <summary>
            Descendant should override this method to open respective type storage.
            In the end this basic method should be called
            </summary>
            <param name="openMode"></param>
            <param name="headerPosition"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnCreateStorage(VistaDB.Engine.Core.IO.StorageHandle.StorageMode,System.UInt64)">
            <summary>
            Descendant should override this method to open respective type storage.
            In the end this basic method should be called
            </summary>
            <param name="accessMode">access mode to use for new storage</param>
            <param name="headerPosition">Position of data storage header</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnCloseStorage">
            <summary>
            Close storage. All child objects should make sure they still call this base method as well.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnDeclareNewStorage(System.Object)">
            <summary>
            Default realization for Declare new storage. Descendants can overload this method. 
            Nothing is done by default
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnGetFreeCluster(System.Int32)">
            <summary>
            Request of free cluster. Descendants may overload this method
            to use special free space policy. By default free space is always allocated
            in the end of file
            </summary>
            <param name="pageCount">number of pages in the cluster</param>
            <returns>Position of allocated cluster</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnSetFreeCluster(System.UInt64,System.Int32)">
            <summary>
            Mark free page in free space map (pending a commit/flush).
            Descendants may overload this method. By default it does nothing
            </summary>
            <param name="clusterId">Position of free cluster</param>
            <param name="pageCount">Number of pages in the cluster</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnAttachLockStorage(System.UInt64)">
            <summary>
            Request to open and/or attach another data storage in order to 
            provide virtual lock policy for this data storage. Descendants may overload this method. 
            By default the data storage uses itself instance to keep locking on it
            </summary>
            <param name="headerPosition">The header position to use as unique hint value in order to recognize data storage unambiguously</param>
            <returns>Resulting status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnDetachLockStorage(System.Boolean)">
            <summary>
            Called by data storage to detach and/or close associated storage that 
            was used to provide virtual lock policy. Descendants may overload this method to do related work.
            By default it is done nothing here
            </summary>
            <param name="external">Lock file is external file</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnImport(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Import data from source storage to this one. You may override descendant to implement another import process
            </summary>
            <param name="sourceStorage">Source storage to import from</param>
            <param name="interruptOnError">Signals to interrupt import process when an error happens while importing a row</param>
            <returns>Import status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnInitializeImport(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Initialize data import process. The method is called by Import method.
            By default this method returns false status, that is followed by data import interrupting.
            Override this method by descendants to care of correct return status. 
            </summary>
            <param name="sourceStorage">Source storage to import from</param>
            <param name="interruptOnError">Signals to interrupt import process when an error happens</param>
            <returns>Import staring status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnFinalizeImport(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Finalize data import process. The method is called by Import method.
            By default this method returns true. Override this method by descendants 
            to do specific data import finalization
            </summary>
            <param name="sourceStorage">Source storage to import from</param>
            <param name="interruptOnError">Signals to interrupt import process when an error happens</param>
            <returns>Import finalizing status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnExport(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Default method to export data from this storage to destination one. Override this method by
            a descendant to implement another way to export data 
            </summary>
            <param name="destinationStorage">Destination storage to export data</param>
            <param name="interruptOnError">Signals to interrupt export process when an error happens</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnImportRow(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row)">
            <summary>
            Default way to import row. 
            It just copies the whole external row data to satellite row
            </summary>
            <param name="sourceRow">Source row</param>
            <param name="destinationRow">Destination row</param>
            <returns>Importing status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnExportRow(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row)">
            <summary>
            Default way to export row. It just copies current row 
            data to external satellite row
            </summary>
            <param name="sourceRow">Source row</param>
            <param name="destinationRow">Destination row</param>
            <returns>Exporting status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnZapStorage(System.Boolean)">
            <summary>
            Default method deletes all rows in storage data. It just checks
            correct access mode to proceed
            </summary>
            <returns>Proceeding status</returns>
            <param name="commit">If it is set, changes should be applied immediately. Don't make data caching</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnCleanUpDiskSpace(System.Boolean)">
            <summary>
            Execute default clearing the file space allocated to this data storage. 
            It does nothing by default but return false status
            </summary>
            <param name="commit">Apply changes to file immediately</param>
            <returns>Cleaning status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnGetColumnValue(System.Int32,VistaDB.VistaDBType,VistaDB.Engine.Core.Row)">
            <summary>
            Default way to get column value from current row. 
            It gets respective column by index
            </summary>
            <param name="rowIndex">Column index in the source row</param>
            <param name="crossType">Data type to convert to</param>
            <param name="sourceRow">The row to get column value from</param>
            <returns>Related column value in the source row</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnPutColumnValue(System.Int32,VistaDB.VistaDBType,VistaDB.Engine.Core.Row,VistaDB.Engine.Internal.IValue)">
            <summary>
            Default way to put column value
            </summary>
            <param name="rowIndex">Column index in destination row</param>
            <param name="crossType">Data type to convert before putting to the destination row</param>
            <param name="destinationRow">The destination row to put column to</param>
            <param name="columnValue">Column value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnLowLevelLockRow(System.UInt32)">
            <summary>
            Lock row according to lock specification. Override this method to do it properly by descendants
            </summary>
            <param name="rowId">Row id to lock</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnLowLevelUnlockRow(System.UInt32)">
            <summary>
            Unlock row according to lock specification. Override this method to do it properly by descendants
            </summary>
            <param name="rowId">Row id to unlock</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnLowLevelLockStorage(System.UInt64,System.Int32)">
            <summary>
            Lock storage according to lock specification. Override this method to do it properly by descendants
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnLowLevelUnlockStorage(System.UInt64,System.Int32)">
            <summary>
            Unlock storage according to lock specification. Override this method to do it properly by descendants
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnUpdateCurrentRow">
            <summary>
            Called by UpdateCurrentRow to
            update current row buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnFlushCurrentRow">
            <summary>
            Called by FlushCurrentRowBuffer to
            flush updated, deleted or inserted row data
            </summary>
            <returns>Resulting status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnSynch(System.Int32)">
            <summary>
            Core synchronizing routine to carry out
            current logical synchronization that is set by asynchCounter
            </summary>
            <remarks>This has NOTHING to do with Sync Services.  This apparently is to ensure the disk and block are in sync with each other.</remarks>
            <param name="asynchCounter">Current logical synchronization</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.OnSeekRow(VistaDB.Engine.Core.Row,System.Boolean)">
            <summary>
            Tries to set current row position according to input row.
            Respects all active filters. If row hasn't been found the 
            current position is set to the end of storage
            </summary>
            <param name="row">Pattern row to set in according with</param>
            <param name="partialMatching">The key found may just partially match the pattern</param>
            <returns>Found status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ActivateHeader(System.UInt64)">
            <summary>
            Called by DataStorage to read header data at 'position'
            and activate header information
            </summary>
            <param name="position">File position to read the header</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.CreateHeader(System.UInt64)">
            <summary>
            Called by DataStorage to create header by descendants
            </summary>
            <param name="position">File position the header data are placed to</param>
            <returns>Creation status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DeactivateHeader">
            <summary>
            Called by DataStorage to allow descendants deactivate the header instance
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.AllocateDataStructure">
            <summary>
            Called by DataStorage to care of columns and rows allocation
            </summary>
            <returns>Allocation status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DeallocateDataStructure">
            <summary>
            Called by DataStorage to care of columns and rows deallocation
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.AllocateRows">
            <summary>
            Called by DataStorage to care of rows apartment allocation and initialization
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DeallocateRows">
            <summary>
            Called by DataStorage to care of rows apartment deallocation
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.CreateDefaultRow">
            <summary>
            Create default row, containing default column data in data storage
            </summary>
            <returns>creation status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ActivateDefaultRow">
            <summary>
            Activate default row, containing default column data in data storage
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.InitializeAccessFlags(VistaDB.Engine.Core.IO.StorageHandle.StorageMode)">
            <summary>
            Initialize data storage this instance access flags
            </summary>
            <param name="mode"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.AttachLockStorage(System.UInt64)">
            <summary>
            Request to open and/or attach another data storage in order to 
            provide virtual lock policy for this data storage. 
            It is called by data storage instance itself
            </summary>
            <param name="headerPosition">The header position to use as unique hint value in order to recognize data storage unambiguously</param>
            <returns>Resulting status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DetachLockStorage">
            <summary>
            Called by data storage to detach and/or close associated storage that 
            was used to provide virtual lock policy
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.InitializeImport(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Initialize data import process. The method is called by Import method
            </summary>
            <param name="sourceStorage">Source storage to import from</param>
            <param name="interruptOnError">Signals to interrupt import process when an error happens while importing a row</param>
            <returns>Import staring status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.FinalizeImport(VistaDB.Engine.Core.DataStorage,System.Boolean)">
            <summary>
            Finalize data import process. The method is called by Import method.
            </summary>
            <param name="sourceStorage">Source storage to import from</param>
            <param name="interruptOnError">Signals to interrupt import process when an error happens</param>
            <returns>Import finalizing status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.ExportRow(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row)">
            <summary>
            Export row from this storage to satellite row of destination storage
            </summary>
            <param name="sourceRow">Source row</param>
            <param name="destinationRow">Destination row</param>
            <returns>Exporting status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.UpdateCurrentRow">
            <summary>
            Updates current row
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.FlushCurrentRow">
            <summary>
            Final destination to update, delete or insert row
            </summary>
            <returns>resulting status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.Destroy">
            <summary>
            Internal cleanup routine called by Dispose
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.PassTransaction(VistaDB.Engine.Core.Row,System.UInt32)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DataStorage.DoGettingAnotherTransactionStatus(System.UInt32)">
            <summary>
            Test if the row has active status in another active or rolled back transaction
            </summary>
            <param name="transactionId"></param>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.Version">
            <summary>
            Current version of this data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.IsNewVersion">
            <summary>
            New version signals about the data storage has been updated by 
            another client
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.IsDeleteOperation">
            <summary>
            Helper for descendant classes.
            It checks current delete operation status
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.NoLocks">
            <summary>
            Determine if we need to use locks for this data storage or not.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.StorageId">
            <summary>
            Unique ID assigned to the physical data storage
            (all instances share the same id)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.Handle">
            <summary>
            File storage handle. When data storage nested
            this handle is the instance of the parent data storage handle
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.Header">
            <summary>
            Header object
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.ParentConnection">
            <summary>
            Connection this data storage works in
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.BgnOfSet">
            <summary>
            Beginning of dataset flag
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.EndOfSet">
            <summary>
            End of dataset flag
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.Culture">
            <summary>
            Culture info assigned to the data storage. 
            This information is put to the header.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.CurrentRow">
            <summary>
            Current row. This is up-to date row data for current row position
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.SatelliteRow">
            <summary>
            Satellite row. This is the row data to be a
            temporarily buffered current row or the data for updated/appended row
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.TopRow">
            <summary>
            Most possible top row data.
            If current row is less or equal to this row, then
            BgnOfSet flag is set
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.BottomRow">
            <summary>
            Most possible bottom row data.
            If current row is greater or equal to this row, then
            EndOfSet flag is set
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.FilteredRowCount">
            <summary>
            Row count available in data storage when optimized filter is set
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.TranslationList">
            <summary>
            Column translation list to carry out data export/import process
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.SuppressErrors">
            <summary>
            Suppress the exception about unique key duplication
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.IsShared">
            <summary>
            Helper to check shared status of this data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.IsReadOnly">
            <summary>
            Helper to check read-only status of this data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.IsShareReadOnly">
            <summary>
            Helper to check read-only share access mode of this data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.IsTemporary">
            <summary>
            Temporary status of this data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.WrapperDatabase">
            <summary>
            Wrapper database storage this data storage is nested in
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.IsTransactionLogged">
            <summary>
            Is this current data storage object being transaction logged?  
            False by default - only set to true if we are in a transaction
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.RowCount">
            <summary>
            Physical row count available in data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.CaseSensitive">
            <summary>
            The data are case sensitive
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.Alias">
            <summary>
            Alias of data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.Name">
            <summary>
            Name of data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.EncryptionKey">
            <summary>
            EncryptionKey assigned to the data storage by a user (these are not generated for internal use)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.Encryption">
            <summary>
            Encryption object instantiated with information from an Encryption Key
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.LowScope">
            <summary>
            Low scope row. By default it simply returns TopRow
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.HighScope">
            <summary>
            High scope row. By default it simply returns BottomRow
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.DataStorage.PostponedSynchronization">
            <summary>
            Allow postponed synchronization for relationships
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBOperationCallbackStatus">
             <summary>
             Information messages passed by the engine during time consuming operations like pack and repair.
             </summary>
             <example>
             <code lang="cs">
             public void PackingFunction
             {
             	IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
            		// You do not have to provide a path - Dot Net looks in the current working directory by default.
            		DDAObj.PackDatabase(fileName, null, false, new OperationCallbackDelegate(this.OnPackInfo));
             }
             	
             public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo operationDelegate )
             {
            		if( operationDelegate.Progress &lt; 0 )
            			return;
            
             	int ProgressPercent = operationDelegate.Progress;
             
             	string ProgressText = String.Concat("Performing ",operationDelegate.Operation.ToString()," on ",operationDelegate.ObjectName.ToString(),":");
            	}
             </code>
             </example>
             <seealso cref="T:VistaDB.DDA.OperationCallbackDelegate">Operation Information progress delegate for callback</seealso>
             <seealso cref="M:VistaDB.DDA.IVistaDBDDA.PackDatabase(System.String,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Boolean,VistaDB.DDA.OperationCallbackDelegate)"/>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBOperationCallbackStatus.Progress">
            <summary>
            Progress status for current operation as a percentage
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBOperationCallbackStatus.Operation">
            <summary>
            Current operation
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBOperationCallbackStatus.ObjectName">
            <summary>
            Name of the object that the current operation is being applied
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBOperationCallbackStatus.Message">
            <summary>
            Extended message information for the operation being performed against the ObjectName
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.Operation.Insert">
            <summary>
            Insert operation is proceeding
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.Operation.Update">
            <summary>
            Update operation is proceeding
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.Operation.Delete">
            <summary>
            Delete operation is proceeding
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.Operation.Synch">
            <summary>
            Synchronization
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.Operation.Seek">
            <summary>
            Signals about looking for the record row position
            synchronization, when it is not know asyncCounter
            value to bypass over, but it is known row data to look for
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DataStorage.Operation.None">
            <summary>
            None of active operations is proceeding
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Index.tree">
            <summary>
            Index tree
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Index.forcedTreeSeek">
            <summary>
            Force the looking for the key in index tree
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Index.dynamicDescend">
            <summary>
            Dynamical descending status
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Index.currentPrimaryKey">
            <summary>
            Current primary key value in update/delete operations
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.DoSplitPolicy(System.Int32)">
            <summary>
            Defines number of keys to distribute between two nodes
            </summary>
            <param name="oldCount">Number of keys on the node that is being split</param>
            <returns>Number of keys to left at the old node. 
            The rest is put to new right node</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.DoCheckIfRelated(VistaDB.Engine.Core.Scripting.EvalStack)">
            <summary>
            Check if primary key could be used to 
            set the relationships with foreign key
            </summary>
            <param name="fkEvaluator">foreign key p-code</param>
            <returns>The answer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.OnUpdateRow(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row)">
            <summary>
            Check do we need to update index key
            </summary>
            <param name="oldKey">Old key</param>
            <param name="newKey">New key</param>
            <returns>True result requests to update by new key</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.MarkOptimizedStatus(VistaDB.Engine.Core.RowIdFilter,VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row,System.Boolean,System.Int32[])">
            <summary>
            Mark a range of an index in a given RowIdFilter to be True or to be Null.  (Default state is False.)
            </summary>
            <param name="filter">The RowIdFilter to mark.</param>
            <param name="lowScope">The key Row for the start of the range (in index order).</param>
            <param name="highScope">The key Row for the end of the range (in index order).</param>
            <param name="forcedTrueStatus">Whether (true) to mark range with True or (false) to mark range with Null.</param>
            <param name="excludeNullsKeyOrders">Optional int array specifying key column orders which should exclude NULLs.
            (pass null if not used)</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.BuildFiltermap(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row,System.Boolean,System.Int32[])">
            <summary>
            Build an IOptimizedFilter (a RowIdFilter) and mark a specified range as True and mark NULL range as Null 
            (excludeNulls == true), or mark just the NULL range as True (excludeNulls == false).  (The rest is False.)
            </summary>
            <param name="lowConstant">The key Row representing the low boundary (start of range in index order).</param>
            <param name="highConstant">The key Row representing the high boundary (end of range in index order).</param>
            <param name="excludeNulls">Whether (true) to mark the specified range True and exclude NULL range as Null
            or (false) to just mark the specified range as True and not consider the NULL range.</param>
            <param name="excludeNullsKeyOrders">Optional int array specifying key column orders which should exclude NULLs.
            (pass null if not used)</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.GetScopeKeyCount">
            <summary>
            Scans index and calculates the keys in it, taking current scope operators into account.
            (WARNING: CAUSES SIDE-EFFECTS:  The current row position of the parent table becomes undefined/EOF)
            </summary>
            <returns>The number of keys in the current scope. 
            If no current scope set the method calculates total number of rows in table.</returns>
            <remarks>After execution the current row position of the parent table is undefined</remarks>
        </member>
        <member name="P:VistaDB.Engine.Core.Indexing.Index.AllowPostponing">
            <summary>
            Allow postponed reading the extended data types in this data storage
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.Index.Type">
            <summary>
            Type of the index
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.StorageHeader">
            <summary>
            Data storage header
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Header">
            <summary>
            Simple header
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Row">
            <summary>
            General record. It's used or inherited by many objects. 
            They are, for example, table rows, index keys, table 
            headers, index node headers etc. The basic implementation
            uses variable length row buffer
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBRow">
            <summary>
            Interface to a VistaDBRow object
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBRow.ClearModified">
            <summary>
            Clear modified flags for all columns in the row. 
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBRow.Compare(VistaDB.DDA.IVistaDBRow)">
            <summary>
            Compare with another key row column by column taking ascending column information into account
            </summary>
            <param name="row">The row to compare with</param>
            <returns>Zero if rows are equal, -1 if this row less and 1 otherwise</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBRow.CompareKey(VistaDB.DDA.IVistaDBRow)">
            <summary>
            Compare with another key row column by column taking ascending column 
            information and RowId into account. An equivalent of applying the Compare method. 
            If Compare results into 0 value, the RowId are being compared then. 
            The method may be used for IVistaDBTable rows as well.
            </summary>
            <param name="key">The key to compare with</param>
            <returns>Zero if rows are equal, -1 if this row less and 1 otherwise</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBRow.InitTop">
            <summary>
            Initialize the columns in the row with the most top column values. RowId is set to uint.MaxValue
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBRow.InitBottom">
            <summary>
            Initialize the columns in the row with the most bottom column values. RowId is set to uint.MinValue
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRow.Count">
            <summary>
            Number of columns contained in the row
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRow.Item(System.Int32)">
            <summary>
            Gets a column by its index in the row
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRow.Item(System.String)">
            <summary>
            Gets a column by its name. Name should be unique in the row
            </summary>
            <param name="name">Name of the column to get - This is not case sensitive</param>
            <returns>When found it returns respective column, otherwise null</returns>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRow.RowId">
            <summary>
            Unique row identifier
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.MinRowId">
            <summary>
            Calculates minimum row id number that is possible
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.MaxRowId">
            <summary>
            Returns maximum row id number that is possible
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.metaInfo">
            <summary>
            Extra meta column to collect meta information kept by row.
            That are row id, row version etc..
            </summary>
            <remarks>Internal use only</remarks>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.ascending">
            <summary>
            Ascend comparing flag
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.buffer">
            <summary>
            Row buffer. This is the byte array 'image' of any record 
            to put data in or get data from the external file
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.position">
            <summary>
            This row position in data storage
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.alignment">
            <summary>
            The space allocated in the storage must have page borders alignment
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.#ctor(System.UInt32,System.UInt32,System.UInt64,System.Boolean,VistaDB.Engine.Core.Cryptography.Encryption,System.Int32[])">
            <summary>
            Default record constructor.
            </summary>
            <param name="rowId">row id</param>
            <param name="rowVersion">row version</param>
            <param name="referencedPosition">Extra data position tracked by the row</param>
            <param name="ascending">Ascending in row comparing</param>
            <param name="encryption">Encryption to use</param>
            <param name="activeMask">The array of byte that points to the columns 
            participating compare process in comparing between tow rows</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.#ctor(VistaDB.Engine.Core.Row)">
            <summary>
            Row copy constructor. Set rowid, row version to 0 and row reference to EmptyReference
            It doesn't copy column values, but column structure only.
            </summary>
            <param name="row">external row to copy column structure from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.GetEncryptedMemoryApartment(VistaDB.Engine.Core.Row)">
            <summary>
            Calculate number of bytes to store the whole record.
            Takes in account x8 bytes alignment for encrypted columns
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.CompareTpVisible(VistaDB.Engine.Core.Row)">
            <summary>
            The same as above CompareTpHidden, but transactions are not took into account
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.FormatHeader(System.Byte[],System.Int32,VistaDB.Engine.Core.Row)">
            <summary>
            Copy header data to the byte buffer and set null bits array
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.UnformatHeader(System.Byte[],System.Int32,System.Boolean,VistaDB.Engine.Core.Row)">
            <summary>
            initialize header data in according to information in byte buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.FormatEncryptedColumns(System.Byte[],System.Int32,VistaDB.Engine.Core.Row)">
            <summary>
            Copy columns data to the byte buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.UnformatEncryptedColumns(System.Byte[],System.Int32,VistaDB.Engine.Core.Row)">
            <summary>
            Initialize columns in according to information in byte buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.AllocateBuffer(System.Int32)">
            <summary>
            Allocate record buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.FormatRowBuffer(System.Byte[],System.Int32,VistaDB.Engine.Core.Row)">
            <summary>
            Put data to external buffer by offset
            </summary>
            <param name="buffer">external buffer</param>
            <param name="offset">offset</param>
            <param name="precedenceRow">Previous row to pack in according to</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.FormatRowBuffer(VistaDB.Engine.Core.Row)">
            <summary>
            Format this instance record buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.UnformatRowBuffer(System.Byte[],System.Int32,VistaDB.Engine.Core.Row)">
            <summary>
            Scan data in external buffer by offset
            </summary>
            <param name="buffer">external buffer</param>
            <param name="offset">offset</param>
            <param name="precedenceRow">Previous row to pack in according to</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.UnformatRowBuffer">
            <summary>
            Unformat this instance record buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.InitTop">
            <summary>
            Reset the top row to be empty, not edited or a current reference
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.InitBottom">
            <summary>
            Reset the bottom row to be empty
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.FormatColumns(System.Byte[],System.Int32,VistaDB.Engine.Core.Row)">
            <summary>
            Copy columns data to the byte buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.AppendColumn(VistaDB.Engine.Internal.IColumn)">
            <summary>
            Append column value to this row
            </summary>
            <param name="column">Column to append</param>
            <returns>Column index in the row</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.GetMemoryApartment(VistaDB.Engine.Core.Row)">
            <summary>
            Calculate number of bytes in the buffer to store the current record content.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.RowId">
            <summary>
            Unique row id
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.RowVersion">
            <summary>
            The row generation number. Increased by every new transaction or transaction level
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.Position">
            <summary>
            Row position at data storage file. It's helper run-time only value
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.FormatLength">
            <summary>
            Set formated buffer length to read/write to/from storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.RefPosition">
            <summary>
            Referenced data position kept by the row
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.VistaDB#Engine#Internal#IRow#Item(System.Int32)">
            <summary>
            Get column by its index
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Row.RowScope">
            <summary>
            Shows updated data scope in header. It is used for optimization purpose
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Row.Column">
            <summary>
            General column. Represents atomic value in row.
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBColumn">
            <summary>
            Column interface
            </summary>
            <remarks>
            You should not attempt to instantiate an object of this type with the new operator.
            </remarks>
        </member>
        <member name="T:VistaDB.IVistaDBValue">
            <summary>
            Boxed value
            </summary>
        </member>
        <member name="P:VistaDB.IVistaDBValue.Value">
            <summary>
            A value corresponding to VistaDB type implicitly converted to the object type
            </summary>
        </member>
        <member name="P:VistaDB.IVistaDBValue.IsNull">
            <summary>
            Helper property to check if value is assigned with null
            </summary>
        </member>
        <member name="P:VistaDB.IVistaDBValue.Type">
            <summary>
            VistaDB specified data type
            </summary>
        </member>
        <member name="P:VistaDB.IVistaDBValue.SystemType">
            <summary>
            Native system type corresponding to the VistaDBType
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBColumn.Compare(VistaDB.DDA.IVistaDBColumn)">
            <summary>
            Compare between two column values
            </summary>
            <param name="column">The column to compare with</param>
            <returns>0 if equal; 1 if this column is greater; -1 if this column is less</returns>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumn.Name">
            <summary>
            Column name
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumn.MaxLength">
            <summary>
            Maximum number of chars or bytes allocated in database. 
            This value should be multiplied by actual page size 
            expressed in kilobytes for ExtendedType.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumn.MinValue">
            <summary>
            Minimum column value for respective VistaDBType
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumn.MaxValue">
            <summary>
            Maximum column value for respective VistaDBType
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumn.AllowNull">
            <summary>
            Column value can have null value
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumn.ReadOnly">
            <summary>
            Column value cannot be changed in update operations
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumn.Modified">
            <summary>
            The flag is set to modified column status when a value assigned to the column
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.IColumn.GetValueHashCode">
            <summary>
            Get a hash code for the current value of this IVistaDBColumn such that if two IVistaDBColumn
            instances compare as equal they will also have the same hash code.
            </summary>
            <returns>0 if IsNull, otherwise a hash code for the current value</returns>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBColumnAttributes">
            <summary>
            Column attributes. By default the column attributes are:
            AllowNull = true, ReadOnly = false, Encrypted = true( if database encrypted ), Packed = false
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBColumnAttributes.Compare(VistaDB.DDA.IVistaDBColumnAttributes)">
            <summary>
            Compares a given column attributes and returns difference from current column
            </summary>
            <param name="attributes">Attributes to compare with</param>
            <returns>Difference between attributes</returns>
            <remarks>Column name comparison is case insensitive</remarks>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.Name">
            <summary>
            Column's description
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.Description">
            <summary>
            Column's description.  The description length is limited depending upon the current pagesize.
            <remarks>SQL Server does not have a direct mapping for this property, but you can store description as extended data in SQL Server.</remarks>
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.Caption">
            <summary>
            Caption.  This has been marked as obsolete and will be removed from a future build.
            <remarks>This feature is not SQL Server compatible.</remarks>
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.CodePage">
            <summary>
            Code page to encode character column type in file storage. 
            Non character type always has this value set to 0
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.Encrypted">
            <summary>
            In older VistaDB formats, indicates whether each column is specifically encrypted on disk.  As of VistaDB 5,
            encryption (when enabled) is applied to all database data pages regardless of this property.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.Packed">
            <summary>
            Flag to represent if the column should be packed using LZH compression before being written to disk.
            Packing a column that has lots of redundant text can result in considerable space savings on disk.  
            Packing and unpacking the data for retrieval adds extra CPU needs to the column.  Performing like or where
            clause operations on a packed column that is not indexed will be considerably slower than a normal column.
            This is only when the data is written to disk.  A 100MB column compressed to 10MB will still consume 100MB when loaded into a Row or DataSet.
            <remarks>Only Text, NText, Images (Large object data types) may use this flag.</remarks>
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.RowIndex">
            <summary>
            Read only zero based index for this column in the current row
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.ExtendedType">
            <summary>
            Flag to represent that this column is an extended data type (it is not stored with the rowdata of fixed columns).
            Image, Text, NText are all normally stored as extended row data because they cannot fit within the row data space.
            Extended columns are slower to search, sort etc as extra disk seeks and row loads are required to operate against these columns.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.FixedType">
            <summary>
            Flag to indicate a fixed data size is used to represent this column.  
            These types of columns are stored in the row data.  The maximum size of the fixed row data is based upon your pagesize.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.IsSystem">
            <summary>
            Flag meaning this column is a System column and may not be dropped or manipulated.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributes.UniqueId">
            <summary>
            Unique identifier for column that doesn't depend on name or other attributes.
            This is used by DDA in AlterTable functionality.  This Id is internal to the engine and in most cases should not be used in
            user code except to compare against two columns and see if they are the same.  Testing for anything other than equality does not
            convey any meaning.  If they are equal they are the same column, but the numbers do not signify versioning.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.Column.systemTypeMap">
            <summary>
            The map of system object to vistadb type
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.Column.type">
            <summary>
            Column type
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.Column.val">
            <summary>
            Column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.Column.bufferLength">
            <summary>
            Buffer length to keep this value in record buffer
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.Column.rowIndex">
            <summary>
            Index of this column in the row
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.Column.edited">
            <summary>
            Changed value run-time status
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.Column.descending">
            <summary>
            Use descending in comparing operations
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.#cctor">
            <summary>
            Initializer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.#ctor(System.Object,VistaDB.VistaDBType,System.Int32)">
            <summary>
            Default column constructor
            </summary>
            <param name="val">Initial column value</param>
            <param name="type">VistaDBDataType for this column value instance</param>
            <param name="bufferLength">maximum byte count to store the column value in record buffer</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.#ctor(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Copy constructor
            </summary>
            <param name="column">column instance to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.AssignAttributes(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Set meta information
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.AssignAttributes(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Set meta information
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.Duplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <param name="padRight">pad right character type with white space</param>
            <returns>New instance of this type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.OnDuplicate(System.Boolean)">
            <summary>
            Instance copy virtual generator.
            </summary>
            <param name="padRight">signals to pad character columns with white spaces</param>
            <returns>Null by default</returns>
            <remarks>Need to be overloaded by inherit data types</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Overridden. Put column value to variable length buffer of bytes.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Overridden. Get column value from buffer of bytes.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.GetBufferLength(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Current buffer length. 
            The number of bytes to be actually allocated for current value. 
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.DoMinus(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Subtract the argument from this instance (this - arg).
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.DoGetMinusBy(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Subtract this instance from the argument (arg - this).
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.DoPlus(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Expands value to this column type and adjust current value
            </summary>
            <param name="column">Right operand</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.DoDivideBy(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Divide this numerator instance by the denominator argument (this / arg).
            </summary>
            <param name="denominator"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.DoGetDividedBy(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Divide the numerator argument by this denonminator instance (arg / this).
            </summary>
            <param name="numerator"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.DoModBy(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Compute the mod remainder of dividing this numerator instance by the denominator argument (this % arg).
            </summary>
            <param name="denominator"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.Column.DoGetModBy(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Compute the mod remainder of dividing the numerator argument by this denominator instance (arg % this).
            </summary>
            <param name="numerator"></param>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.Column.RowIndex">
            <summary>
            Logical index of this column in parent row
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.Column.Type">
            <summary>
            Helper property to read column vistadb data type
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.Column.Value">
            <summary>
            Get/set an object that represents this column value
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Row.Column.IsNull">
            <summary>
            Helper property to check null value status
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Row.Column.ArithmeticRank">
            <summary>
            Rank of data types used in different operations
            </summary>
            <remarks>If you change this enum don't forget to update CustValue methods respectevely</remarks>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBColumnAttributesDifference">
            <summary>
            Helper interface to investigate difference between column attributes in details. 
            </summary>
            <seealso cref="M:VistaDB.DDA.IVistaDBColumnAttributes.Compare(VistaDB.DDA.IVistaDBColumnAttributes)"/>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsRenamed">
            <summary>
            Has this column been renamed?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsTypeDiffers">
            <summary>
            Is this a different type?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsMaxLengthDiffers">
            <summary>
            Do the max lengths match?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsOrderDiffers">
            <summary>
            Have the order of the columns changed?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsEncryptedDiffers">
            <summary>
            Has the encryption state changed?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsPackedDiffers">
            <summary>
            Have the packed status flags changed?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsCodePageDiffers">
            <summary>
            Did the CodePage change?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsDescriptionDiffers">
            <summary>
            Are the descriptions different?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsCaptionDiffers">
            <summary>
            Are the captions different?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsNullDiffers">
            <summary>
            Did the IsNull flag change?
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBColumnAttributesDifference.IsReadOnlyDiffers">
            <summary>
            Did the ReadOnly flag change?
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Row.MetaData">
            <summary>
            Built-in column to keep row meta information
            </summary>
            <remarks>Internal use only</remarks>
        </member>
        <member name="T:VistaDB.Engine.Core.IntColumn">
            <summary>
            System.Int32 column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IntColumn.Int32Size">
            <summary>
            Memory apartment in bytes to allocate Int32 type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IntColumn.#ctor">
            <summary>
            Constructor. Initial value is Null
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IntColumn.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Int32 value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IntColumn.#ctor(VistaDB.Engine.Core.IntColumn)">
            <summary>
            Int32 column value copy constructor
            </summary>
            <param name="col">Int32 column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IntColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Int32 type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IntColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Int32 value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IntColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Int32 value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IntColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.MetaData.rowReferenceSize">
            <summary>
            Specifies the apartment size (in bytes) to keep reference.
            </summary>
            <remarks>Internal use only</remarks>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.MetaData.rowID">
            <summary>
            Unique row identifier.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Row.MetaData.referencedPosition">
            <summary>
            Referenced data position kept by the row
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.MetaData.#ctor(System.UInt32,System.UInt32,System.UInt64)">
            <summary>
            Constructor of row meta data
            </summary>
            <param name="rowId">Row id</param>
            <param name="version">Row version</param>
            <param name="referencedPosition">Extra data position tracked by the row</param>
            <remarks>Internal use only</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.MetaData.GetBufferLength(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get byte array length to store record meta information
            </summary>
            <remarks>Internal use only</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.MetaData.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Accept meta information from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
            <remarks>Internal use only</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.Row.MetaData.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put meta information to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceMetainfo">Previous row meta information to pack in according to</param>
            <returns>current index offset in buffer</returns>
            <remarks>Internal use only</remarks>
        </member>
        <member name="F:VistaDB.Engine.Core.Header.signatureEntry">
            <summary>
            Data storage type signature
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Header.rowNumberEntry">
            <summary>
            Current number of rows in the object
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Header.position">
            <summary>
            Position of this header in database file
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Header.parentStorage">
            <summary>
            Parent data storage
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Header.modified">
            <summary>
            If set shows header modified status
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Header.modifiedVersion">
            <summary>
            When set shows data storage version updated status
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Header.pageSize">
            <summary>
            Page length in file storage
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.Activate(System.UInt64)">
            <summary>
            Header activation method
            </summary>
            <param name="position">Position in the storage</param>
            <returns>Activation status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.Build(System.UInt64)">
            <summary>
            Build header and write header data to data storage
            </summary>
            <param name="position">Position in the storage</param>
            <returns>Built status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.ResetVersionInfo">
            <summary>
            Reset modification flags and version.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.Flush">
            <summary>
            Write header to database file (clears modified flag)
            </summary>
            <returns>Header wrote status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.Update">
            <summary>
            re-read whole header from file
            </summary>
            <returns>read status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.OnActivate(System.UInt64)">
            <summary>
            Override this method to activate header information by data storage
            </summary>
            <param name="position">Position in the storage</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.OnBuild(System.UInt64)">
            <summary>
            Override descendant class to complete header building
            </summary>
            <param name="position">Position in the storage</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.OnAfterRead(System.Int32,System.Boolean)">
            <summary>
            Do any work by descendants before reading the header
            </summary>
            <returns>Status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Header.Read(VistaDB.Engine.Core.Row.RowScope)">
            <summary>
            Read header from database file
            </summary>
            <returns>Header read status</returns>
        </member>
        <member name="P:VistaDB.Engine.Core.Header.RowCount">
            <summary>
            Row counter to hold row number information
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Header.Version">
            <summary>
            Data storage version. It allows proper 
            synchronization between several clients accessing this data storage
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Header.Size">
            <summary>
            Header size (in bytes)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Header.Modified">
            <summary>
            Read/write the header data modified status (will set but never clear modified flag)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Header.ModifiedVersion">
            <summary>
            Gets or sets the modifiedVersion flag (will set but never clear modifiedVersion flag)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Header.NewVersion">
            <summary>
            Check if data storage has been updated in the file directly
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Header.HeaderId">
            <summary>
            First byte in all headers. It identifiers 
            the content of the page allocated in the data storage file
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.StorageHeader.pageSizeEntry">
            <summary>
            Page size ( page length of the file )
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.StorageHeader.localeEntry">
            <summary>
            Locale parameter
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.StorageHeader.idCounterEntry">
            <summary>
            The unique Id counter
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.StorageHeader.timestampEntry">
            <summary>
            Unique id counter to use by timestamps
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.StorageHeader.schemaVersion">
            <summary>
            Meta data version
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.StorageHeader.#ctor(VistaDB.Engine.Core.DataStorage,VistaDB.Engine.Core.Header.HeaderId,System.UInt64,System.Int32,System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Header c-tor
            </summary>
            <param name="id"></param>
            <param name="parentStorage">Parent data storage</param>
            <param name="dataReference">Position of some root data in data storage</param>
            <param name="signature"></param>
            <param name="pageSize">Size of file storage page</param>
            <param name="culture"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.StorageHeader.GetNextAutoId">
            <summary>
            The unique counter. Used to initialize unique IDs.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.StorageHeader.CurrentAutoId">
            <summary>
            The unique counter current value. Used to initialize unique IDs
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.StorageHeader.SchemaVersion">
            <summary>
            Data storage metadata version. It makes sure
            there is no data damage while synchronizing between several clients
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Index.IndexHeader.descendEntry">
            <summary>
            Shows the reverse logical order of the rows
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.IndexHeader.CreateSchema(VistaDB.DDA.IVistaDBTableSchema)">
            <summary>
            Create header structure. If storage is registered in database, register rowset schema there,
            otherwise append rowset schema description to the header
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Index.IndexHeader.ActivateSchema">
            <summary>
            Activate header structure. If storage is registered in database, do nothing,
            otherwise instantiate the rest of header information by appending rowset schema description
            </summary>
            <returns>need re-activate status</returns>
        </member>
        <member name="F:VistaDB.Engine.Core.ClusteredRowset.rowsetRunTimeId">
            <summary>
            Used to open a clone for the latest modified instance, so it kept up to date
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.ClusteredRowset.BeginOptimizedFiltering(VistaDB.Engine.Internal.IOptimizedFilter)">
            <summary>
            Apply optimized filter
            </summary>
            <param name="filter">Optimized filter</param>
        </member>
        <member name="T:VistaDB.Engine.Core.ClusteredRowset.SyncExtension">
            <summary>
            Meta information utilized by sync service to collect create/update/delete information.
            The information includes set of columns appended to the table row and tombstone table
            in order  utilized 
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.UniqueId">
            <summary>
            Run-time unique id dynamical counter.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.packOperationMode">
            <summary>
            Is this database opened for pack operation mode?
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.LockSpaceMap">
            <summary>
            Lock access to the space map (now the Handle's freeCache?) for this Database.
            (Is this obsolete?)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.UnlockSpaceMap">
            <summary>
            Unlock access to the space map (now the Handle's freeCache?) for this Database.
            (Is this obsolete?)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.UpdateObjectEntry(System.Boolean,VistaDB.Engine.Core.Database.VdbObjects,System.UInt64,System.String,System.UInt64,System.UInt64,System.Int64,System.Boolean,System.String,System.String,System.Byte[],System.Byte[])">
            <summary>
            Update extended portion of data (meta key stays the same)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.AnalyzeSchema(VistaDB.Engine.Core.Table.TableSchema,VistaDB.Engine.Core.Table.TableSchema,System.Boolean@)">
            <summary>
            Analyze should we create new table schema or modify existing metadata only
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.UpdateMetaObjects(VistaDB.Engine.Core.ClusteredRowset,VistaDB.Engine.Core.AlterList,System.Boolean,VistaDB.Engine.Core.Row)">
            <summary>
            Update indexes, identities, constraints and default values in the table
            with renamed columns and/or changed indexes, identities, constraints and default values
            </summary>
            <param name="alterList"></param>
            <param name="rowset"></param>
            <param name="commit"></param>
            <param name="defaultSeedRow"></param>
            <remarks>The method assumes to treat changes in the objects list if 
            respective objects were not changed</remarks>
            <returns>true if at least one object updated or created</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.PrepareInvoke(System.String,VistaDB.Engine.Core.ClrHosting,VistaDB.Engine.Core.Database.VdbObjects)">
            <summary>
            Prepare this procedure to be run, this will load the assembly from the database and get it ready to be called.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.AllocateRowsetSchema(System.UInt64,VistaDB.Engine.Core.Row)">
            <summary>
            Enumerate and instantiate columns for the rowset; 
            append them to the rowInstance
            </summary>
            <param name="storageId">rowset header location in the data storage</param>
            <param name="rowInstance">row instance that is used to collect rowset schema</param>
            <returns>Row instance containing column structure</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.OpenTransactionLogTable(VistaDB.Engine.Core.ClusteredRowset,System.UInt64)">
            <summary>
            Get the internal Transaction Log Table from the datbase
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.CreateAnchorTable">
            <summary>
            Test if the table already exists and create it otherwise
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.DropAnchorTable">
            <summary>
            Test if the sync tables don't exist. If neither one exits then drop sync table
            </summary>
            <returns>table deleted status</returns>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.UpgradeDatatypesMode">
            <summary>
            Do the data types need to be upgraded to the current versions?
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.UpgradeExtensionsMode">
            <summary>
            Do extensions need to be upgraded to the current version?
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.UpgradeFTSStructure">
            <summary>
            Does the FullTextSearch Structure need to be updated?
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.ActivateSyncMode">
            <summary>
            Is sync mode active?
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.DeactivateSyncMode">
            <summary>
            Turn off sync mode
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.RepairMode">
            <summary>
            Are we operating in repair mode?  
            During a repair we ignore a lot of errors and attempt to recover as much data as possible.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Table">
            <summary>
            Table entry
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Index">
            <summary>
            Table's index entry
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Column">
            <summary>
            Table's column entry
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Constraint">
            <summary>
            Table constraint entry
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.DefaultValue">
            <summary>
            Default value script
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Identity">
            <summary>
            Identity entry
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Relationship">
            <summary>
            Foreign key constraint
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Trigger">
            <summary>
            Trigger
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Description">
            <summary>
            Database description
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.View">
            <summary>
            View object
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.CLRProcedure">
            <summary>
            CLR stored procedure
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.Assembly">
            <summary>
            Assembly containing CLR procedure
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.CLRTrigger">
            <summary>
            CLR trigger
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.StoredProcedure">
            <summary>
            SQL Stored Procedure
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.VdbObjects.UDF">
            <summary>
            UDF
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBDatabaseObject">
            <summary>
            General information about database object
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabaseObject.Name">
            <summary>
            The name of database object
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabaseObject.Description">
            <summary>
            The user's description of the database object
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.IdentityCollection.SetLastIdentity(System.String,VistaDB.Engine.Core.Row)">
            <summary>
            Write last identity
            </summary>
            <param name="tableName">Name of table</param>
            <param name="row">Current row of table, which just inserted new row</param>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBTableNameCollection">
            <summary>
            List of Tables in the current connection as a strongly typed list.  This is faster for use in Foreach loops than the ArrayList version.
            </summary>
            <example>
            <code>
            IVistaDBDatabase db = DDAUtils.BuildTestDatabase(ref DDAObj, dbname, false, null, false); 
            IVistaDBTableCollection tableList = db.GetTables();
            foreach (string table in tableList)
            {
               Console.WriteLine("Table is named: " + table);
            }
            </code>
            </example>
        </member>
        <member name="T:VistaDB.Engine.Internal.VistaDBKeyedCollection`2">
            <summary>
            Generic collection for VistaDB keyed objects
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBKeyedCollection`2">
            <summary>
            IVistaDBKeyedCollection is an interface for objects lists returned by the engine for things like
            Relationships, tables, etc.  The interface allows the user to read from the list, but not
            modify it.  The collections themselves were always intended to be readonly.
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBKeyedCollection`2.ContainsKey(`0)">
            <summary>
            Is this key currently contained in the list?  Used to lookup an entry.
            </summary>
            <param name="key">Key to look for in the collection</param>
            <returns>True if found</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBKeyedCollection`2.TryGetValue(`0,`1@)">
            <summary>
            Try to get the value from the collection, if it does not exist returns false
            </summary>
            <param name="key">Key in collection to find</param>
            <param name="value">The output of the value</param>
            <returns>True is success</returns>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBKeyedCollection`2.Keys">
            <summary>
            Collection of keys for lookup
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBKeyedCollection`2.Values">
            <summary>
            Values returned by the lookup operation
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBKeyedCollection`2.Item(`0)">
            <summary>
            Get a value by the index key name.  Returns NULL if not found.
            </summary>
            <param name="key">Key to find in the collection</param>
            <returns>The Value object, or null if not found.</returns>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBClrProcedureCollection">
            <summary>
            The Collection of Clr Procedures
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.ClrProcedureCollection.AddProcedure(System.String,System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            Add procedure description
            </summary>
            <param name="name"></param>
            <param name="fullSignature">CLR name concatenated with CLR signature throw '\0' symbol</param>
            <param name="description"></param>
            <param name="assemblyFullName"></param>
            <param name="status">active status (not used)</param>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBClrProcedureInformation">
            <summary>
            Meta-information about CLR Proc
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrProcedureInformation.Name">
            <summary>
            Custom name of the CLR Proc
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrProcedureInformation.Signature">
            <summary>
            Signature provided by System.Reflection for CLR Proc
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrProcedureInformation.AssemblyName">
            <summary>
            The name of assembly the CLR Proc is hosted in
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrProcedureInformation.FullHostedName">
            <summary>
            The full name of respective assembly hosted method
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBClrTriggerCollection">
            <summary>
            The list of Clr Triggers loaded in current database
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.ClrTriggerCollection.AddTrigger(System.String,System.String,System.String,System.Byte[],System.Boolean,System.UInt64,System.Int64)">
            <summary>
            Add trigger description
            </summary>
            <param name="name"></param>
            <param name="fullSignature">CLR name concatenated with CLR throw throw '\0' symbol</param>
            <param name="description"></param>
            <param name="assemblyFullName"></param>
            <param name="status">active status (not used)</param>
            <param name="reference">table reference (for triggers only)</param>
            <param name="option">event type (for triggers only)</param>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBClrTriggerInformation">
            <summary>
            CLR Trigger description
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrTriggerInformation.Name">
            <summary>
            Custom name of the CLR Trigger
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrTriggerInformation.Signature">
            <summary>
            Signature provided by System.Reflection for CLR Trigger
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrTriggerInformation.AssemblyName">
            <summary>
            The name of assembly the CLR Trigger is hosted in
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrTriggerInformation.FullHostedName">
            <summary>
            The full name of the assembly hosted method
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrTriggerInformation.TableName">
            <summary>
            The name of table the trigger is set on
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBClrTriggerInformation.TriggerAction">
            <summary>
            The type of action that fired the trigger
            </summary>
            <remarks>Only AfterInsert, AfterUpdate and AfterDelete actions supported by CLR Triggers</remarks>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBAssemblyCollection">
            <summary>
            The list of assemblies registered in database
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBAssemblyInformation">
            <summary>
            The information about assembly registered in database
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBAssemblyInformation.Name">
            <summary>
            The name the assembly is registered with
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBAssemblyInformation.FullName">
            <summary>
            The full name of compiled assembly in according to System.Reflection.AssemblyName.FullName property
            </summary>
            <seealso cref="P:System.Reflection.AssemblyName.FullName"/>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBAssemblyInformation.ImageRuntimeVersion">
            <summary>
            Gets a string representing the version of the common language runtime for this assembly image
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBAssemblyInformation.VistaDBRuntimeVersion">
            <summary>
            Gets a string representing the version of VistaDB this assembly image is referenced to.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBAssemblyInformation.Procedures">
            <summary>
            Gets the list of procedures compiled in assembly for possible registration.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBAssemblyInformation.Triggers">
            <summary>
            Gets the list of CLR triggers compiled in assembly for possible registration.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBAssemblyInformation.COFFImage">
            <summary>
            An array of type byte that is a COFF-based image containing assembly
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBRelationshipCollection">
            <summary>
            Collection of relationships. 
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBRelationshipInformation">
            <summary>
            The Relationship entry from an IVistaDBRelationshipCollection.  This entry contains the actual values for the relationship.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRelationshipInformation.Name">
            <summary>
            The name of relationship. When relationship is set this name coincides 
            with respective name of foreign key index created to maintain the relationship.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRelationshipInformation.PrimaryTable">
            <summary>
            The name of primary table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRelationshipInformation.ForeignTable">
            <summary>
            The name of foreign table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRelationshipInformation.ForeignKey">
            <summary>
            The foreign key entry
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRelationshipInformation.DeleteIntegrity">
            <summary>
            The rule to use in referential integrity policy for delete operations
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBRelationshipInformation.UpdateIntegrity">
            <summary>
            The rule to use in referential integrity policy for update operations
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.CurrentFileVersion">
            <summary>
            This is the version value for the current generation of file format (10 was VistaDB 4, 11 is VistaDB 5)
            which will be used for new database creation and is required for write-access support.  (See ReadOnlyAllowedMinVersion)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.ReadOnlyAllowedMinVersion">
            <summary>
            This is the minimum version of database file which this version of the engine will allow provided that access
            is read-only (or to-pack).  This does not limit the migration ability for a pack operation.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.BlockEncryptionMinVersion">
            <summary>
            This is the version in which block-by-block encryption was introduced and replaces column-by-column encryption.
            This value should never be changed.  (11 is VistaDB 5)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.databaseFileSchemaVersionHeaderPosition">
            <summary>
            The database file schema version position
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.NumberColumnsHeaderPosition">
            <summary>
            Position where the Number of columns in the Database Header is stored.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.encryptionKeyMd5HeaderPosition">
            <summary>
            Position in the header where the encryption key is kept
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.freeSpaceMapLocationHeaderPosition">
            <summary>
            Where is the free space map location kept in the header?
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.oldCopyrightStringHeaderPosition">
            <summary>
            Position in the header used for Copyright string in VistaDB 4 (file version 10).
            Now used for string encryption type?
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.schemaVersionGuidHeaderPosition">
            <summary>
            The database version guid position
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.schemaVersionGuid">
            <summary>
            The unique instance guid for this database schema version.  Ensures we have the exact version for applying
            schema or sync changes rather than relying on the filename or location
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.transactionIdHeaderPosition">
            <summary>
            Where is the current TransactionId stored in the header?
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.currentTransactionIdValue">
            <summary>
            The current transactionId value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.numHeaderColumns">
            <summary>
            The actual number of columns we have in the database header - after this are data rows
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Database.DatabaseHeader.endianPosition">
            <summary>
            The position of the endian stamp for detecting file transfers between incompatible serialization architectures
            (not effectively checked in VistaDB 4)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.DatabaseHeader.BeginTransaction">
            <summary>
            Assign new transaction id to current database. Use odd numbers for active transactions.
            Even numbers are used for sessions w/o active transactions
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.DatabaseHeader.OnRegisterSchema(VistaDB.DDA.IVistaDBTableSchema)">
            <summary>
            Everytime we get a new schema we generate a new SchemaVersionGuid to ensure
            comparisons looking for a specific schema match up 
            </summary>
            <param name="schema"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.Database.DatabaseHeader.FileSchemaVersionOutOfDate">
            <summary>
            Does the current file schema version match the databases internal current file version?
            </summary>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.DatabaseHeader.DatabaseFileSchemaVersion">
            <summary>
            The version of the database file schema - this is the value we change when a file structure change is required.
            Any version that does not match the current file schema version should not be loaded without an upgrade first.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.DatabaseHeader.EncryptionKeyMd5">
            <summary>
            This is an md5 hash of the encryption key used to encrypt the database.
            We don't ever store the actual key, just the md5 hash of the key.  This allows us to load an encryption key string and verify
            it is correct (testing the Md5 of the key they give us rather than actually attempting to decrypt data).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.DatabaseHeader.ColumnCount">
            <summary>
            Column counter to hold the number of columns in the database header
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.DatabaseHeader.FreeSpaceMapLocation">
            <summary>
            This is the position in the file where the free space map is stored
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Database.DatabaseHeader.SchemaVersionGuid">
            <summary>
            Unique identifier to mark this database schema version.  Updates at each schema change.
            This was originally planned for sync, but it is useful for things like schema version as well.
            We can use it to tell that this file is the exact one we intended 
            without relying on things like filename or location on disk, etc.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Database.TraverseJobDelegate">
            <summary>
            The delegate used to filter out objects loaded from the disk
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.DatabaseMetaTable">
            <summary>
            Wrapper class to allow same access to database with DDA interface like access to any data table
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Table">
            <summary>
            Row orders collection. Table may contain several 
            different row orders including the primary and the 
            original order
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.ITable">
            <summary>
            Supports table interface between sql and core engine. Provides internal functionality 
            the core should implement to be used by sql
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBTable">
            <summary>
            DDA table public interface. 
            Inherits IVistaDBQueryResult interface and extends it's functionality
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Close">
            <summary>
            Close the table and clear respective resources
            </summary>
            <remarks>The same functionality is provided by Dispose method</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Evaluate(System.String)">
            <summary>
            Evaluate expression.
            </summary>
            <param name="expression">Expression to evaluate</param>
            <returns>Row result</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.SetFilter(System.String,System.Boolean)">
            <summary>
            Set filter expression and try to optimize it if the optimize parameter is true
            </summary>
            <param name="expression">Filter expression</param>
            <param name="optimize">Try to optimize filter using and existing indexes</param>
            <remarks>
            Optimization is enabled by default.  If you are getting unexpected results from a query, try to turn 
            optimization off and see if the query works correctly.
            </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.ResetFilter">
            <summary>
            Reset all filters
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.GetFilter(System.Boolean)">
            <summary>
            Gets filter expression for current table state.
            </summary>
            <param name="optimizable">When it is true, returns script for optimizable filter (may have been modified from what was given to the engine). 
            Otherwise returns simple script filter</param>
            <returns>Script filter expression as a string</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.GetScope(VistaDB.DDA.IVistaDBRow@,VistaDB.DDA.IVistaDBRow@)">
            <summary>
            Gets the IVistaDBRow objects containing current top and bottom rows of the applied scope.
            These objects before the first row and after the last row.
            </summary>
            <param name="lowKey">The row(compound key) before the first available row(compound key) in active index</param>
            <param name="highKey">The row(compound key) after the last available row(compound key) in active index</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.SetScope(VistaDB.DDA.IVistaDBRow,VistaDB.DDA.IVistaDBRow)">
            <summary>
            Set scope on active index to apply filter on the number of rows.  The columns referenced in the scope
            operators must be present in the active index for them to work correctly.
            </summary>
            <param name="lowKey">The row(compound key) before the first available row(compound key) in active index</param>
            <param name="highKey">The row(compound key) after the last available row(compound key) in active index</param>
            <remarks>If lowKey or highKey passed as null reference, the ResetScope executed</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.SetScope(System.String,System.String)">
            <summary>
            Set scope on active index to apply filter on the number of rows.  The columns referenced in the scope
            operators must be present in the active index for them to work correctly.
            </summary>
            <param name="lowKeyExpression">The script to use by engine in order to evaluate low scope key</param>
            <param name="highKeyExpression">The script to use by engine in order to evaluate high scope key</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.ResetScope">
            <summary>
            Reset scope in active index
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Find(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Find an expression in an index.  This is for searching for exact and partial matching records.
            </summary>
            <param name="keyEvaluationExpression">The expression to evaluate for the target row(s).  This expression should follow the Find Expression Syntax (see help file).</param>
            <param name="indexName">Index to use for the operation (must already exist)</param>
            <param name="partialMatching">Try to find using partial matching if exact match is not found</param>
            <param name="softPosition">Try to position the current row pointer to the row after a non found key. This is where the row would have if it had existed.</param>
            <returns>Operation status. If the key is not found, the current row position is set to the bottom of the table and EndOfTable flag is set.  True will set current row to the first found entry.</returns>
            <remarks>Find may not be used on FTS indexes</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Find(VistaDB.DDA.IVistaDBRow,System.String,System.Boolean,System.Boolean)">
            <summary>
            Find the key in index and set found row as current
            </summary>
            <param name="key">Compound key value to find</param>
            <param name="indexName">Index to use for the operation (must already exist)</param>
            <param name="partialMatching">Try to find using partial matching if exact match is not found</param>
            <param name="softPosition">Try to position the current row pointer to the row after a non found key. This is where the row would have if it had existed.</param>
            <returns>Operation status. If the key is not found, the current row position is set to the bottom of the table and EndOfTable flag is set.  True will set current row to the first found entry.</returns>
            <remarks>Find may not be used on FTS indexes</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.CreateIndex(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Create an index on current table.  This may be a unique constrained index, or a primary key index.
            </summary>
            <param name="name">Index name</param>
            <param name="keyExpression">Key expression with syntax "column1[;DESC(column2)[;...n]]". Key expression cannot cover more than 256 columns.</param>
            <param name="primary">The index is the primary key.</param>
            <param name="unique">The index requires unique column constraint. It is ineffective parameter when primary parameter is set (because all primary keys MUST be unique by definition).</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.CreateTemporaryIndex(System.String,System.String,System.Boolean)">
            <summary>
            Create temporary index from given keyExpression. The index is not added to database 
            but kept separately in the user temporary folder. The file is deleted by engine when the table is closed.
            </summary>
            <param name="name">Index name</param>
            <param name="keyExpression">Key expression with syntax "column1[;DESC(column2)[;...n]]". Key expression cannot cover more than 128 columns.</param>
            <param name="unique">The index requires unique column constraint</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.CreateFTSIndex(System.String,System.String)">
            <summary>
            Create special index to use by full text search. Identity columns may not be used for FullTextSearch indexes.  Only a single FullTextSearch index may exist per table.
            </summary>
            <param name="name">index name</param>
            <param name="columns">Table columns participating full text index. These names are listed in the same string and separated with ';' sign</param>
            <example>
            The following example creates an FullTextSearch Index on multiple columns.
            <code>
            using( IVistaDBDatabase db = DDAObj.OpenDatabase(dbName, VistaDBDatabaseOpenMode.ExclusiveReadWrite, null) )
            {
            	using( IVistaDBTable table = db.OpenTable("testtable", false, false) )
            	{
            		table.CreateFTSIndex("FTSTest", "col1;col2;col3;col4");
            	}
            }
            </code>
            </example>
            <example>
            To create a full text search index in SQL you execute the following style command:
            <code>
            CREATE FULLTEXT INDEX indexname on tablename(columnname,...)
            </code>
            </example>
            <remarks>DDA cannot query the FullTextSearch indexes.  Only the SQL CONTAINS command operates on Full Text Search (FTS) indexes.</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.DropIndex(System.String)">
            <summary>
            Drop existing index
            </summary>
            <param name="name">Index name</param>
            <seealso cref="M:VistaDB.DDA.IVistaDBTable.DropFTSIndex"/>
            <remarks>This cannot be used to drop FullTextSearch Indexes - see the DropFTSIndex command.</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.DropFTSIndex">
            <summary>
            Drop full text search index.  No params are required as there may be only one Full Text Search (FTS) Index per table.
            </summary>
            <remarks>The space used by the FTS index is not reclaimed until a pack operation is completed.</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.RenameIndex(System.String,System.String)">
            <summary>
            Rename existing index without rebuilding.
            </summary>
            <param name="oldName">Old index name</param>
            <param name="newName">New index name</param>
            <remarks>Method doesn't rename primary key index if it participates in relationships. 
            You cannot rename foreign key indexes (they are managed by the engine).</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.CreateIdentity(System.String,System.String,System.String)">
            <summary>
            Create and initialize identity counter. Applied to integer type columns only.
            </summary>
            <param name="columnName">Column to set identity for</param>
            <param name="seedExpression">Initial value. If null string is passed 
            the initial value stays current default value</param>
            <param name="stepExpression">Step to increment/decrement identity counter</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.DropIdentity(System.String)">
            <summary>
            Drop existing identity column
            </summary>
            <param name="columnName">Column name (must exist)</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.CreateDefaultValue(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Create a default value for a column using an expression.
            </summary>
            <param name="columnName">The target column</param>
            <param name="scriptExpression">Script expression</param>
            <param name="useInUpdate">Use this default value script in update operations 
            (when value has not been assigned to the column in the update).  This is not SQL Server compliant.</param>
            <param name="description">Description</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.DropDefaultValue(System.String)">
            <summary>
            Drop an existing default value
            </summary>
            <param name="columnName">Column name (must exist)</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.CreateConstraint(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create constraint to check after insert, update or before delete operations
            </summary>
            <param name="name">Constraint's name to identify constraint instance</param>
            <param name="scriptExpression">SQL expression to evaluate</param>
            <param name="description">User's description to constraint. Optional. May be null reference</param>
            <param name="insertion">When it is set to the true, the constraint will be checked after insert row operation</param>
            <param name="update">When it is set to the true, the constraint will be checked after update row operation</param>
            <param name="delete">When it is set to the true, the constraint will be checked after before delete operation. If v-expression is being evaluated to the false, the row will not be deleted</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.DropConstraint(System.String)">
            <summary>
             Drop existing constraint
            </summary>
            <param name="name">Constraint's name</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.CreateForeignKey(System.String,System.String,System.String,VistaDB.DDA.VistaDBReferentialIntegrity,VistaDB.DDA.VistaDBReferentialIntegrity,System.String)">
            <summary>
            Create foreign key constraint that instantiates respective relationship in the database
            </summary>
            <param name="constraintName">The name of foreign key constraint. This name will be used by core engine
            in order to create new index on foreign key. The index name may be used to set active index. But this 
            index cannot be deleted until constraint is set</param>
            <param name="foreignKey">The foreign key expression. It should match the order 
            and type of primary key columns</param>
            <param name="primaryTable">The table containing primary key to refer by foreign key</param>
            <param name="updateIntegrity">The rule to follow in primary table update operation</param>
            <param name="deleteIntegrity">The rule to follow in primary table delete operation</param>
            <param name="description">User's description of this constraint</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.DropForeignKey(System.String)">
            <summary>
            Drop foreign key constraint. Respective foreign key index will be deleted from the table as well.
            </summary>
            <param name="constraintName">Foreign key constraint name. It's the same name assigned to foreign key index.</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Put(System.Int32,System.Object)">
            <summary>
            Assign column value with system type value by column order in the row.
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="columnValue">The value to assign</param>
            <remarks>This method tries convert system type value to VistaDBType value</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Put(System.String,VistaDB.IVistaDBValue)">
            <summary>
            Assign column value by column name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="columnValue">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Put(System.Int32,VistaDB.IVistaDBValue)">
            <summary>
            Assign column value by column order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="columnValue">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutString(System.String,System.String)">
            <summary>
            Assign string value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutString(System.Int32,System.String)">
            <summary>
            Assign string value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutByte(System.String,System.Byte)">
            <summary>
            Assign byte value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutByte(System.Int32,System.Byte)">
            <summary>
            Assign byte value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutInt16(System.String,System.Int16)">
            <summary>
            Assign int16 value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutInt16(System.Int32,System.Int16)">
            <summary>
            Assign int16 value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutInt32(System.String,System.Int32)">
            <summary>
            Assign int32 value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutInt32(System.Int32,System.Int32)">
            <summary>
            Assign int32 value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutInt64(System.String,System.Int64)">
            <summary>
            Assign int64 value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutInt64(System.Int32,System.Int64)">
            <summary>
            Assign int64 value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutSingle(System.String,System.Single)">
            <summary>
            Assign Float value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutSingle(System.Int32,System.Single)">
            <summary>
            Assign Float value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDouble(System.String,System.Double)">
            <summary>
            Assign Double value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDouble(System.Int32,System.Double)">
            <summary>
            Assign Double value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDecimal(System.String,System.Decimal)">
            <summary>
            Assign Decimal value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDecimal(System.Int32,System.Decimal)">
            <summary>
            Assign Decimal value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutBoolean(System.String,System.Boolean)">
            <summary>
            Assign boolean value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutBoolean(System.Int32,System.Boolean)">
            <summary>
            Assign boolean value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDateTime(System.String,System.DateTime)">
            <summary>
            Assign DateTime value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDateTime(System.Int32,System.DateTime)">
            <summary>
            Assign DateTime value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDateTimeOffset(System.String,System.DateTimeOffset)">
            <summary>
            Assign DateTimeOffset value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutDateTimeOffset(System.Int32,System.DateTimeOffset)">
            <summary>
            Assign DateTimeOffset value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutTime(System.String,System.TimeSpan)">
            <summary>
            Assign TimeSpan value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutTime(System.Int32,System.TimeSpan)">
            <summary>
            Assign TimeSpan value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutBinary(System.String,System.Byte[])">
            <summary>
            Assign array of bytes value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutBinary(System.Int32,System.Byte[])">
            <summary>
            Assign array of bytes value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutGuid(System.String,System.Guid)">
            <summary>
            Assign Guid value to column by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutGuid(System.Int32,System.Guid)">
            <summary>
            Assign Guid value to column by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
            <param name="value">The value to assign</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutNull(System.String)">
            <summary>
            Set null value by column's name
            </summary>
            <param name="columnName">Column's name</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutNull(System.Int32)">
            <summary>
            Set null value by column's order in the row
            </summary>
            <param name="index">Zero-based column's index in the row</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutFromFile(System.String,System.String)">
            <summary>
            Put Text, NText, Image data from external file to a column.
            </summary>
            <param name="fileName">Name of external file containing text or binary data</param>
            <param name="columnName">Column name the data put in</param>
            <remarks>The method reads text data from the external text file using Encoding assigned to respective character column</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.PutFromFile(System.Int32,System.String)">
            <summary>
            Put Text, NText, Image data from external file to a column.
            </summary>
            <param name="fileName">Name of external file containing text or binary data</param>
            <param name="index">Zero-based column's index in the row</param>
            <remarks>The method reads text data from the external text file using Encoding assigned to respective character column</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.GetToFile(System.String,System.String)">
            <summary>
            Read Text, NText, Image data from database and put them to external file.
            </summary>
            <param name="fileName">Name of external file</param>
            <param name="columnName">Column name the data are read from</param>
            <remarks>The method writes text data to the external text file using Encoding assigned to respective character column</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.GetToFile(System.Int32,System.String)">
            <summary>
            Read Text, NText, Image data from database and put them to external file.
            </summary>
            <param name="fileName">Name of external file</param>
            <param name="index">Zero-based column's index in the row</param>
            <remarks>The method writes text data to the external text file using Encoding assigned to respective character column</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Get(System.String)">
            <summary>
            Get column value by column's name
            </summary>
            <param name="columnName">Column's name</param>
            <returns>IVistaDB object instance containing value of the column</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Get(System.Int32)">
            <summary>
            Get column value by column's name
            </summary>
            <param name="columnIndex">Column's index</param>
            <returns>IVistaDB object instance containing value of the column</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Insert">
            <summary>
            The method should be called in the beginning the insert operation. 
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Post(System.Boolean)">
            <summary>
            The method should be called to finalize insert or update operations.
            </summary>
            <param name="leaveRowLock">If set, the row lock applied explicitly by user
            before update or implicitly by core engine in update or insert operations
            wont be reset by core until explicit unlock operation done</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Post">
            <summary>
            The method should be called to finalize insert or update operations. 
            After it is passed the core engine reset respective row lock.
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Delete">
            <summary>
            Immediately deletes current row and reset row lock if it 
            was set before delete operation
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Lock(System.Int64)">
            <summary>
            Lock row. If zero is passed, the entire table will be locked
            </summary>
            <param name="rowId">Id of the row</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Unlock(System.Int64)">
            <summary>
            Unlock row. If zero is passed, the entire table will be 
            unlocked and all existing row locks will be released
            </summary>
            <param name="rowId">Id of the row</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.First">
            <summary>
            Set current row pointer to the first row position. 
            If there are no rows, the EndOfTable flag is set to the true value
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Last">
            <summary>
            Set current row pointer to the last row position. 
            If there are no rows, the EndOfTable flag is set to the true value
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Prev">
            <summary>
            Move row pointer one record ahead
            If there are no rows, the StartOfTable flag is set to the true value
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.Next">
            <summary>
            Advances current row pointer position
            If there are no rows, the EndOfTable flag is set to the true value
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.MoveBy(System.Int32)">
            <summary>
            Advances current row pointer position
            </summary>
            <param name="rowNumber">The number of rows to skip</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.ExportData(VistaDB.DDA.IVistaDBTable,System.String)">
            <summary>
            To export table data using constraint set on destination table.
            </summary>
            <param name="table">Destination table. Must not be this table instance</param>
            <param name="constraint">Constraint to activate while exporting data. 
            The constraint is being applied to the destination table and 
            checking every new row. It acts like the 'after creating row constraint'. 
            Must be null reference if no constraint is set</param>
            <remarks>SetFilter may be applied to this table before calling the method in order to export only filtered data</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.SetOperationCallbackDelegate(VistaDB.DDA.OperationCallbackDelegate)">
            <summary>
            Defines a delegate that time consuming operations may call back in order to inform the user as to the progress of the operation and additional information.
            </summary>
            <param name="operationCallbackDelegate">Delegate method</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.SetDDAEventDelegate(VistaDB.DDA.IVistaDBDDAEventDelegate)">
            <summary>
            Set delegate method called by core engine by event
            </summary>
            <param name="eventDelegate">EventDelegate object</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTable.ResetEventDelegate(VistaDB.DDA.DDAEventDelegateType)">
            <summary>
            Reset event delegate type called by DDA 
            </summary>
            <param name="eventType">Event type</param>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.Name">
            <summary>
            Table name
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.ActiveIndex">
            <summary>
            Name of active index that pivots current row order
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.IsClosed">
            <summary>
            Get the value indicating whether the table is closed
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.ScopeKeyCount">
            <summary>
            Scans active index and calculates the keys in it, taking current scope operators into account.
            (WARNING: CAUSES SIDE-EFFECTS:  The current row position of the parent table becomes undefined/EOF)
            </summary>
            <returns>The number of keys in the current scope. 
            If no current scope set the method calculates total number of rows in table.</returns>
            <remarks>After execution the current row position of the parent table is undefined</remarks>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.LastSessionIdentity">
            <summary>
            Read the memory-cached value of last insert operation
            made to the identity columns by this table instance
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.LastTableIdentity">
            <summary>
            Read the last value of identity columns that 
            will be used by any client in nearest insert operation. 
            This value is saved in the file storage.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.CurrentKey">
            <summary>
            The unique key that points out current row when Key is read 
            or set respective row to be current when Key is wrote
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.CurrentRow">
            <summary>
            Row structure containing current table row columns
            While reading creates new current row copy. 
            When writing, caches data in the table until Post is issued.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.RowCount">
            <summary>
            Number of physical rows in the table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.EndOfTable">
            <summary>
            Tests if a record movement function has placed the row pointer beyond the last row in the table.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.StartOfTable">
            <summary>
            Tests if a  a record movement function has placed the row pointer before the first row in the table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.EnforceConstraints">
            <summary>
            Gets or sets a value indicating whether constraint rules are followed 
            when attempting any insert, update or delete operation
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.EnforceIdentities">
            <summary>
            Gets or sets a value indicating whether identities are active
            when attempting any insert operation
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.TemporaryIndexes">
            <summary>
            Get collection of temporary indexes created and assigned to this table instance
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTable.RegularIndexes">
            <summary>
            Get collection of regular indexes created and/or opened in this table instance
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.ITable.CreateSparseIndex(System.String,System.String)">
            <summary>
            Create index of standard type that disables adding non-unique keys to the index.
            The uniqeeness does not set unique constraint to the table but rather groups same key values.
            There is no garantee consistense of key set in delete/update operations
            </summary>
            <param name="name"></param>
            <param name="keyExpression"></param>
        </member>
        <member name="F:VistaDB.Engine.Core.Table.currentModificationCounter">
            <summary>
            Used to open a clone for the latest modified instance, so it kept up to date
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Table.ErrorTip(System.UInt32)">
            <summary>
            
            </summary>
            <param name="rowId"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Table.Create(System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="commit"></param>
            <param name="empty"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.Table.SyncUpToDateStatus(System.Boolean,System.Boolean)">
            <summary>
            Synchronizes changes or row pointer movement. It's single entry 
            in the engine to commit physical changes made in the table or update
            current row pointer position
            </summary>
            <param name="commit">Forces to commit changes on the disk immediately</param>
            <param name="leaveRowLock">Do not reset row lock</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Table.VistaDB#DDA#IVistaDBTable#Close">
            <summary>
            Close table
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Table.Finalize">
            <summary>
            Finalizer for table to ensure cleanup.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.ActiveOrder">
            <summary>
            Current active pivot row order
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.VistaDB#DDA#IVistaDBTable#Name">
            <summary>
            Table name
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.IsClosed">
            <summary>
            Gets a value indicating whether the table is closed.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.VistaDB#DDA#IVistaDBTable#CurrentKey">
            <summary>
            The unique key that points out current row
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.StartOfTable">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.VistaDB#DDA#IVistaDBTable#ScopeKeyCount">
            <summary>
            Scans active index and calculates the keys in it, taking current scope operators into account.
            (WARNING: CAUSES SIDE-EFFECTS:  The current row position of the parent table becomes undefined/EOF)
            </summary>
            <returns>The number of keys in the current scope. 
            If no current scope set the method calculates total number of rows in table.</returns>
            <remarks>After execution the current row position of the parent table is undefined</remarks>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.VistaDB#Engine#Internal#ITable#Alias">
            <summary>
            Table alias
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Table.VistaDB#Engine#Internal#ITable#CurrentKey">
            <summary>
            The unique key that points out current row
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBTableSchema">
            <summary>
            Table schema for usage in creation or altering of an IVistaDBTable.
            </summary>
            <remarks>
            <para>
            You do not instantiate one of these objects through the new operator.  You 
            instead use the table operators inside the IVistaDBDatabase interface.
            </para>
            <para>When making changes to a schema you need to retrieve this object from the
            IVistaDBDatabase object, perform the modifications you want, then apply them 
            by calling IVistaDBDatabase.AlterTable (<seealso cref="M:VistaDB.DDA.IVistaDBDatabase.AlterTable(System.String,VistaDB.DDA.IVistaDBTableSchema)"/>).</para>
            </remarks>
            <example>
            &lt;&lt;pre&gt;&gt;
            
            //DDA Example code
            IVistaDBDDA DDAObj = DDAObj = VistaDBEngine.Connections.OpenDDA();
            IVistaDBDatabase db1 = DDAObj.CreateDatabase(filename, true, null, 2, 0, 
            false);
            IVistaDBTableSchema table1s = db1.NewTable("TestTable1");
            table1s.AddColumn("ID", VistaDBType.Int);
            table1s.DefineColumnAttributes("ID", false, false, false, false, 
            null, null);
            table1s.AddColumn("COLINT", VistaDBType.Int);
            table1s.DefineColumnAttributes("COLINT", false, false, false, 
            false, null, null);
            
            IVistaDBTable newTable = db1.CreateTable(table1s, false, false);
            newTable.CreateIdentity("ID", "1000", "1");
            newTable.CreateIndex("Primary", "ID", true, true);
            newTable.CreateIndex("idxDate", "COLDATETIME", false, 
            false);
            newTable.Close();
            newTable.Dispose();
            newTable = null;
            
            &lt;&lt;/pre&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AddColumn(System.String,VistaDB.VistaDBType)">
            <summary>
            Append new non-character type column
            </summary>
            <param name="name">Column's name</param>
            <param name="type">VistaDBType column type. If you pass Char, VarChar or Text type they will be 
            converted to unicode N-type with maximum allowed size.</param>
            <returns>0-based column's index</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AddColumn(System.String,VistaDB.VistaDBType,System.Int32,System.Int32)">
            <summary>
            Append new column
            </summary>
            <param name="name">Column's name</param>
            <param name="type">VistaDBType column's type</param>
            <param name="maxLen">Maximum length of character type column. 
            This value doesn't matter for Text, NText and Image columns</param>
            <param name="codePage">Code page to keep column's value of type Char, VarChar, Text being encoded in the file</param>
            <returns>0-based column's index</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AddColumn(System.String,VistaDB.VistaDBType,System.Int32)">
            <summary>
            Append new column using default ANSI code page for database culture
            </summary>
            <param name="name">Column's name</param>
            <param name="type">VistaDBType column's type</param>
            <param name="maxLen">Maximum length of character type column. 
            This value doesn't matter for Text, NText and Image columns</param>
            <returns>0-based column's index</returns>
            <see cref="M:VistaDB.DDA.IVistaDBDDA.CreateDatabase(System.String,System.Boolean,System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DropColumn(System.String)">
            <summary>
            Drop the column by its name
            </summary>
            <param name="name">Column's name</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DefineColumnAttributes(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Define column's attributes.
            </summary>
            <remarks>
            By default the column attributes are:
            allowNull = true, readOnly = false, encrypted = true( if database encrypted, otherwise = false ),
            packed = false, caption = null, description = null
            </remarks>
            <param name="name">Column's name</param>
            <param name="allowNull">Column can contain nulls</param>
            <param name="readOnly">Column cannot be updated</param>
            <param name="encrypted">Column level encryption flag. (Obsolete as of VistaDB 5)</param>
            <param name="packed">The extended type columns is packed 
            when put to database file</param>
            <param name="caption">The caption to show in data grid</param>
            <param name="description">The description of the column</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AlterColumnName(System.String,System.String)">
            <summary>Alter the name of a column</summary>
            <param name="oldName">Name of the existing column</param>
            <param name="newName">New name to assign to the column</param>
            <returns>IVistaDBColumnAttributes describing altered column</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AlterColumnType(System.String,VistaDB.VistaDBType,System.Int32,System.Int32)">
            <summary>
            Alter the type of existing column
            </summary>
            <param name="name">Name of the existing column</param>
            <param name="newType">New VistaDBType type for the column</param>
            <param name="newMaxLen">New maximum length for character column. 
            If new VistaDBType type doesn't support this maximum the parameter has no effect.</param>
            <param name="newCodePage">New code page. If new VistaDBType type doesn't support 
            this maximum the parameter has no effect. Pass 0 value to use existing code page.</param>
            <returns>IVistaDBColumnAttributes describing altered column</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AlterColumnType(System.String,VistaDB.VistaDBType,System.Int32)">
            <summary>
            Alter the type of existing column
            </summary>
            <param name="name">Name of the existing column</param>
            <param name="newType">New VistaDBType type for the column</param>
            <param name="newMaxLen">New maximum length for character column. 
            If new VistaDBType type doesn't support this maximum the parameter has no effect.
            Pass 0 value to use existing maxLen.</param>
            <returns>IVistaDBColumnAttributes describing altered column</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AlterColumnType(System.String,VistaDB.VistaDBType)">
            <summary>
            Alter the type of existing column
            </summary>
            <param name="name">Name of the existing column</param>
            <param name="newType">New VistaDBType type for the column</param>
            <returns>IVistaDBColumnAttributes describing altered column</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.AlterColumnOrder(System.String,System.Int32)">
            <summary>
            Defines the new zero based column order for the column by its name in existing table schema. 
            The other columns will be re-ordered in the table schema respectively.
            </summary>
            <param name="name">Name of the column</param>
            <param name="order">New column order in the table row</param>
            <returns>IVistaDBColumnAttributes describing altered column</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DefineIndex(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Define new index entry in table schema or update the existing one
            </summary>
            <param name="name">Index name</param>
            <param name="keyExpression">Key expression - Columns to be included in the index</param>
            <param name="primary">Is this the primary index.  All primary key indexes must be unique.</param>
            <param name="unique">The index unique. Has no effect if primary flag has been set</param>
            <returns>Instance of new IVistaDBIndexInformation</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DropIndex(System.String)">
            <summary>
            Drop existing index from the table schema.
            </summary>
            <remarks>
            Drop existing index from the table schema. The method doesn't do 
            an actual delete operation but updates table schema in order 
            to use this information with latest alter table functionality.
            To free the space allocated in the database file a PackDatabase operation must be performed.
            </remarks>
            <param name="name">Index name</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DefineIdentity(System.String,System.String,System.String)">
            <summary>
            Assign the identity to the column. 
            </summary>
            <remarks>
            VistaDB supports identity for the Int16, Int32 and Int64 data types only. The identity 
            counter does not participate transactions, thus it ensures unique value
            is assigned to the column in multi-user environment.
            Note, the engine doesn't check existing rows for the column values, 
            so setting identity doesn't check unique numbers. 
            You may set the unique index on this column, to ensure you have unique values from an identity.
            </remarks>
            <param name="columnName">Column's name</param>
            <param name="seedValue">The initial identity value. This value may be evaluated throw v-expression</param>
            <param name="stepExpression">The step value to use for identity. The step may be evaluated throw v-expression</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DropIdentity(System.String)">
            <summary>
            Drop existing identity
            </summary>
            <param name="columnName">Column's name the identity is assigned to</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DefineDefaultValue(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Assign default value to the column.
            </summary>
            <remarks>
            The default value may be either a constant or the evaluated one throw sql expression.
            You cannot set default value if identity has already been assigned 
            to the column.
            </remarks>
            <param name="columnName">Column name</param>
            <param name="scriptExpression">Expression to evaluate to the default when it is not provided as a part of the udpate</param>
            <param name="useInUpdate">When set, the engine uses this value in update operations, too</param>
            <param name="description">Description for the default value</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DropDefaultValue(System.String)">
            <summary>
            Drop the default value assigned to the column
            </summary>
            <param name="columnName">Column's name</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DefineConstraint(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Set constraint to check after insert, update or before delete operations.
            </summary>
            <param name="name">Constraint name</param>
            <param name="scriptExpression">Expression to evaluate during constraint check operations.</param>
            <param name="description">User's description to constraint</param>
            <param name="insert">When it is set to the true, the constraint will be checked after insert row operation</param>
            <param name="update">When it is set to the true, the constraint will be checked after update row operation</param>
            <param name="delete">When it is set to the true, the constraint will be checked after before delete operation. If v-expression is being evaluated to the false, the row will not be deleted</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBTableSchema.DropConstraint(System.String)">
            <summary>
            Drop an existing constraint.
            </summary>
            <param name="name">Constraint name (must exist)</param>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Name">
            <summary>
            Name of the Table this schema was loaded from on disk.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Description">
            <summary>
            Table description
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.ColumnCount">
            <summary>
            Number of columns in the table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.DroppedColumns">
            <summary>
            The collection of names the dropped columns in the origin table schema
            </summary>
            <seealso cref="P:VistaDB.DDA.IVistaDBColumnAttributes.UniqueId"/>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.RenamedColumns">
            <summary>
            The collection of names the renamed columns in the origin table schema
            </summary>
            <seealso cref="P:VistaDB.DDA.IVistaDBColumnAttributes.UniqueId"/>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Indexes">
            <summary>
            Collection of index information objects for this table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Identities">
            <summary>
            Collection of identity information objects for this table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.DefaultValues">
            <summary>
            Collection of column default values information.  These are the default value scripts defined for a column.
            Valid values are strings like:  GetDate(), NewGuid(), 0
            The entry must be valid for that column type.  Setting 0 on a DateTime column will result in an exception when it is used.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Constraints">
            <summary>
            Collection of constraints for this table (without foreign keys)
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Triggers">
            <summary>
            Collection of CLR triggers assigned to this table
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.ForeignKeys">
            <summary>
            Information about relationshipss for this table through the foreign keys constraints
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Item(System.String)">
            <summary>
            Attributes of the table's column with specified name
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.Item(System.Int32)">
            <summary>
            Attributes of the table's column with specified column index in the row
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.IsSynchronized">
            <summary>
            Gets if the table is participating within synchronization services.
            <remarks>The table cannot be altered or deleted while it is enrolled with a sync service provider.</remarks>
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.IsTombstoneTable">
            <summary>
            This table is collection of deleted rows used by database synchronization services.  There is no need to manually
            manipulate this table, it is handled automatically by the VistaDB Engine.
            <remarks>The table cannot be altered or deleted manually while marked to be participating in sync services.</remarks>
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBTableSchema.IsSystemTable">
            <summary>
            The table is used by VistaDB engine core as a system resource.
            <remarks>The table cannot be deleted or altered while it is marked as a system resource.</remarks>
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Table.TableSchema.temporary">
            <summary>
            Mark temporary schema in alter table
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBIndexCollection">
            <summary>
            List of table's indexes
            </summary>
            <example>
            Through the DDA interfaces you can use this collection to determine if an index exists for a given table.
            <code>
            IVistaDBDatabase db = DDAUtils.BuildTestDatabase(ref DDAObj, dbname, false, null, false); 
            IVistaDBTableSchema schema = db.TableSchema("Table1"); 
            IVistaDBIndexCollection ixlist = schema.Indexes; 
            if( ixlist["targetindex"] == null ) 
            { 
               // Index does not exist 
            }
            </code>
            </example>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBKeyColumn">
            <summary>
            Meta information about column participating an index key
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBKeyColumn.RowIndex">
            <summary>
            The order of this column in the parent table row
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBKeyColumn.Descending">
            <summary>
            Shows if the column has descend order in respective index
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBIndexInformation">
            <summary>
            Set of index flags and attributes
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.Name">
            <summary>
            Index's name
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.KeyExpression">
            <summary>
            Key expression
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.KeyStructure">
            <summary>
            Get array of table row columns indexes participating in the index key.
            It is ordered according to list of columns in Filter Expression
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.Primary">
            <summary>
            The index is primary
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.Unique">
            <summary>
            Are key values unique values enforced by the unique constraint?
            This index being standard sets unique 
            constraint for table insert/update operations
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.FKConstraint">
            <summary>
            Is this index built to support Foreign Key support?
            The index is internal to the engine and cannot be dropped explicitly.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.FullTextSearch">
            <summary>
            The index is generated by engine to support full text search. 
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIndexInformation.Temporary">
            <summary>
            The index is temporary. It is not added to database storage and kept separately in user temporary directory.
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBDefaultValueCollection">
            <summary>
            The collection of column default value information
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBDefaultValueInformation">
            <summary>
            Default value expression assigned to a column
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDefaultValueInformation.ColumnName">
            <summary>
            Column name the script is being assigned to
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDefaultValueInformation.Expression">
            <summary>
            SQL Expression to calculate default value
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDefaultValueInformation.UseInUpdate">
            <summary>
            When it is set, the default value is used in update operations as well
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBIdentityCollection">
            <summary>
            Collection of identities 
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBIdentityInformation">
            <summary>
            Identity assigned to the column
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIdentityInformation.ColumnName">
            <summary>
            The name of column the identity is set on
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIdentityInformation.StepExpression">
            <summary>
            Script to evaluate the step expression
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBIdentityInformation.SeedValue">
            <summary>
            Current identity value converted to string
            </summary>
            <remarks>The request of this value for existing table 
            is followed by opening the table, reading last identity 
            value and the closing the table</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.Table.TableSchema.IdentityCollection.IdentityInformation.CopySeedValue(VistaDB.Engine.Core.Table.TableSchema.IdentityCollection.IdentityInformation)">
            <summary>
            Copy the SeedValue from another provided IdentityInformation object (such as when renaming an IDENTITY column).
            </summary>
            <param name="originalIdentity">The original IdentityInformation instance whose current (stored) IDENTITY seed value
            should be copied to this new instance.</param>
            <returns>True if successfully copied.  False if SeedValue is already set for this instance.</returns>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBConstraintCollection">
            <summary>
            Collection of constraints
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBConstraintInformation">
            <summary>
            Script expression constraint
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConstraintInformation.Name">
            <summary>
            Name of constraint
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConstraintInformation.Expression">
            <summary>
            SQL script expression evaluated to boolean result. 
            It is supposed the constraint is being passed when 
            it is evaluated to the true boolean result.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConstraintInformation.AffectsInsertion">
            <summary>
            Constraint is evaluated during insert operation
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConstraintInformation.AffectsUpdate">
            <summary>
            Constraint is evaluated during update operation
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConstraintInformation.AffectsDelete">
            <summary>
            Constraint is evaluated during delete operation
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.IDatabase">
            <summary>
            Supports database interface between sql and core engine. Provides internal functionality 
            the core should implement to be used by sql
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBDatabase">
            <summary>
            The VistaDB Database including common database settings and operations
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.GetTableNames">
            <summary>
            Collection of table information
            </summary>
            <returns>Collection of table information</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.ContainsTable(System.String)">
            <summary>
            Does this database contain a table with this name?
            </summary>
            <param name="Tablename"></param>
            <returns>bool true if the table as found</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.OpenTable(System.String,System.Boolean,System.Boolean)">
            <summary>
            Open table
            </summary>
            <param name="name">Table name</param>
            <param name="exclusive">Table will be accessed exclusively by this table instance only</param>
            <param name="readOnly">Table instance will be accessed for read-only. The other instances still may write to the table 
            unless shareReadOnly database opening flag has set to the true value</param>
            <returns>Instance of IVistaDBTable</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.TableSchema(System.String)">
            <summary>
            Get table schema existing in the database. You may read table schema without 
            opening the table
            </summary>
            <param name="name">Table name</param>
            <returns>IVistaDBTableSchema instance</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.NewTable(System.String)">
            <summary>
            The first method to call in order to create new table in database. This method instantiates an IVistaDBTableSchema object and returns it.
            </summary>
            <param name="name">The name of new table</param>
            <returns>IVistaDBTableSchema empty instance</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.CreateTable(VistaDB.DDA.IVistaDBTableSchema,System.Boolean,System.Boolean)">
            <summary>
            Create new table given the table schema.  You should call NewTable() first to get the schema to pass to this function.
            </summary>
            <param name="schema">Table schema to create</param>
            <param name="exclusive">When it is set, the table instance 
            will have exclusive access to the table.  Any other open attempts on the table will fail.</param>
            <param name="readOnly">When it is set, the table instance 
            will have read-only access to the table. Any other opened instance may write to the table if this is nonexclusive.</param>
            <returns>IVistaDBTable instance</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.AlterTable(System.String,VistaDB.DDA.IVistaDBTableSchema)">
            <summary>
            Alter table in according to new table schema
            </summary>
            <param name="oldName">The current name of table to alter</param>
            <param name="schema">Modified table schema</param>
            <remarks>You should get the instance of IVistaDBTableSchema by TableSchema, 
            modify it and send to this method to apply table changes. You may pass null reference to <typeparamref name="newName"/> parameter 
            if you are not defining new name</remarks>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.TableSchema(System.String)"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.DropTable(System.String)">
            <summary>
            Drop existing table. The engine will verify it is possible to delete 
            the table and maintain relationships integrity in the database before allowing the DropTable to succeed. 
            </summary>
            <param name="name">Table name</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.TestDatabaseObjectName(System.String,System.Boolean)">
            <summary>
            Test if name of table, column, index etc. is correct
            </summary>
            <param name="name">Object name to test</param>
            <param name="raiseException">Raises exception instead of returning test result value</param>
            <exception cref="T:VistaDB.Diagnostic.VistaDBException">Raises VistaDBException with Errors.dda_InvalidName error</exception>
            <seealso cref="T:VistaDB.Diagnostic.Errors"/>
            <returns>Test status</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.ExportXml(System.String,VistaDB.DDA.VistaDBXmlWriteMode)">
            <summary>
            Export database schema and table data to xml-formated 
            file according to the transfer list of tables. If relationships set in database, 
            the information will be exported only concerning those ones, which link tables included 
            into the transfer list.
            </summary>
            <param name="xmlFileName">XML file name</param>
            <param name="mode">The export mode</param>
            <returns>The total number of rows of data exported to the XML file, or a negative value
            if a non-error usage scenario prevents export from being possible</returns>
            <exception cref="T:System.Security.SecurityException">A SecurityException may be thrown by
            the .NET framework when attempting to create or write to the specified file.</exception>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.ImportXml(System.String,VistaDB.DDA.VistaDBXmlReadMode,System.Boolean)">
            <summary>
            Update database schema and import table data in according to the transfer list of tables.
            </summary>
            <param name="xmlFileName">XML file name</param>
            <param name="mode">The import mode</param>
            <param name="interruptOnError">When set, the import process will be interrupted 
            by any error and respective exception will be raised</param>
            <returns>The total number of rows of data imported from the XML file, or a negative value
            if a non-error usage scenario prevents import from being possible</returns>
            <exception cref="T:VistaDB.Diagnostic.VistaDBException">A VistaDBException may be thrown if
            improper use of the API would prevent import from being possible.</exception>
            <exception cref="T:System.Security.SecurityException">A SecurityException may be thrown by
            the .NET framework when attempting to access the specified file.</exception>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.ImportXml(System.Xml.XmlReader,VistaDB.DDA.VistaDBXmlReadMode,System.Boolean)">
            <summary>
            Update database schema and import table data through XmlReader.
            </summary>
            <param name="xmlReader">Instance of System.Xml.XmlReader class</param>
            <param name="mode">The import mode</param>
            <param name="interruptOnError">When set, the import process will be interrupted 
            by any error and an exception will be raised</param>
            <returns>The total number of rows of data imported from the XML file, or a negative value
            if a non-error usage scenario prevents import from being possible</returns>
            <exception cref="T:VistaDB.Diagnostic.VistaDBException">A VistaDBException may be thrown if
            improper use of the API would prevent import from being possible.</exception>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.AddToXmlTransferList(System.String)">
            <summary>
            Add table name to the table transfer list used by xml ExportXml/ImportXml functions.
            </summary>
            <param name="tableName">Table name to add</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.ClearXmlTransferList">
            <summary>
            Clear table transfer list used by xml export/import routines.
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.GetLastIdentity(System.String,System.String)">
            <summary>
            Get last value assigned to the identity column in table insert operation at this database instance. 
            The table inserted the row may be already closed at current moment.
            </summary>
            <param name="tableName">Table name</param>
            <param name="columnName">Name of column containing identity</param>
            <returns>IVistaDBColumn instance containing last identity value. If identity is not set for the column null returned</returns>
            <remarks>You may input null instead column name to get first identity column in the row. You may input null instead 
            table name to get identity from table with last insertion</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.GetLastTimestamp(System.String)">
            <summary>
            Get last value assigned to the timestamp column in the table insert operation for this database instance. 
            The table inserted the row may be already closed at current moment.
            </summary>
            <param name="tableName">Table name</param>
            <returns>IVistaDBColumn instance containing last timestamp value. If timestamp is not set the null reference returned</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.BeginTransaction">
            <summary>
            Begin transaction in ReadCommitted isolation level
            </summary>
            <see cref="P:VistaDB.DDA.IVistaDBDatabase.IsolationLevel"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Begin transaction
            </summary>
            <param name="level">The isolation level of the transaction</param>
            <see cref="P:VistaDB.DDA.IVistaDBDatabase.IsolationLevel"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.CommitTransaction">
            <summary>
            Commit transaction
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.RollbackTransaction">
            <summary>
            Rollback current transaction
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.AddAssembly(System.String,System.String,System.String)">
            <summary>
            Add assembly from external file and store it in database for use by CLR Procs, triggers, etc.
            Does not load any third party dependencies.  If you need an external dependency to be included
            you should ILMERGE the assemblies together.
            </summary>
            <param name="assemblyName">The assembly name to register in database</param>
            <param name="assemblyFileName">The full file name containing the assembly</param>
            <param name="description">User's description</param>
            <remarks>If assembly with same name is already registered, an exception raised</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.UpdateAssembly(System.String,System.String,System.String)">
            <summary>
            Update existing assembly registered in database with new assembly.  Will remove any clr procs or functions that
            are not present in new assembly.  Third party assemblies are not loaded into the database.
            </summary>
            <param name="assemblyName">The assembly name to replace</param>
            <param name="assemblyFileName">The full file name containing the assembly</param>
            <param name="description">User's description</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.DropAssembly(System.String,System.Boolean)">
            <summary>
            Drop the assembly from database
            </summary>
            <param name="assemblyName">The assembly name to delete</param>
            <param name="force">Delete the assembly and all CLR Procs referencing it</param>
            <remarks>If assembly referenced by CLR Proc and <paramref name="force"/> is set to false an exception raised. 
            You may force to delete the assembly and all CLR Procs referencing it</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.GetAssemblies">
            <summary>
            Get a collection of the assemblies currently registered in the database (CLR Procs, CLR Triggers, etc).
            </summary>
            <returns>Collection of IVistaDBAssembly objects</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.GetClrProcedures">
            <summary>
            Get collection of Clr Procs in database
            </summary>
            <returns>The collection of CLR Proc descriptions and information</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.GetClrTriggers">
            <summary>
            Collection of CLR Triggers registered in database.  These triggers are contained within an assembly and referenced through
            trigger naming.
            </summary>
            <returns>The collection of CLR Triggers</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.GetClrTriggers(System.String)">
            <summary>
            Get Collection of CLR Triggers for a specific table.
            </summary>
            <param name="tableName">The table name to filter the search.</param>
            <returns>Collection of CLR Triggers</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.RegisterClrProcedure(System.String,System.String,System.String,System.String)">
            <summary>
            Looks for CLR Proc in assembly. If CLR Proc found, registers the link to this method by custom name 
            </summary>
            <param name="procedureName">The CLR Proc custom name to register</param>
            <param name="clrHostedMethod">The full name of CLR Proc hosted method. The name should 
            include namespace the CLR Proc belongs to. The procedure should be static</param>
            <param name="assemblyName">The name of assembly registered in database with <b>CreateAssembly</b> or <b>UpdateAssembly</b></param>
            <param name="description">User's description for this procedure. May be a null reference (Nothing in Visual Basic)</param>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.AddAssembly(System.String,System.String,System.String)"/>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.UpdateAssembly(System.String,System.String,System.String)"/>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.UnregisterClrProcedure(System.String)"/>
            <remarks>The assembly may contain a method to treat row results got with CLR Proc. In such case the CLR Proc should be marked with 
            VistaDBCLRKind attribute having the property FillRow initialize with name of respecting method</remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.UnregisterClrProcedure(System.String)">
            <summary>
            Unregister the link to CLR Proc
            </summary>
            <param name="procedureName">The custom CLR Proc name</param>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.RegisterClrProcedure(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.PrepareClrContext">
            <summary>
            Prepare current context to use by Clr Procedure or Trigger
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.PrepareClrContext(VistaDB.DDA.IVistaDBPipe)">
            <summary>
            Prepare current context to use by CLR Proc or trigger
            <param name="pipe">The user-defined object to accept data issued by CLR Proc or trigger</param>
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.UnprepareClrContext">
            <summary>
            Release current context used by CLR Proc
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.InvokeClrProcedure(System.String,System.Object[])">
            <summary>
            Invoke Clr Procedure.  Assembly must already be loaded into database and procedure name associated.
            </summary>
            <param name="procedureName">The Clr Procedure custom name</param>
            <param name="parameters">
            An argument list for the invoked method. This is a set of objects with the 
            same number, order, and type as the parameters of the function or procedure to be invoked</param>
            <returns>An object containing the return value of the invoked function, or 
            a null reference (Nothing in Visual Basic) in the case of invoked procedure.</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.InvokeClrProcedureFillRow(System.String,System.Object[])">
            <summary>
            Invoke the FillRow method for Clr Procedure
            </summary>
            <param name="procedureName">The Clr Procedure custom name</param>
            <param name="parameters">
            An argument list for the invoked method. This is a set of objects with the 
            same number, order, and type as the parameters of the function or procedure to be invoked</param>
            <returns>An object containing the return value of the invoked function, or 
            a null reference (Nothing in Visual Basic) in the case of invoked procedure.</returns>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.RegisterClrTrigger(System.String,System.String,System.String,System.String,VistaDB.TriggerAction,System.String)">
            <summary>
            Looks for CLR Trigger in assembly. If CLR Trigger found, registers user provided name.
            </summary>
            <param name="triggerName">The CLR Trigger custom name to register</param>
            <param name="clrHostedMethod">The full name of CLR Trigger hosted method. The name should 
            include namespace the CLR Trigger belongs to. The procedure should be static</param>
            <param name="assemblyName">The name of assembly registered in database with <b>CreateAssembly</b> or <b>UpdateAssembly</b></param>
            <param name="tableName">The name of table the trigger is set on</param>
            <param name="triggerAction">The table level event to fire trigger</param>
            <param name="description">User's description for this procedure. May be null (Nothing in VB.NET) to exclude a description.</param>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.AddAssembly(System.String,System.String,System.String)"/>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.UpdateAssembly(System.String,System.String,System.String)"/>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.UnregisterClrProcedure(System.String)"/>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.UnregisterClrTrigger(System.String)"/>
            <remarks>
            Current version supports DML triggers. Only AfterInsert, AfterUpdate and AfterDelete actions supported by CLR Triggers
            <para>
            Also note that the DLL containing the CLR Trigger is loaded INTO the database and is no longer required.  
            This is to prevent a situation where the DLL is deleted or no longer with the database causing the database to no longer work.
            </para>
            <para>
            During development of a CLR Trigger you will have to Unregister and Register  the CLRTrigger into the database each time you 
            rebuild your DLL for the changes to be loaded.  The database does not look at the DLL after this initial registration.
            </para>
            </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.UnregisterClrTrigger(System.String)">
            <summary>
            Unregister the link to CLR Trigger
            </summary>
            <param name="triggerName">The custom CLR Trigger name</param>
            <remarks>
            During development of a CLR Trigger you will have to Unregister and Register the CLRTrigger into the database each time you 
            rebuild your DLL for the changes to be loaded.  The database does not look at the DLL after this initial registration.  The entire assembly
            is loaded internal to the database file.
            </remarks>
            <seealso cref="M:VistaDB.DDA.IVistaDBDatabase.RegisterClrTrigger(System.String,System.String,System.String,System.String,VistaDB.TriggerAction,System.String)"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.ActivateSyncService(System.String)">
            <summary>
            Restructure table in order to allow sync service to work
            </summary>
            <param name="tableName">Table name the sync service is being activated for</param>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDatabase.DeactivateSyncService(System.String)">
            <summary>
            Restructure table in order to exclude meta information allowing sync service to work
            </summary>
            <param name="tableName">Table name the sync service is being deactivated for</param>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.Culture">
            <summary>
            Database culture used to collate character data or apply date 
            and time masks in filters or queries
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.CaseSensitive">
            <summary>
            Database sensitivity in character data
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.PageSize">
            <summary>
            The Page size in kilobytes.  A setting of 1 = 1,024 bytes. 
            </summary>
            <remarks>
            <para>
            The optimal pagesize should be large enough to hold 3-5 records in your database.  
            You may change this at anytime, but the database must be packed after the change.
            </para>
            </remarks>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.IsDatabaseCurrentFormatVersion">
            <summary>
            Whether the format version of this database is the current version (the latest version known to this version
            of the VistaDB provider engine).
            </summary>
            <remarks>If false then this database can not be opened for writing by this engine until it is first upgraded
            with a Pack operation.  Some recent older versions may be opened in read-only mode and allow interactive access
            without requiring a Pack.  However, a Pack operation will always upgrade to the latest format known to the
            engine being used.</remarks>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.CanDatabaseVersionEncryptPages">
            <summary>
            Whether the format version of this database supports page encryption (true) or only column encryption (false).
            If true then the column attribute "Encrypted" is meaningless. (<seealso cref="P:VistaDB.DDA.IVistaDBDatabase.ArePagesEncrypted"/>)
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.ArePagesEncrypted">
            <summary>
            Whether this database is encrypted at the database page level.
            (<seealso cref="P:VistaDB.DDA.IVistaDBDatabase.PageEncryptionAlgorithm"/>)
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.PageEncryptionAlgorithm">
            <summary>
            The algorithm used to encrypt database pages ("None" if not enabled, null if N/A for this database format).
            (<seealso cref="P:VistaDB.DDA.IVistaDBDatabase.ArePagesEncrypted"/>)
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.Mode">
            <summary>
            Read current database opening mode
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.IsolatedStorage">
            <summary>
            Database file resides in isolated storage
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.Description">
            <summary>
            Database description
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.NestedTransactionLevel">
            <summary>
            Current level for nested transactions
            </summary>
            <remarks>Nested transactions are not supported at this time. 
            The value returned by this property is the number of active transactions. 
            1 means active transaction, 0 means no transactions in progress.</remarks>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.IsolationLevel">
            <summary>
            Isolation level for current transaction
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.Relationships">
            <summary>
            Relationships collection from the database
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBDatabase.VersionGuid">
            <summary>
            Read only unique identifier assigned to this database schema version. Used for sync and schema updates systems.
            You cannot infer anything to the meaning of the guid other than to compare if they are equal.
            If they are equal then you have two databases with the exact same schema version.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.IDatabase.GetTableAnchor(System.String)">
            <summary>
            Reads current timestamp value from table header
            </summary>
            <param name="tableName"></param>
            <returns>current timestamp value or null if table has no timestamp column</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DatabaseMetaTable.SetRepairMode(System.Boolean)">
            <summary>
            Set if we are in repair mode or not for pack operations.
            </summary>
            <param name="repair">True for repair mode</param>
        </member>
        <member name="T:VistaDB.Engine.Core.Cryptography.EncryptionKey">
            <summary>
            EncryptionKey encapsulation class
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Cryptography.EncryptionKey.Cypher.None">
            <summary>
            No encryption.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Cryptography.EncryptionKey.Cypher.Blowfish">
            <summary>
            Per-column encryption using Blowfish (as of VistaDB 5:  no longer used except for reading older databases).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Cryptography.EncryptionKey.Cypher.AES128">
            <summary>
            Per-page encryption using Advanced Encryption Standard (with 128-bit key).
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Cryptography.Encryption">
            <summary>
            Provides encryption/decryption functionality
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Encryption.SetPosition(System.Int64)">
            <summary>
            Initialize this instance for block encryption/decryption dependent upon the position of the block in the file.
            </summary>
            <param name="filePosition">The file position of the start of the block (cluster) being read or written as a
            whole.  Special handling may be used for the first block of the file.</param>
        </member>
        <member name="T:VistaDB.Engine.Core.Cryptography.BlowFishEncryption">
            <summary>
            BlowFish cryptography (64-bit encryption based on user given string hash)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Cryptography.Md5">
            <summary>
            MD5 digital signature calculator based on
            RSA Data Security, Inc. MD5 Message-Digest Algorithm.
            See RFC 1321 for RSA Data Security's copyright and license notice
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Encode(System.Byte[],System.Int32,System.UInt32[],System.Int32,System.Int32)">
            <summary>
            Encode count bytes at source into (count / 4) uint's at target
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Decode(System.UInt32[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode count uint's at source into (count * 4) bytes at target
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Transform(System.Byte[],System.Int32,System.UInt32[])">
            <summary>
            Transform State according to first 64 bytes at Buffer
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Init(VistaDB.Engine.Core.Cryptography.Md5.MD5Context)">
            <summary>
            Initialize given Context
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Final(VistaDB.Engine.Core.Cryptography.Md5.MD5Context,System.Byte[])">
            <summary>
            Finalize given context and create digest
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.DigestToBytes(System.String)">
            <summary>
            Create digest of given message
            </summary>
            <param name="message"></param>
            <returns>digest that is array of 16 bytes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.DigestToBytes(System.Byte[])">
            <summary>
            Create digest of given message
            </summary>
            <param name="array"></param>
            <returns>digest that is array of 16 bytes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.DigestToSignature(System.String)">
            <summary>
            Create digest Signature of given message
            </summary>
            <param name="message"></param>
            <returns>digest that is array of 16 bytes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.DigestToSignature(System.Byte[])">
            <summary>
            Create digest Signature of given message
            </summary>
            <param name="array"></param>
            <returns>digest that is array of 16 bytes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Match(System.Byte[],System.Byte[])">
            <summary>
            Compare two Digests
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.IsEmpty(System.Byte[])">
            <summary>
            Check if Digests is empty
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Reset(System.Byte[])">
            <summary>
            set empty digest
            </summary>
            <param name="digest"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Signature.#ctor(System.Int64,System.Int64)">
            <summary>
            Encapsulate an MD5 Signature from two Int64 values.
            </summary>
            <param name="low"></param>
            <param name="high"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.Md5.Signature.#ctor(System.Byte[])">
            <summary>
            Encapsulate an MD5 Signature from a 16-byte array which will not be kept by this instance.
            </summary>
            <param name="array">A 16-byte array containing an MD5 hash value (or null for empty == all 0's).</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Cryptography.VdbBitConverter.GetBytes(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Quick equivalent for Array.Copy(BitConverter.GetBytes(uint value), int originOffset, byte[] buffer, int offset, int len).
            Method doesn't allocate new byte array but writes to destination array directly
            </summary>
            <param name="val">the value to convert</param>
            <param name="buffer">destination buffer</param>
            <param name="offset">initial offset in destination buffer</param>
            <param name="len">the length of destination buffer to fill out with data</param>
            <returns>resulting offset in destination buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.EvalStack.SyncNext">
            <summary>
            Synchronize p-code signatures according to actual parameters number and their types
            </summary>
            <returns>Status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.EvalStack.SignaturesValidation(System.Boolean,System.String@)">
            <summary>
            Walk the PCode stack and ensure we built a valid expression
            </summary>
            <param name="checkBoolean">Is this a logical expression?  If it is we should only output a bit as a result.  Any other type of result is invalid.</param>
            <param name="expression">The actual expression that we used to build this stack</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.EvalStack.Exec(VistaDB.Engine.Core.Row)">
            <summary>
            This overloaded signature expects boolean result evaluated
            </summary>
            <param name="contextRow"></param>
        </member>
        <member name="T:VistaDB.Engine.Core.RowIdFilter">
            <summary>
            This filter of available RowId built with byte[]
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.#ctor(VistaDB.Engine.Core.RowIdFilter)">
            <summary>
            Construct a RowIdFilter as a copy of another given RowIdFilter set.
            </summary>
            <param name="filter">The RowIdFilter to copy.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.#ctor(System.UInt32)">
            <summary>
            Construct a RowIdFilter with an activeRows bitmap up to a specified maxRowId.
            </summary>
            <param name="maxRowId">The max rowId that occurs in the underlying DataStorage.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.#ctor">
            <summary>
            Construct a RowIdFilter without an activeRows bitmap (used for derived type ConstantRowIdFilter).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.OnConjunction(VistaDB.Engine.Internal.IOptimizedFilter)">
            <summary>
            Compute the Conjunction (set intersection) of this RowIdFilter instance with another given IOptimizedFilter,
            and update this instance to the normalized results.  (The argument filter is unchanged.)
            </summary>
            <param name="filter">The IOptimizedFilter to combine with this instance by Conjuntion (set intersection).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which have been inverted from the default False to True.)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.OnDisjunction(VistaDB.Engine.Internal.IOptimizedFilter)">
            <summary>
            Compute the Disjunction (set union) of this RowIdFilter instance with another given IOptimizedFilter,
            and update this instance to the normalized results.  (The argument filter is unchanged.)
            </summary>
            <param name="filter">The IOptimizedFilter to combine with this instance by Disjuntion (set union).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which have been inverted from the default False to True.)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.OnInvert(System.Boolean)">
            <summary>
            Invert all True and False entries by (instant == false) just inverting the this.inverted flag or
            (instant == true) by also normalizing all entries if this.inverted is true after being inverted.
            </summary>
            <param name="instant">Whether to perform immediate normalization of entries (true) or defer
            normalization (false).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which invert from the default False to True.)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.Conjunction(VistaDB.Engine.Internal.IOptimizedFilter)">
            <summary>
            Compute the Conjunction (set intersection) of this RowIdFilter instance with another given IOptimizedFilter,
            and update this instance to the normalized results.  (The argument filter is unchanged.)
            </summary>
            <param name="filter">The IOptimizedFilter to combine with this instance by Conjuntion (set intersection).</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.Disjunction(VistaDB.Engine.Internal.IOptimizedFilter)">
            <summary>
            Compute the Disjunction (set union) of this RowIdFilter instance with another given IOptimizedFilter,
            and update this instance to the normalized results.  (The argument filter is unchanged.)
            </summary>
            <param name="filter">The IOptimizedFilter to combine with this instance by Disjuntion (set union).</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.Invert(System.Boolean)">
            <summary>
            Invert all True and False entries by (instant == false) just inverting the this.inverted flag or
            (instant == true) by also normalizing all entries if this.inverted is true after being inverted.
            </summary>
            <param name="instant">Whether to perform immediate normalization of entries (true) or defer
            normalization (false).</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.GetConstant">
            <summary>
            Returns the Constant value if this filter IsConstant(), or Undefined if this filter is not constant.
            </summary>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Engine.Core.RowIdFilter.RowCount">
            <summary>
            A count of the number of resulting True entries.  (This could include deleted rowId entries which have
            been inverted from the default False to True.)  Valid for determining if this RowIdFilter is empty.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.#ctor(VistaDB.Engine.Core.RowIdFilter.ActiveRows)">
            <summary>
            Construct an ActiveRows bitmap as a copy of another given ActiveRows bitmap.
            </summary>
            <param name="activeRows">The ActiveRows bitmap to copy.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.#ctor(System.UInt32)">
            <summary>
            Construct an ActiveRows bitmap with entries initialized to False (except rowId == 0, rowId > maxRowId
            are initialized to Null).
            </summary>
            <param name="maxRowId">The max rowId existing in the underlying DataStorage as the upper bound for
            the bitmap.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.GetValidStatus(System.UInt32)">
            <summary>
            Test whether a given rowId entry holds the value True.  (Does not account for this.inverted flag.)
            </summary>
            <param name="rowId"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.SetValidStatus(System.UInt32,System.Boolean)">
            <summary>
            Set a given rowId entry to True (setTrueValue == true) or to Null (setTrueValue == false).
            </summary>
            <param name="rowId"></param>
            <param name="setTrueValue"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.Invert(System.Boolean)">
            <summary>
            Invert all True and False entries by (immediateNormalize == false) just inverting the this.inverted flag or
            (immediateNormalize == true) by also normalizing all entries if this.inverted is true after being inverted.
            </summary>
            <param name="immediateNormalize">Whether to perform immediate normalization of entries (true) or defer
            normalization (false).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which invert from the default False to True.)  MinValue means count is unchanged from a previous
            computation.  MaxValue means count is unknown but presumed positive.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.Disjunction(VistaDB.Engine.Core.RowIdFilter.ActiveRows)">
            <summary>
            Compute the Disjunction (set union) of this ActiveRows instance with another given ActiveRows filter,
            and update this instance to the normalized results.  (The argument filter is unchanged.)
            </summary>
            <param name="filter">The ActiveRows filter to combine with this instance by Disjuntion (set union).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which have been inverted from the default False to True.)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.Conjunction(VistaDB.Engine.Core.RowIdFilter.ActiveRows)">
            <summary>
            Compute the Conjunction (set intersection) of this ActiveRows instance with another given ActiveRows
            filter, and update this instance to the normalized results.  (The argument filter is unchanged.)
            </summary>
            <param name="filter">The ActiveRows filter to combine with this instance by Conjuntion (set intersection).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which have been inverted from the default False to True.)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.DisjunctionConstant(VistaDB.Engine.Core.Triangular.Value)">
            <summary>
            Compute the Disjunction (set union) of this ActiveRows instance with a constant-value filter set,
            and update this instance to the normalized results.
            </summary>
            <param name="triangular">The constant triangular-logic value of the filter set to combine with this
            instance by Disjuntion (set union).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which have been inverted from the default False to True.)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.ConjunctionConstant(VistaDB.Engine.Core.Triangular.Value)">
            <summary>
            Compute the Conjunction (set intersection) of this ActiveRows instance with a constant-value filter set,
            and update this instance to the normalized results.
            </summary>
            <param name="triangular">The constant triangular-logic value of the filter set to combine with this
            instance by Conjuntion (set intersection).</param>
            <returns>A count of the number of resulting True entries.  (This could include deleted rowId entries
            which have been inverted from the default False to True.)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RowIdFilter.ActiveRows.PrepareAttachment">
            <summary>
            Normalize this ActiveRows bitmap by applying the current this.inverted flag to all entries.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.IO.LockManager">
            <summary>
            Managed list of locks applied to the data storage.
            The applied locks are managed in memory and followed 
            by physical file lock/unlock operation according 
            to reference counter
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.LockManager.storageLock">
            <summary>
            Value ulong.MaxValue means the storage lock is not set
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.LockManager.LockObject(System.Boolean,System.UInt64,VistaDB.Engine.Core.IO.LockManager.LockType,System.Boolean@,System.Int32)">
            <summary>
            Lock an object
            </summary>
            <param name="userLock">it's row id lock requested by user</param>
            <param name="id">Object id</param>
            <param name="type">Object type</param>
            <param name="actualLock">Returns lock applying status. When false, the lock has been already set and it is increasing the lock counter only</param>
            <param name="lockTimeout">time out value in seconds</param>
        </member>
        <member name="T:VistaDB.Engine.Core.IO.LockManager.LockCollection">
            <summary>
            List of user's locks applied to the data storage.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.LockManager.LockCollection.syncObject">
            <summary>
            Expose a sync object for holding this collection for longer periods of time
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.LockManager.LockCollection.SetLock(System.UInt64)">
            <summary>
            Mark user's lock
            </summary>
            <param name="objectId">Row id. Zero for RowId collection means the lock for the whole datastorage</param>
            <returns>Status</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.LockManager.LockCollection.ResetLock(System.UInt64)">
            <summary>
            Remove user's lock
            </summary>
            <param name="objectId">Row/storage id. Zero for RowId collection means the lock for the whole datastorage</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.LockManager.LockCollection.LockedStatus(System.UInt64)">
            <summary>
            Check lock status for the row
            </summary>
            <param name="objectId">Row/storage id to check lock status</param>
            <returns>Current lock status</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.Cryptography.Lzh">
            <summary>
            Adaptive Huffman Coding.
            Based on Japanese version 29-NOV-1988
            LZSS coded by Haruhiko OKUMURA in C
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Cryptography.TestLZH">
            <summary>
            Test class to check Lzh functionality
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Scripting.PCodeUnit">
            <summary>
            Dynamic data that are treated by Signature objects. 
            Every operator treats as much PCodeUnit objects as 
            it has the number of input parameters and makes the 
            convolution of them to resulting PCodeUnit. If there are 
            no parameters, an operator just 'generates' a resulting value.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Scripting.Signature">
            <summary>
            Script function or operator
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Scripting.Signature.Parameters">
            VFunction(   a     ,      b      )
                     ^
                 bgnOfGroup - starts operator parameters' scope
                               ^
                             delimiter - delimits parameters
                                             ^
                                         endOfGroup - finalizes operator parameters scope
                            ^
                          spaceChar - fills the space between parameters and delimiters
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.ColumnSignature.#ctor(System.Int32,VistaDB.VistaDBType)">
            <summary>
            Any column
            </summary>
            <param name="groupId">group id for this operator</param>
            <param name="type">column type</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.Append.#ctor(System.String,System.Int32)">
            <summary>
            Any column
            </summary>
            <param name="name">Signature's name</param>
            <param name="groupId">Group id for this signature</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.Assign.#ctor(System.String,System.Int32,VistaDB.VistaDBType)">
            <summary>
            Assign value to column
            </summary>
            <param name="name">operator</param>
            <param name="groupId">group id for this operator</param>
            <param name="type">type of left operand to assign</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.GetUtcDate.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Current date and time on this computer, expressed as the Coordinated Universal Time (UTC). 
            </summary>
            <param name="name"></param>
            <param name="groupId"></param>
            <param name="endOfGroupId"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.GetDate.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Current date and time stamp
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.Date.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Current date stamp
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.GuidSignature.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Guid random generator
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.FloatConversion.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Current date stamp
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.DoubleConversion.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Current date stamp
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.Int64Conversion.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Current date stamp
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.StringConversion.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Current date stamp
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.IdentitySignature.#ctor(System.Int32,System.Int32)">
            <summary>
            Identity signature
            </summary>
            <param name="groupId">Group id for this signature</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.ReadOnlySignature.#ctor(System.Int32,System.Int32)">
            <summary>
            Read-only signature
            </summary>
            <param name="groupId">group id for this operator</param>
            <param name="endOfGroupId">End of group for this group operator</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.Descending.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Descending signature
            </summary>
            <param name="name">Signature name</param>
            <param name="groupId">group id for this operator</param>
            <param name="endOfGroupId">End of this group operator</param>
        </member>
        <member name="T:VistaDB.Engine.Core.Scripting.ForeignKeyConstraint">
            <summary>
            The operator look at primary index and see if 
            new foreign key references the existed primary one.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.ForeignKeyConstraint.#ctor(System.Int32,System.Int32)">
            <summary>
            ReferencedFK signature
            </summary>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of this group operator</param>
        </member>
        <member name="T:VistaDB.Engine.Core.Scripting.NonreferencedPrimaryKey">
            <summary>
            The operator look at foreign key index and see if 
            primary key referenced in the existed foreign key index.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.NonreferencedPrimaryKey.#ctor(System.Int32,System.Int32)">
            <summary>
            NonreferencedPK signature
            </summary>
            <param name="groupId">Group id for this operator</param>
            <param name="endOfGroupId">End of this group operator</param>
        </member>
        <member name="T:VistaDB.Engine.Core.Scripting.Summation">
            <summary>
            Base class for binary plus and minus operators
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Relationships.Freeze(System.Boolean)">
            <summary>
            Freeze all the relationships by setting this Active link to false.  This will prevent them
            from being checked during database operations.  Turning all of these off has the effect of
            stopping referential integrity from being checked.  This is done during certain operations to
            speed up their tasks, but the database should not normally be run in this state.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Relationships.Defreeze(System.Boolean)">
            <summary>
            Defreeze all the relationships by setting this Active link back to true. 
            This brings referential integrity back to the database.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.CharColumn">
            <summary>
            Char(X) column value instance.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.CharColumn.maxLength">
            <summary>
            Maximum number of character
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.CharColumn.culture">
            <summary>
            Culture information used in comparing to another character columns
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.CharColumn.caseInsensitive">
            <summary>
            Case insensitivity in comparing to another character columns
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.CharColumn.stringComparer">
            <summary>
            The culture and case-sensitivity dependent StringComparer to use when comparing this column
            or getting a hash code for its current value.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.CharColumn.encoding">
            <summary>
            Encoding to use in record buffer manipulations.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.CharColumn.actualLen">
            <summary>
            Helper dynamic length counter to keep right padding spaces in evaluations
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.CharColumn.#ctor(System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Char(X) column value constructor
            </summary>
            <param name="val">String value</param>
            <param name="maxLength">Maximum character number for this column</param>
            <param name="codePage">code page to encode in database file storage</param>
            <param name="culture">Culture information to use in compare operations</param>
            <param name="caseInsensitive">Use case insensitive compare operations</param>
        </member>
        <member name="M:VistaDB.Engine.Core.CharColumn.#ctor(VistaDB.Engine.Core.CharColumn)">
            <summary>
            Char(X) column value copy constructor
            </summary>
            <param name="col">Character column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.CharColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.CharColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Char type with same attributes</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.NCharColumn">
            <summary>
            NChar(X) column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.NCharColumn.Utf8CodePage">
            <summary>
            Implicit Unicode code page to use by encoding
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.NCharColumn.#ctor(System.String,System.Int32,System.Globalization.CultureInfo,System.Boolean,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial value</param>
            <param name="maxSize">Maximum character to accept</param>
            <param name="culture">Culture information to use in compare operations</param>
            <param name="caseInsensitive">Use case insensitive comparing</param>
            <param name="codePage">unicode code page</param>
        </member>
        <member name="M:VistaDB.Engine.Core.NCharColumn.#ctor(VistaDB.Engine.Core.NCharColumn)">
            <summary>
            NChar(X) column value copy constructor
            </summary>
            <param name="col">Unicode character column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.NCharColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of NChar type with same attributes</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.VarcharColumn">
            <summary>
            Varchar(X) column value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.VarcharColumn.#ctor(System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial value</param>
            <param name="maxSize">Maximum character to accept</param>
            <param name="codePage">Code page to encode character values before put to database storage file</param>
            <param name="culture">Culture information to use in compare operations</param>
            <param name="caseInsensitive">Use case insensitive comparing</param>
        </member>
        <member name="M:VistaDB.Engine.Core.VarcharColumn.#ctor(VistaDB.Engine.Core.VarcharColumn)">
            <summary>
            Varchar(X) column value copy constructor
            </summary>
            <param name="col">Varchar column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.VarcharColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Varchar type with same attributes</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.NVarcharColumn">
            <summary>
            NVarchar(X) column value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.NVarcharColumn.#ctor(System.String,System.Int32,System.Globalization.CultureInfo,System.Boolean,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial value</param>
            <param name="maxSize">Maximum character to accept</param>
            <param name="culture">Culture information to use in compare operations</param>
            <param name="caseInsensitive">Use case insensitive comparing</param>
            <param name="codePage">unicode code page</param>
        </member>
        <member name="M:VistaDB.Engine.Core.NVarcharColumn.#ctor(VistaDB.Engine.Core.NVarcharColumn)">
            <summary>
            NVarchar(X) column value copy constructor
            </summary>
            <param name="col">Unicode NVarchar column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.NVarcharColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of NVarchar type with same attributes</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.UnicodeColumn">
            <summary>
            Default column type used by sql parser
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.UnicodeColumn.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial value</param>
            <param name="culture">Culture information to use in compare operations</param>
            <param name="caseInsensitive">Use case insensitive comparing</param>
        </member>
        <member name="M:VistaDB.Engine.Core.UnicodeColumn.#ctor(VistaDB.Engine.Core.UnicodeColumn)">
            <summary>
            UnicodeColumn column value copy constructor
            </summary>
            <param name="col">Unicode character column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.UnicodeColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of UnicodeColumn with same attributes</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.TinyIntColumn">
            <summary>
            System.Byte column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.TinyIntColumn.ByteSize">
            <summary>
            Memory apartment in bytes to allocate Byte type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.TinyIntColumn.#ctor">
            <summary>
            Byte column Null value c-tor
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.TinyIntColumn.#ctor(System.Byte)">
            <summary>
            Byte column value c-tor
            </summary>
            <param name="val">Byte column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.TinyIntColumn.#ctor(VistaDB.Engine.Core.TinyIntColumn)">
            <summary>
            Byte column value copy constructor
            </summary>
            <param name="col">Byte column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.TinyIntColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Byte type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.TinyIntColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Byte value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.TinyIntColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Byte value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.TinyIntColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.SmallIntColumn">
            <summary>
            System.Int16 column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.SmallIntColumn.Int16Size">
            <summary>
            Memory apartment in bytes to allocate Int32 type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallIntColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallIntColumn.#ctor(System.Int16)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Int16 value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallIntColumn.#ctor(VistaDB.Engine.Core.SmallIntColumn)">
            <summary>
            Int16 column value copy constructor
            </summary>
            <param name="col">Int16 column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallIntColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Int16 type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallIntColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Int16 value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallIntColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Int16 value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallIntColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.BigIntColumn">
            <summary>
            System.Int64 column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.BigIntColumn.LongSize">
            <summary>
            Memory apartment in bytes to allocate Int64 type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BigIntColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BigIntColumn.#ctor(System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Int64 value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BigIntColumn.#ctor(VistaDB.Engine.Core.BigIntColumn)">
            <summary>
            Int64 column value copy constructor
            </summary>
            <param name="col">Int64 column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BigIntColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Int64 type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BigIntColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Int64 value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BigIntColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Int64 value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BigIntColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Timestamp.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Timestamp.#ctor(System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Timestamp value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Timestamp.#ctor(VistaDB.Engine.Core.Timestamp)">
            <summary>
            Timestamp column value copy constructor
            </summary>
            <param name="col">Timestamp column to copy from</param>
        </member>
        <member name="T:VistaDB.Engine.Core.DateTimeColumn">
            <summary>
            System.DateTime column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DateTimeColumn.DTSize">
            <summary>
            Memory apartment in bytes to allocate DateTime type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeColumn.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial DateTime value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeColumn.#ctor(VistaDB.Engine.Core.DateTimeColumn)">
            <summary>
            DateTime column value copy constructor
            </summary>
            <param name="col">DateTime column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DateTimeColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put DateTime value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get DateTime value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core._DateColumn">
            <summary>
            OLD _Date column value from VistaDB 3 or before
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core._DateColumn.DateSize">
            <summary>
            Memory apartment in bytes to allocate Date type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core._DateColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core._DateColumn.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Date value</param>
        </member>
        <member name="M:VistaDB.Engine.Core._DateColumn.#ctor(VistaDB.Engine.Core._DateColumn)">
            <summary>
            Date column value copy constructor
            </summary>
            <param name="col">Date column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core._DateColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DateColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core._DateColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Date value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core._DateColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get DateTime value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core._DateColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.TimeColumn">
            <summary>
            Time (only) column value (System.TimeSpan since Midnight).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.TimeColumn.TimeSize">
            <summary>
            Memory apartment in bytes to allocate Time type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.TimeColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.TimeColumn.#ctor(System.TimeSpan)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial TimeSpan value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.TimeColumn.#ctor(VistaDB.Engine.Core.TimeColumn)">
            <summary>
            DateTime column value copy constructor
            </summary>
            <param name="col">Time column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.TimeColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DateTimeColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.TimeColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Time value (TimeSpan) to record buffer (as Ticks).
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.TimeColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Time value from record buffer (as Ticks).
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.TimeColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.DateColumn">
            <summary>
            System.DateTime column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DateColumn.DateSize">
            <summary>
            Memory apartment in bytes to allocate DateTime type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateColumn.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial DateTime value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateColumn.#ctor(VistaDB.Engine.Core.DateColumn)">
            <summary>
            DateTime column value copy constructor
            </summary>
            <param name="col">DateTime column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DateTimeColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Date value to record buffer (as Ticks / TicksPerDay).
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Date value from record buffer (as Ticks / TicksPerDay).
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.SmallDateTimeColumn">
            <summary>
            Date column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.SmallDateTimeColumn.SmallDateTimeSize">
            <summary>
            Memory apartment in bytes to allocate Date type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallDateTimeColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallDateTimeColumn.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Date value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallDateTimeColumn.#ctor(VistaDB.Engine.Core.SmallDateTimeColumn)">
            <summary>
            Date column value copy constructor
            </summary>
            <param name="col">Date column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallDateTimeColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DateColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallDateTimeColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Date value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallDateTimeColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get DateTime value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallDateTimeColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.DateTime2Column">
            <summary>
            System.DateTime column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DateTime2Column.DT2Size">
            <summary>
            Memory apartment in bytes to allocate DateTime type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTime2Column.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTime2Column.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial DateTime value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTime2Column.#ctor(VistaDB.Engine.Core.DateTime2Column)">
            <summary>
            DateTime column value copy constructor
            </summary>
            <param name="col">DateTime column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTime2Column.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DateTimeColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTime2Column.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put DateTime2 (DateTime) value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTime2Column.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get DateTime2 (DateTime) value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTime2Column.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.DateTimeOffsetColumn">
            <summary>
            System.DateTime column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DateTimeOffsetColumn.DTOSize">
            <summary>
            Memory apartment in bytes to allocate DateTime type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeOffsetColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeOffsetColumn.#ctor(System.DateTimeOffset)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial DateTime value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeOffsetColumn.#ctor(VistaDB.Engine.Core.DateTimeOffsetColumn)">
            <summary>
            DateTime column value copy constructor
            </summary>
            <param name="col">DateTime column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeOffsetColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DateTimeColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeOffsetColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put DateTimeOffset value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeOffsetColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get DateTimeOffset value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DateTimeOffsetColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.DecimalColumn">
            <summary>
            System.Decimal column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.DecimalColumn.IntSize">
            <summary>
            Memory apartment in bytes to allocate Decimal type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.#ctor(System.Decimal)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Decimal value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.#ctor(VistaDB.Engine.Core.DecimalColumn)">
            <summary>
            DateTime column value copy constructor
            </summary>
            <param name="col">DecimalColumn instance to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.#ctor(VistaDB.VistaDBType,System.Int32)">
            <summary>
            Helper constructor to overload by fixed scale factor decimal types like currency
            </summary>
            <param name="type">Inheriting type </param>
            <param name="size">Buffer length</param>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of DecimalColumn type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Decimal value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Decimal value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.DecimalColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.MoneyColumn">
            <summary>
            Money column value. That's the same value like Decimal with fixed scale factor 4
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.MoneyColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.MoneyColumn.#ctor(System.Decimal)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Currency value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.MoneyColumn.#ctor(VistaDB.Engine.Core.MoneyColumn)">
            <summary>
            DateTime column value copy constructor
            </summary>
            <param name="column">Currency column instance to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.MoneyColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Decimal value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.MoneyColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Decimal value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallMoneyColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallMoneyColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put SmallMoney value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to current index offset in buffer</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.SmallMoneyColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get SmallMoney value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.BitColumn">
            <summary>
            System.Boolean column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.BitColumn.BooleanSize">
            <summary>
            Memory apartment in bytes to allocate boolean type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BitColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BitColumn.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial boolean value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BitColumn.#ctor(VistaDB.Engine.Core.BitColumn)">
            <summary>
            Boolean column value copy constructor
            </summary>
            <param name="col">Boolean column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BitColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Boolean4 type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put Boolean value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get Boolean value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.RealColumn">
            <summary>
            System.Single column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.RealColumn.SingleSize">
            <summary>
            Memory apartment in bytes to allocate boolean type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.RealColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.RealColumn.#ctor(System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial boolean value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RealColumn.#ctor(VistaDB.Engine.Core.RealColumn)">
            <summary>
            Single column value copy constructor
            </summary>
            <param name="col">Sinlge column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.RealColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Single column with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RealColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put float value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RealColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get float value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.RealColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.FloatColumn">
            <summary>
            System.Double column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.FloatColumn.DoubleSize">
            <summary>
            Memory apartment in bytes to allocate boolean type value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.FloatColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.FloatColumn.#ctor(System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial boolean value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.FloatColumn.#ctor(VistaDB.Engine.Core.FloatColumn)">
            <summary>
            Double column value copy constructor
            </summary>
            <param name="col">Double column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.FloatColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Double column with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.FloatColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put double value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.FloatColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get double value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.FloatColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.UniqueIdentifierColumn">
            <summary>
            Guid column value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.UniqueIdentifierColumn.GuidSize">
            <summary>
            Memory apartment in bytes to allocate boolean type value
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.UniqueIdentifierColumn.s_MinValue">
            <summary>
            cache our boxed value for dummy null and max value.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.UniqueIdentifierColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.UniqueIdentifierColumn.#ctor(System.Guid)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Guid value</param>
        </member>
        <member name="M:VistaDB.Engine.Core.UniqueIdentifierColumn.#ctor(VistaDB.Engine.Core.UniqueIdentifierColumn)">
            <summary>
            Double column value copy constructor
            </summary>
            <param name="col">Double column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.UniqueIdentifierColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Double column with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.UniqueIdentifierColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put double value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.UniqueIdentifierColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get double value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.UniqueIdentifierColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.BinaryDataColumn">
            <summary>
            Stores varying-length binary (byte array) data.  (Used as a base class to support extended types.)
            </summary>
            <remarks><para>This class (as BinaryColumn) used to be used to implement VarBinary and Binary with the behavior
            of VarBinary(65535) for both.  It is also the base class for extended column types which keep a base binary list
            of external pages.  However, as this class does not support a max length (only the hard-coded MaxArray) and
            does not support indexing (can't be declared small enough), and so on, it has been renamed to BinaryDataColumn,
            and a new BinaryColumn and VarBinaryColumn will implement those respective types.</para>
            <para>This class will also be used to implement the legacy VarBinary(65535) type in VistaDB 4 databases in order
            to support upgrade (and read-only access, if allowed).  Upgrading to VistaDB 5 should replace this type with
            VarBinary(MAX) aka IMAGE aka BlobColumn since Binary and VarBinary will have the SQL Server limit of 8000.
            </para></remarks>
        </member>
        <member name="F:VistaDB.Engine.Core.BinaryDataColumn.OldVarBinaryType">
            <summary>
            The old VistaDBType.VarBinary enum value (21) from VistaDB 4.  This type is deprecated for external use
            in VistaDB 5, replaced with new length-limited VarBinary and (zero-padded) Binary types and the previous
            Image type (now referred to as VarBinary(Max)).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryDataColumn.#ctor">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryDataColumn.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial boolean value</param>
            <remarks>This constructor</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryDataColumn.#ctor(VistaDB.Engine.Core.BinaryDataColumn)">
            <summary>
            Byte array column value copy constructor
            </summary>
            <param name="col">Boolean column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryDataColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Boolean4 type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryDataColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put byte array value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryDataColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get byte array value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryDataColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.VarBinaryColumn">
            <summary>
            Fixed array of bytes
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.#ctor">
            <summary>
            Constructor of Null value declared as SqlSizeLimit (not for use by derived types;
            use an overload taking type and maxSize)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.#ctor(System.Byte[])">
            <summary>
            Constructor for initial value declared as SqlSizeLimit (not for use by derived types;
            use an overload taking type and maxSize)
            </summary>
            <param name="val">Initial binary value</param>
            <remarks>This constructor</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.#ctor(System.Byte[],System.Int32)">
            <summary>
            Constructor for normal declaration with a value and a declared maxSize.
            </summary>
            <param name="val">Initial binary value</param>
            <param name="maxSize">The declared max size of the byte array.</param>
            <remarks>This constructor</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.#ctor(VistaDB.Engine.Core.VarBinaryColumn)">
            <summary>
            Byte array column value copy constructor
            </summary>
            <param name="col">VarBinary column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.#ctor(VistaDB.VistaDBType,System.Int32)">
            <summary>
            Derived type constructor (caller can then assign to Value if not just a null)
            </summary>
            <param name="type">The actual VistaDBType of this derived instance.</param>
            <param name="maxSize">The declared max byte array size of this instance.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Boolean4 type with same attributes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put byte array value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack</param>
            <returns>current index offset in buffer for start of any InheritedSize more data</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get byte array value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.ReadVarLength(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Read the length of the rest of this field (used by old per-column encryption).
            (Only provided for completeness; this should not be used outside of experimental internal cases.)
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="precedenceColumn"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.VarBinaryColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
            <remarks>SQL Server compares binary values without considering length.  Any difference in length is treated
            as if padded with trailing zeroes when comparing.  This includes both in max size and in variable length.  We
            will need to compare similarly, but allow for a key compare which also distinguishes on actual variable length.
            (Max size should never be different in a key compare.)</remarks>
        </member>
        <member name="P:VistaDB.Engine.Core.VarBinaryColumn.MaxBinaryValue">
            <summary>
            This magic reference represents the maximum possible Binary/VarBinary value as if it were an infinite array
            of 0xff's.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.VarBinaryColumn.ArrayLength">
            <summary>
            Gets the length of the stored array.  (For fixed-length BinaryColumn this is the unpadded array.)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.VarBinaryColumn.ValueLength">
            <summary>
            Gets the length of the byte array Value of this column.  (For fixed-length BinaryColumn this is maxSize.)
            Returns -1 if Value IsNull.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.VarBinaryColumn.Value">
            <summary>
            Get or set the byte array value.  Any array instance passed in or out belongs to the column instance and
            must not be modified.  The caller should clone any array buffer they need to reuse/modify (because most
            cases should not need to clone).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.VarBinaryColumn.MaxFill">
            <summary>
            Whether this column always fills the value to the declared maxSize (right-pads with 0's as needed).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.BinaryColumn.paddedArray">
            <summary>
            Cache for a byte array zero-padded to our maxSize for quick return from (read-only) Value property.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryColumn.#ctor">
            <summary>
            Constructor of Null value declared as maxSize of 1.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryColumn.#ctor(System.Byte[])">
            <summary>
            Constructor for initial value declared as maxSize of val.Length (or 1 if val is null).
            </summary>
            <param name="val">Initial binary value</param>
            <remarks>This constructor</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryColumn.#ctor(System.Byte[],System.Int32)">
            <summary>
            Constructor for normal declaration with a value and a declared maxSize.
            </summary>
            <param name="val">Initial binary value</param>
            <param name="maxSize">The declared max size of the byte array.</param>
            <remarks>This constructor</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryColumn.#ctor(VistaDB.Engine.Core.BinaryColumn)">
            <summary>
            Byte array column value copy constructor
            </summary>
            <param name="col">VarBinary column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryColumn.#ctor(VistaDB.VistaDBType,System.Int32)">
            <summary>
            Derived type constructor (caller can then assign to Value if not just a null)
            </summary>
            <param name="type">The actual VistaDBType of this derived instance.</param>
            <param name="maxSize">The declared max byte array size of this instance.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.BinaryColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Boolean4 type with same attributes</returns>
        </member>
        <member name="P:VistaDB.Engine.Core.BinaryColumn.MaxFill">
            <summary>
            Whether this column always fills the value to the declared maxSize (right-pads with 0's as needed).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.BinaryColumn.Value">
            <summary>
            Get or set the byte array value.  Any array instance passed in or out belongs to the column instance and
            must not be modified.  The caller should clone any array buffer they need to reuse/modify (because most
            cases should not need to clone).
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.ExtendedColumn">
            <summary>
            Variable array of bytes.
            Extended columns allocated only once at leaf level in rowset
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.ExtendedColumn.clusterLength">
            <summary>
            Number of pages to allocate by one cluster 
            to hold extended data
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.ExtendedColumn.clusterCount">
            <summary>
            Number of clusters
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.ExtendedColumn.clustersFreed">
            <summary>
            The current clusterCount clusters of clusterLength pages each have been freed (pending commit).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.ExtendedColumn.extendedValue">
            <summary>
            Actual extended value. The base value contains the 
            list of pages allocated to keep the extended value in file storage
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.ExtendedColumn.extendedBufferLength">
            <summary>
            Length of the extended data buffer put to the file storage
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.ExtendedColumn.#ctor(VistaDB.VistaDBType)">
            <summary>
            Constructor of Null value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.ExtendedColumn.#ctor(System.Object,VistaDB.VistaDBType)">
            <summary>
            Helper constructor
            </summary>
            <param name="extendedValue">Initial boolean value</param>
            <param name="type">Actual type</param>
        </member>
        <member name="M:VistaDB.Engine.Core.ExtendedColumn.#ctor(VistaDB.Engine.Core.ExtendedColumn)">
            <summary>
            Byte array column value copy constructor
            </summary>
            <param name="col">Boolean column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.ExtendedColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put byte array value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.ExtendedColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get byte array value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.TextColumn">
            <summary>
            Text column instance. The value of text is put 
            in external place. The main record buffer references it
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.TextColumn.culture">
            <summary>
            Culture information used in comparing to another character columns
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.TextColumn.caseInsensitive">
            <summary>
            Case insensitivity in comparing to another character columns
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.TextColumn.stringComparer">
            <summary>
            The culture and case-sensitivity dependent StringComparer to use when comparing this column
            or getting a hash code for its current value.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.TextColumn.encoding">
            <summary>
            Encoding to use in record buffer manipulations.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.TextColumn.#ctor(System.String,System.Int32,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Text(X) column value constructor
            </summary>
            <param name="val">String value</param>
            <param name="culture">Culture used in collation</param>
            <param name="caseInsensitive">Sensitivity used in collation</param>
            <param name="codePage">code page to encode in database file storage</param>
        </member>
        <member name="M:VistaDB.Engine.Core.TextColumn.#ctor(VistaDB.Engine.Core.TextColumn)">
            <summary>
            Char(X) column value copy constructor
            </summary>
            <param name="col">Character column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.TextColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.TextColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of Text type with same attributes</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.NTextColumn">
            <summary>
            NText column instance. The value of text is put 
            in external place. The main record buffer references it
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.NTextColumn.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,System.Int32)">
            <summary>
            NText column value constructor
            </summary>
            <param name="val">String value</param>
            <param name="culture">Colture information to use in compare operations</param>
            <param name="caseInsensitive">Use case insensitive compare operations</param>
            <param name="codePage">unicode code page</param>
        </member>
        <member name="M:VistaDB.Engine.Core.NTextColumn.#ctor(VistaDB.Engine.Core.NTextColumn)">
            <summary>
            NText column value copy constructor
            </summary>
            <param name="col">NText column to copy from</param>
        </member>
        <member name="M:VistaDB.Engine.Core.NTextColumn.OnDuplicate(System.Boolean)">
            <summary>
            Create instance copy.
            </summary>
            <returns>New instance of NText type with same attributes</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.BlobColumn">
            <summary>
            This class implements the VarBinary(MAX) or IMAGE SQL type (VistaDBType.Image).
            </summary>
            <remarks>Historically, this has been called Image type in VistaDB 4 and older, but it actually works more like
            VarBinary(MAX) and will be externally referred to as such in VistaDB 5.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.BlobColumn.ConvertToByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Put byte array value to record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BlobColumn.ConvertFromByteArray(System.Byte[],System.Int32,VistaDB.Engine.Core.Row.Column)">
            <summary>
            Get byte array value from record buffer.
            </summary>
            <param name="buffer">Current buffer</param>
            <param name="offset">Index offset</param>
            <param name="precedenceColumn">Previous column to pack in according to</param>
            <returns>current index offset in buffer</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BlobColumn.Collate(VistaDB.Engine.Core.Row.Column)">
            <summary>
            Collation to another column
            </summary>
            <param name="col">Column to compare with</param>
            <returns>Collation value</returns>
            <remarks>SQL Server compares binary values without considering length.  Any difference in length is treated
            as if padded with trailing zeroes when comparing.  This includes both in max size and in variable length.  We
            will need to compare similarly, but allow for a key compare which also distinguishes on actual variable length.
            (Max size should never be different in a key compare.)</remarks>
        </member>
        <member name="T:VistaDB.Engine.Core.UnknownColumn">
            <summary>
            Unknown type data. Always null
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.UnknownColumn.#ctor">
            <summary>
            Constructor of Null value of unknown type
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.RowExtension">
            <summary>
            The list of columns in the main row that should be kept in an external storage buffer to be length non-restricted size.
            A better way to think of this is row data that does not fit within a page - this will almost always be TEXT or BLOB data.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.RowExtension.parentRow">
            <summary>
            Position of first page in data storage to start chained pages from there
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.BitPacker">
            <summary>
            An alternative to System.BitConverter for use with odd-sized values.  (Always uses little-endian order.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.BitPacker.PackBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Pack a value into fewer than 8 bytes (ignoring high bytes) as specified by length.
            (Little-endian order)
            </summary>
            <param name="value">The raw value to encode into bytes.</param>
            <param name="buffer">The buffer to write into.</param>
            <param name="offset">The starting offset in the buffer to write at.</param>
            <param name="length">The number of significant bytes to write.</param>
            <returns>The new buffer offset after the encoding of the value.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitPacker.PackBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Pack a value into fewer than 4 bytes (ignoring high bytes) as specified by length.
            (Little-endian order)
            </summary>
            <param name="value">The raw value to encode into bytes.</param>
            <param name="buffer">The buffer to write into.</param>
            <param name="offset">The starting offset in the buffer to write at.</param>
            <param name="length">The number of significant bytes to write.</param>
            <returns>The new buffer offset after the encoding of the value.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitPacker.UnpackBytes(System.Int64@,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a value packed into fewer than 8 bytes (sign-extending high bytes) as specified by length.
            (Little-endian order)
            </summary>
            <param name="value">Outputs the value decoded from bytes.</param>
            <param name="buffer">The buffer to read from.</param>
            <param name="offset">The starting offset in the buffer to read at.</param>
            <param name="length">The number of significant bytes to read.</param>
            <returns>The new buffer offset after the encoding of the value.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitPacker.UnpackBytes(System.UInt64@,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a value packed into fewer than 8 bytes (zero-extending high bytes) as specified by length.
            (Little-endian order)
            </summary>
            <param name="value">Outputs the value decoded from bytes.</param>
            <param name="buffer">The buffer to read from.</param>
            <param name="offset">The starting offset in the buffer to read at.</param>
            <param name="length">The number of significant bytes to read.</param>
            <returns>The new buffer offset after the encoding of the value.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitPacker.UnpackBytes(System.Int32@,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a value packed into fewer than 4 bytes (sign-extending high bytes) as specified by length.
            (Little-endian order)
            </summary>
            <param name="value">Outputs the value decoded from bytes.</param>
            <param name="buffer">The buffer to read from.</param>
            <param name="offset">The starting offset in the buffer to read at.</param>
            <param name="length">The number of significant bytes to read.</param>
            <returns>The new buffer offset after the encoding of the value.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.BitPacker.UnpackBytes(System.UInt32@,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a value packed into fewer than 4 bytes (zero-extending high bytes) as specified by length.
            (Little-endian order)
            </summary>
            <param name="value">Outputs the value decoded from bytes.</param>
            <param name="buffer">The buffer to read from.</param>
            <param name="offset">The starting offset in the buffer to read at.</param>
            <param name="length">The number of significant bytes to read.</param>
            <returns>The new buffer offset after the encoding of the value.</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.TemporaryRowset">
            <summary>
            Temporary rowset. Collects inserted or deleted rows to use by triggers.
            Support same structure like any other table, but do not flush memory to the disk.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.RowsetIndex">
            <summary>
            Individual table index to order recordset by composite key
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.RowsetIndex.rowSet">
            <summary>
            Rowset data storage this index relies on
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.RowsetIndex.spool">
            <summary>
            Sorting spool
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.RowsetIndex.buildingStatus">
            <summary>
            It is to be true value when the index is being built/re-built
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.RowsetIndex.keyPcode">
            <summary>
            Evaluating p-code for index key expression
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.RowsetIndex.OnPartialKeyFound(VistaDB.Engine.Core.Row)">
            <summary>
            The method looks at column list contained in the row
            and decides are these columns being included into the left part 
            of index key and are they same values in Current row
            </summary>
            <param name="patternRow">The key row to look for</param>
            <returns></returns>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.FTSIndex">
            <summary>
            Special index to tokenize and collect words in text columns in according to fts key
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.FTSIndex.SynchFtsLists">
            <summary>
            Compare keys to insert and delete
            </summary>
            <returns>Need to update index status</returns>
        </member>
        <member name="T:VistaDB.Engine.Internal.IWordBreaker">
            <summary>
            Performs linguistic analysis to find out word boundaries and to confirm, 
            that the found word may be included into the full text index
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.IWordBreaker.IsWordBreaker(System.String,System.Int32)">
            <summary>
            Check if character symbol is word breaker
            </summary>
            <param name="s">String to check</param>
            <param name="position">Character position to check</param>
            <returns>True when char at specified position couldn't be part of word. For example, it is space or punctuation mark</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.IWordBreaker.IsStopWord(System.String)">
            <summary>
            Check if the word shouldn't be included into full text index. For example 'a', 'the', 'am' etc.
            </summary>
            <param name="word">The word to check</param>
            <returns>True if the input word is recognized as stop-word</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.FTSIndex.WordAnalyzer.StopWords">
            <summary>
            Stop words dictionary
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.FTSIndex.FtsKeys.CreateEntry(VistaDB.Engine.Core.Row,System.String,System.Int32,System.Int32)">
            <summary>
            Create a new entry for the FullTextSearch Index from this data
            </summary>
            <param name="evaluatedRow"></param>
            <param name="token"></param>
            <param name="columnOrder"></param>
            <param name="occurence"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.FTSIndex.FtsKeys.ParseKeys(VistaDB.Engine.Core.Row)">
            <summary>
            Tokenize evaluation result
            </summary>
            <param name="evaluatedRow">The result of evaluation on table row</param>
            <returns>False signals about nothing to adjust in the list</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Scripting.SignatureList.Add(VistaDB.Engine.Core.Scripting.Signature)">
            <summary>
            We add an explicitly hidden method here because we need to know the index at which these objects were added for other routines
            </summary>
            <param name="item">Signature object to add</param>
            <returns>Index of the newly added item (will always be the end of the list, no reason to sort)</returns>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.Band">
            <summary>
            The accumulator apartment to pick up part of keys and manage them through temporary file.
            The key set on the band is filled out by sorted keys.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.BandManager">
            <summary>
            List of sorted bands.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.SortSpool">
            <summary>
            Sorting collection
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.SortSpool.CheckForMono">
            <summary>
            Check whether we are running in a Mono runtime environment rather than a normal .NET CLR.
            </summary>
            <returns>True if running in Mono.  False if .NET CLR.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.SortSpool.EstimateMemory">
            <summary>
            Helper method to estimate available system physical memory
            to set spool length accordingly and possibly force the using external sorting
            </summary>
            <returns>RAM available in bytes</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.SortSpool.#ctor(System.Boolean,System.UInt32,System.Int32@,VistaDB.Engine.Core.Row,VistaDB.Engine.Core.IO.StorageManager,VistaDB.Engine.Core.Cryptography.EncryptionKey,System.Boolean)">
            <summary>
            Provides two sorting methods -- quick sort or external sorting by merging.
            <list type="Internal sorting through quick sorting algorithm made in memory">
            It is considered to be used when all keys would be allocated in physical memory.
            </list>
            <list type="Sorting with using external files">
            It is considered to be used when all keys would not be allocated in physical memory.
            </list>
            </summary>
            <param name="isolatedStorage"></param>
            <param name="keyCount">maximum key count will be put to the spool</param>
            <param name="expectedKeyLen">estimation for expected key length (main row part)</param>
            <param name="patternKey">pattern key to check available memory resources in order to sort effectively</param>
            <param name="fileManager">connection correspondent file manager</param>
            <param name="encryptionKey">the block-encryption key to encrypt spool files, or null for non-encrypted</param>
            <param name="forceQuickSorting"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.SortSpool.MultiPhaseMergingSorting">
            <summary>
            Multi-Phase Merging (external sorting algorithm)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.SortSpool.QuickSorting">
            <summary>
            Quick sorting algorithm
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.Indexing.SortSpool.IsMonoRuntime">
            <summary>
            Inidicates if the process is running under the Mono runtime or the full .NET CLR.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.IO.CacheSystem">
            <summary>
            Cache system to cache pages from disk
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.CreateNewPage(System.UInt64,System.UInt64)">
            <summary>
            Create a new Page instance for an existing page to be read from the database file.
            </summary>
            <param name="storageId">The storageId the page is associated with.</param>
            <param name="pageId">The pageId of the page to read.</param>
            <returns>A new Page instance to read from.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.OpenNewPage(System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Open a new Page instance for a new page to be written to the database file.
            </summary>
            <param name="storageId">The storageId the page is associated with.</param>
            <param name="pageId">The pageId of the page to write.</param>
            <param name="forceRead">True to force the page to be read from the file.  False if pre-reading is not needed.</param>
            <returns>A new Page instance to write to.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.FindPage(System.UInt64)">
            <summary>
            Find an existing Page instance from the cache for reading or writing. (returns null if not found)
            </summary>
            <param name="pageId"></param>
            <returns>The existing Page instance from the cache, or null if not found.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.OnHandleDataIO(System.UInt64,System.Byte[],System.Int32,System.UInt64,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Handle Data I/O through the cache.
            </summary>
            <param name="storageId">The storageId this data is associated with.</param>
            <param name="data">The data buffer.</param>
            <param name="offset">The starting offset in the data buffer.</param>
            <param name="filePosition">The starting filePosition for the I/O.  May or may not be aligned to a page boundary.</param>
            <param name="length">The length of the requested operation upon the data buffer.  Underlying I/O may or may not
            exceed this (ie. reading an entire page into the cache) but only this length will be copied from or to the data
            buffer.</param>
            <param name="toRead">True for read operations.  False for write operations.</param>
            <param name="forceRead"><para>For a read operation:  True to force a read from the file even upon a cache hit.
            False if read may use cached data.  A cache miss will always read entire page from the file.  A "dirty" (modified)
            cache page will skip reading from the file.</para>
            <para>For a write operation:  True if writing to an existing page (may or may not be present in cache) which may
            need to be read from the file to complete a cache page for a partial write (less than the entire page).
            False if this is a newly-allocated page and does not need to read from the file even for a partial write.
            A full-page write will skip a forced read.</para></param>
            <returns>The length of the data operation. (currently just returns the original length parameter value)</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.DirtyPage(VistaDB.Engine.Core.IO.CacheSystem.Page)">
            <summary>
            Register a Page instance that has become dirty (has unsaved modified data).
            </summary>
            <param name="page"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.FreshPage(VistaDB.Engine.Core.IO.CacheSystem.Page)">
            <summary>
            Unregister a Page instance that is no longer dirty (has been saved to disk or refreshed from disk).
            </summary>
            <param name="page"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.RemovePage(System.UInt64)">
            <summary>
            Entirely remove a Page from the cache without flushing it.
            </summary>
            <param name="pageId">The PageId to remove.</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.Flush">
            <summary>
            Flush all dirty pages to disk and remove them from the base dictionary.  Free any extent pages pending release.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.ClearAssociativeButHeader(System.UInt64)">
            <summary>
            Clear all of the buffers for this storage ID when not IsDirty, EXCEPT the root node of the storageId.
            (OBSOLETE, now self-pruning, and only dirty pages are kept by hard reference)
            </summary>
            <param name="storageId"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.ClearAssociative(System.UInt64)">
            <summary>
            Clear all pages associated with a particular storageId (including header) without flushing them.  Caller should
            also clear any extent pages pending release that are associated with the storageId (NOT freeing them).
            </summary>
            <param name="storageId"></param>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.CacheSystem.Page.pageId">
            <summary>
            Position of this page in the file
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.CacheSystem.Page.storageId">
            <summary>
            Associated logical storage that uses this page
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.CacheSystem.Page.isDirty">
            <summary>
            Does this page need to be flushed (is it dirty)?
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.CacheSystem.Page.buffer">
            <summary>
            Byte buffer to keep read/write page information
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.CacheSystem.Page.pageEndHash">
            <summary>
            Stores the last 16 bytes of the page on disk (if block-encryption is active) to compare for underlying changes.
            (null if block-encryption is not active.)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.CacheSystem.Page.cache">
            <summary>
            The CacheSystem instance which contains this Page instance.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.Page.Refresh(VistaDB.Engine.Core.IO.StorageHandle,System.Boolean,System.Int32)">
            <summary>
            Refresh from the filestream.  Is this for a read operation, and what length is the buffer?
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.Page.IsNewPageVersion">
            <summary>
            Test if this page version have been updated and if the new version is existing in the file
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.Page.CheckPageHash(System.Boolean,System.Boolean)">
            <summary>
            Compares the end of the page on disk (if block-encryption is active) to the value stored from the last refresh,
            and returns whether to read from disk to refresh from underlying changes.
            </summary>
            <param name="forceRead"></param>
            <param name="toRead"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.CacheSystem.Page.UpdatePageHash(System.Byte[],System.Int32)">
            <summary>
            Update the cached pageEndHash value with the end of the (block-encrypted) page on disk
            to detect future changes.
            </summary>
            <param name="fileBuffer"></param>
            <param name="length"></param>
        </member>
        <member name="P:VistaDB.Engine.Core.IO.CacheSystem.Page.IsDirty">
            <summary>
            Is this page dirty?  We need to flush it to the disk (not just release it)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.WeakReferenceCache`2">
            <summary>
            This generic collection caches values in a Dictionary using weak references to
            provide dynamic sizing that works well the garbage collector.  It does this in a way that
            guarentees the most recently accessed entries won't be garbage collected.
            </summary>
            <typeparam name="TKey">An IEquatable value used as the Dictionary key</typeparam>
            <typeparam name="TValue">A reference type to be stored as the target of a weak reference</typeparam>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.#ctor(System.Int32)">
            <summary>
            Create a cache specifying the initial capacity.
            </summary>
            <param name="capacity">The capacity parameter also influences packing behavior</param>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a cache specifying the initial capacity and equlity comparer.
            </summary>
            <param name="capacity">The capacity parameter also influences packing behavior</param>
            <param name="comparer">Implementation to use when comparing keys</param>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.AddToWeakCache(`0,`1)">
            <summary>
            Add an entry to the WeakReference cache without modifying the most-recent list.
            </summary>
            <param name="key"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.Remove(`0)">
            <summary>
            Remove the entry for a specified key from the cache if it exists.
            </summary>
            <param name="key">The key of the entry to remove.</param>
            <returns>True if an entry was removed, false if the key did not exist.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.GetMostRecentList">
            <summary>
            Get a snapshot List of TValues from the most-recently-used list (which can then be enumerated, etc).
            </summary>
            <returns>A List&lt;TValue&gt; of values from the queue, in order.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.GetMostRecentList(System.Boolean)">
            <summary>
            Get a snapshot List of TValues from the most-recentoy-used list (which can then be enumerated, etc).
            </summary>
            <param name="reversed">False for most-recent-first, True for most-recent last.</param>
            <returns>A List&lt;TValue&gt; of values from the queue, in order (or, optionally, reversed order).</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.EnumerateMostRecent">
            <summary>
            Get an enumerator for the most-recently-used list of TValues.
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; to enumerate the most-recently-used list of TValues.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.EnumerateEntireCache">
            <summary>
            Get an enumerator for the entire cache of TValues (in no particular order).
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; to enumerate the entire cache of TValues.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.GetLeastRecentValue">
            <summary>
            Get the TValue in danger of being dropped from the most-recently-used list (null if below capacity).
            </summary>
            <returns>A TValue which could be dropped from the MRU list if a new value is added.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.Clear">
            <summary>
            Resets the cache clearing all entries and restoring it to its initial capacity
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.Pack(System.Boolean)">
            <summary>
            Pack the cache if it contains too many dead entries
            </summary>
            <param name="forcePack">Force all dead entries to be removed from the cache</param>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.FetchValue(`0)">
            <summary>
            This virtual method can be overridder by a subclass to resolve a cache fault by
            fetching a value into the cache when requested but not available
            </summary>
            <param name="key">Key associated with the desired value</param>
            <returns>TValue for requested TKey or null if not available</returns>
        </member>
        <member name="P:VistaDB.Engine.Internal.WeakReferenceCache`2.Item(`0)">
            <summary>
            Indexer property to add or retrieve values from the cache
            </summary>
            <param name="key">Key to be used to lookup or store a value</param>
            <returns>Returns a TValue if found, otherwise null</returns>
        </member>
        <member name="P:VistaDB.Engine.Internal.WeakReferenceCache`2.CacheCount">
            <summary>
            Returns the number of entries in the underlying Dictionary (including dead weak references)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Internal.WeakReferenceCache`2.QueueCount">
            <summary>
            Returns the number of entries in the least-recently used (LRU) queue
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Internal.WeakReferenceCache`2.LiveReferenceCount">
            <summary>
            Returns the number of live weak references in the cache
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.WeakReferenceCache`2.CacheNode`1">
            <summary>
            Wrapper object used as the value for the internal Dictionary used by WeakReferenceCache.
            Each CacheNode holds a WeakReference to the actual TValue of interest plus a strong
            reference to the node in an LRUQueue representing recently accessed values.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1">
            <summary>
            A least-recently used (LRU) queue of cache values. Each node in the queue will
            hold a strong reference to a recently accessed TValue thus ensuring that value
            won't be garbage collected.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1.GetFirst">
            <summary>
            Gets the first TValue in the queue.
            </summary>
            <returns>The first TValue in the queue.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1.GetLast">
            <summary>
            Gets the last TValue in the queue.
            </summary>
            <returns>The last TValue in the queue.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1.AddToFront(`2)">
            <summary>
            Relocate a node to the front of the queue.
            This method is called when a cache value is referenced
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1.MoveToFront(VistaDB.Engine.Internal.WeakReferenceCache{`0,`1}.LRUNode{`2})">
            <summary>
            Move a node to the head of the queue
            </summary>
            <param name="node">Node to be moved (MUST already be linked into this queue!)</param>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1.RemoveFromBack">
            <summary>
            Removes the last node from the queue. This method is called automatically when a new node
            is added to the queue that would cause it to exceed it's capacity.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1.GetValues">
            <summary>
            Get a snapshot List of TValues from the queue (which can then be enumerated, etc).
            </summary>
            <returns>A List&lt;TValue&gt; of values from the queue, in order.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUQueue`1.GetValues(System.Boolean)">
            <summary>
            Get a snapshot List of TValues from the queue (which can then be enumerated, etc).
            </summary>
            <param name="reversed">False for most-recent-first, True for most-recent last.</param>
            <returns>A List&lt;TValue&gt; of values from the queue, in order (or, optionally, reversed order).</returns>
        </member>
        <member name="T:VistaDB.Engine.Internal.WeakReferenceCache`2.LRUNode`1">
            <summary>
            A single node with an LRUQueue used in conjunction with a WeakReferenceCache
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList">
            <summary>
            An updatable list of up to N most-recently-used (MRU) TValues.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.GetFirst">
            <summary>
            Gets the first TValue in the list.
            </summary>
            <returns>The first TValue in the list.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.GetLast">
            <summary>
            Gets the last TValue in the list.
            </summary>
            <returns>The last TValue in the list.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.AddToFront(`1)">
            <summary>
            Add a new TValue to (the top of) the list because it has just been "used".
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.MoveToFront(System.Collections.Generic.LinkedListNode{`1})">
            <summary>
            Move a listed TValue's node to the top of the list because it has just been "used".
            </summary>
            <param name="node">Node to be moved (must not currently be linked in a different list).</param>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.RemoveFromBack">
            <summary>
            Removes the last node from the list. This method is called automatically when a new node
            is added to the queue that would cause it to exceed it's capacity.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.Remove(System.Collections.Generic.LinkedListNode{`1})">
            <summary>
            Removes a specific node from the list.  The containing LinkedListNode&lt;TValue&gt; must be provided.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.GetValues">
            <summary>
            Get a snapshot List of TValues from the queue (which can then be enumerated, etc).
            </summary>
            <returns>A List&lt;TValue&gt; of values from the queue, in order.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.WeakReferenceCache`2.MruList.GetValues(System.Boolean)">
            <summary>
            Get a snapshot List of TValues from the queue (which can then be enumerated, etc).
            </summary>
            <param name="reversed">False for most-recent-first, True for most-recent last.</param>
            <returns>A List&lt;TValue&gt; of values from the queue, in order (or, optionally, reversed order).</returns>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.fileStream">
            <summary>
            File stream this StorageHandle manages
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.storageMode">
            <summary>
            File opening and access mode modes
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.lockTables">
            <summary>
            List of locks applied immediately to file storage
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.instanceCount">
            <summary>
            Number of instances that use this StorageHandle
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.ReadAndDecryptPage(System.Int64)">
            <summary>
            Read an entire page (of pageSize) at the specified position (pageId) into our decryptedBuffer and set
            the bufferedPageId to indicate the page it holds.  (Using encryptedBuffer and decrypting if necessary.)
            </summary>
            <param name="pageId">The pageId of the page to read.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.EncryptAndWritePage(System.Int64)">
            <summary>
            Write an entire page (of pageSize) at the specified position (pageId) from our decryptedBuffer if
            it currently holds the same bufferedPageId.  (Using encyrptedBuffer and encrypting if necessary.)
            </summary>
            <param name="pageId">The pageId of the page to write.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.CheckPageHashChanged(System.UInt64,System.Byte[])">
            <summary>
            Compare the end of an encrypted page on disk against the last known value and report whether it has changed.
            </summary>
            <param name="pageId">The pageId to test.</param>
            <param name="pageEndHash">The buffer holding the last known value for the end of the encrypted page on disk.</param>
            <returns>True if the underlying page has changed (or can't be determined).  False if the pageEndhash matches.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.GetFreeCluster(System.Int32,System.Int32)">
            <summary>
            Allocate a contiguous cluster of pages of a required pageCount in size if any have been freed.
            </summary>
            <param name="pageCount">Length of cluster</param>
            <param name="storagePageSize">Page size (in bytes)</param>
            <returns>Position of allocated free cluster</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.SetFreeCluster(System.UInt64,System.Int32)">
            <summary>
            Release a cluster of contiguous pages to be immediately deallocated for reuse.  (BUG-PRONE old behavior)
            </summary>
            <param name="position"></param>
            <param name="pageCount"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.PendingFreeCluster(System.UInt64,System.UInt64,System.Int32)">
            <summary>
            Release a cluster of contiguous pages to be deallocated for reuse, pending a commit of all writes.
            </summary>
            <param name="storageId">The storageId the cluster was allocated to.</param>
            <param name="position">The position (pageId) of the cluster in the file.</param>
            <param name="pageCount">The count of pages in the cluster.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.WriteRow(VistaDB.Engine.Core.DataStorage,VistaDB.Engine.Core.Row,System.Int32)">
            <summary>
            Writes main row buffer to the cache
            </summary>
            <param name="storage">The storage to write into</param>
            <param name="row">The row to write into data storage</param>
            <param name="length">The length of buffer to write</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.ReadRow(VistaDB.Engine.Core.DataStorage,VistaDB.Engine.Core.Row,System.Int32,System.Boolean)">
            <summary>
            Reads main row buffer from the cache
            </summary>
            <param name="storage">Parent storage</param>
            <param name="row">Row instance</param>
            <param name="length">Length to read in row buffer</param>
            <param name="force">Force reading form the file</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.ReadWithEncryption(System.UInt64,System.Byte[],System.Int32,System.Int32,VistaDB.Engine.Core.IO.CacheSystem.Page)">
            <summary>
            Read a page from the database file (decrypting if necessary) and copy from specified offset
            for specified length into provided buffer.
            </summary>
            <param name="position">The position in the database file to read from.</param>
            <param name="buffer">The buffer to copy (decrypted) data into.</param>
            <param name="offset">The offset in the buffer to start copying at.</param>
            <param name="length">The length of data to read (stops early if buffer runs out).</param>
            <param name="cachePage">The cachePage (if any), or null.</param>
            <returns>The length of data actually read and copied.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.WriteWithEncryption(System.UInt64,System.Byte[],System.Int32,System.Int32,VistaDB.Engine.Core.IO.CacheSystem.Page)">
            <summary>
            Write a page to the database file (encrypting if necessary) copied from specified offset
            for specified length from provided buffer.
            </summary>
            <param name="position">The position in the database file to write at.</param>
            <param name="buffer">The buffer to copy (decrypted) data from.</param>
            <param name="offset">The offset in the buffer to start copying from.</param>
            <param name="length">The length of data to write (stops early if buffer runs out).</param>
            <param name="cachePage">The cachePage (if any), or null.</param>
            <returns>The length of data actually copied and written.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.DirectSeek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Directly set position in file stream
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.DirectWriteBuffer(System.Byte[],System.Int32)">
            <summary>
            Writes byte buffer directly to the file
            </summary>
            <param name="buffer">The buffer to write from</param>
            <param name="length">The length of buffer to write</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.DirectReadBuffer(System.Byte[],System.Int32)">
            <summary>
            Reads byte buffer directly from the file
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.FlushCache">
            <summary>
            Commit all pending writes in the page cache and release all pending free clusters for possible reallocation.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.ClearWholeCacheButHeader(System.UInt64)">
            <summary>
            Clears the cached pages associated with the logical storage in memory minimize operations
            </summary>
            <param name="storageId"></param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.ClearWholeCache(System.UInt64,System.Boolean)">
            <summary>
            Clears the cached pages associated with the logical storage in rollback operations.
            Also clears any extent pages pending release that are associated with the storageId (NOT freeing them).
            </summary>
            <param name="storageId">The storageId whose dirty cache pages to drop (without flushing).</param>
            <param name="rollbackStorage">True to rollback pending release of clusters for this storageId. (Ignored; Always will?)</param>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.StorageMode.transacted">
            <summary>
            Write information will be cached (write-behind mode) 
            until all logical changes collected and committed to file
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.StorageMode.deleteOnClose">
            <summary>
            Signals to delete the file on closing
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.StorageMode.deleteOnCloseBySystem">
            <summary>
            Signals the DeleteOnClose flag is assigned to the OS FileOptions
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.IO.StorageHandle.StorageMode.CreationStatus">
            <summary>
            Helper to check correct creation mode status
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.IO.StorageHandle.StorageMode.OpeningStatus">
            <summary>
            Helper to check correct opening mode status
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.IO.StorageHandle.StreamLocksDictionary">
            <summary>
            The Dictionary of Stream Locks. It is used to keep separate lock lists for every physical table. 
            Several logical table instances use same object shared.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.IO.StorageHandle.StreamLocksDictionary.Item(System.UInt64)">
            <summary>
            Intentional data hiding here - We want a behavior where we add it if it does not exist
            </summary>
            <param name="storageId"></param>
            <returns></returns>
        </member>
        <member name="T:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache">
            <summary>
            Tracks clusters of pages available to be reallocated (and those pending release) for a given StorageHandle (file)
            to reduce the need to grow the file.  (Tracking is lost when StorageHandle is released (ie. closed).)
            EXPECTS EXTERNAL LOCKING for threadsafety.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.sizedClusters">
            <summary>
            The collection of available clusters.  Organized by pageCount.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.pending">
            <summary>
            The collection of clusters pending final release (or rollback).  Organized by StorageId.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.freeClusters">
            <summary>
            The full collection of free clusters (not pending) by position (pageId).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.pendingCount">
            <summary>
            A count of the total number of currently pending clusters.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.pendingCountHighWaterMark">
            <summary>
            The highest value pendingCount has reached.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.Clear">
            <summary>
            Discard all free cluster information.  (Rollback all pending releases and forget freed clusters.)
            EG. used when a new storage file is being opened.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.RollbackRelease(System.UInt64)">
            <summary>
            Rollback pending deallocations for a specified storageId, dropping them from the pending set and leaving
            them allocated to that storageId.
            </summary>
            <param name="storageId">The storageId being rolled back.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.CommitRelease">
            <summary>
            Commit pending deallocations for all storageId's, releasing them to be reallocated.
            </summary>
            <returns>An array of released Clusters to be purged from the pageCache.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.GetCluster(System.Int32)">
            <summary>
            Allocate an available cluster of a required pageCount in size, if any have been freed.
            </summary>
            <param name="pageCount">The count of contiguous pages required for the cluster.</param>
            <returns>Row.EmptyReference if none available with that pageCount</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.PutCluster(System.UInt64,System.UInt64,System.Int32)">
            <summary>
            Release a cluster from a particular storageId to be deallocated and reused,
            pending a commit of all pending writes.
            </summary>
            <param name="storageId">The storageId from which the cluster is being released (in case of rollback).</param>
            <param name="position">The position (pageId) of the cluster in the file.</param>
            <param name="pageCount">The count of contiguous pages in the cluster (typically 1).</param>
        </member>
        <member name="M:VistaDB.Engine.Core.IO.StorageHandle.FreeSpaceCache.PutCluster(System.UInt64,System.Int32)">
            <summary>
            Release a cluster immediately to be deallocated and reused.  (BUG-PRONE old behavior.)
            </summary>
            <param name="position">The position (pageId) of the cluster in the file.</param>
            <param name="pageCount">The count of contiguous pages in the cluster (typically 1).</param>
        </member>
        <member name="T:VistaDB.Engine.Core.IO.StorageManager">
            <summary>
            Manager of storage handles
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.TemporaryTable">
            <summary>
            Row orders collection. Table may contain several 
            different row orders including the primary and the 
            original order
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.TransactionLogRowset.IsTransactionLogged">
            <summary>
            Is this current data storage object being transaction logged?  
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Core.TransactionLogRowset.SnapshotIsolationLevel">
            <summary>
            Workaround for Net1.1
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Tree.ModifiedNode(VistaDB.Engine.Core.Indexing.Node)">
            <summary>
            Register a Node that has been modified so that it will be found when the tree is flushed.
            </summary>
            <param name="node">The Node that has been modified.</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Tree.FlushTree">
            <summary>
            Flush modified nodes (if any) back to disk.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Tree.MinimizeTreeMemory(System.Boolean)">
            <summary>
            Keep unflushed modified nodes from getting too numerous and using too much memory.  (The NodeCache will
            automatically allow GC of non-modified nodes.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Tree.GoKey(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Indexing.Node)">
            <summary>
            Binary search the node containing the key
            </summary>
            <param name="key">The key to seek</param>
            <param name="lowestNode">the level and seek in by going from root</param>
            <returns>Node the found key is placed to</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Tree.FindNextGoodLeafNode(VistaDB.Engine.Core.Indexing.Node)">
            <summary>
            Find the next leaf node after the currentNode by going up to the parent and coming back down, skipping any
            bad nodes (for RepairMode only). (EXPERIMENTAL)
            </summary>
            <param name="currentNode">The current Node we are trying to move next from.</param>
            <returns>The next good leaf node, or null if none could be found.</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Tree.SplitNode(VistaDB.Engine.Core.Indexing.Node)">
            <summary>
            Split current node, create new left node and inserts it into respective tree level,
            then insert parent reference to the new node at upper level
            </summary>
            <param name="node">node to split</param>
        </member>
        <member name="T:VistaDB.Engine.Core.Indexing.Node">
            <summary>
            General index tree node
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.minKeyCount">
            <summary>
            Minimum number of keys on the node 
            to keep extra length buffer in order not to split 
            but extend the node
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.data">
            <summary>
            Node header. It collects run-time information about keys 
            placed at the node and the way they are packed
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.level">
            <summary>
            Index tree level. This value used in index creation
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.previousAppend">
            <summary>
            The cached appended key. This key has been appended before current one appending
            while the index is created
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.appendedLength">
            <summary>
            used in indexing
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.precedenceKey">
            <summary>
            used in indexing
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Node.GoNodeKey(VistaDB.Engine.Core.Row)">
            <summary>
            Find out closest key with binary search.
            </summary>
            <param name="key">key to look for</param>
            <returns>Index key position to look for child node. 
            When the key to  look for is greater or equal to existed key it 
            just returns current index, otherwise left index 
            ( but not less of zero ).</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Node.PropagateNode(VistaDB.Engine.Core.Row,VistaDB.Engine.Core.Row)">
            <summary>
            Set key reference to the child node at parent node
            </summary>
            <param name="oldKey">Old first key at child node</param>
            <param name="newKey">New first key at child node</param>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Node.DeleteKey(System.Int32)">
            <summary>
            Delete the key on the node by its index 
            and sets current index key to the next before deleting position
            </summary>
            <param name="index">Index of key to delete</param>
            <returns>The node containing next key</returns>
        </member>
        <member name="M:VistaDB.Engine.Core.Indexing.Node.Flush(System.Boolean)">
            <summary>
            write modified index tree information to the file cache
            </summary>
            <param name="initBars">resets key buffers data reallocation with byte[] copy operation</param>
            <returns>split status</returns>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.KeyPosition.Less">
            <summary>
            the key stays in the middle of the node, 
            but actually position is less of current key
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.KeyPosition.OnLeft">
            <summary>
            the key position is in front of index node
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.KeyPosition.OnRight">
            <summary>
            the key position is behind of index node
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Core.Indexing.Node.KeyPosition.Equal">
            <summary>
            the key position coincides with current node key
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Core.VistaDBLicenseException">
            <summary>
            This is a base class for any new license Exception types we define and for generic exceptions
            generated in Licensing.
            </summary>
            <remarks>Any generation of an ApplicationException in Licensing should probably use this class instead.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.VistaDBLicenseException.#ctor">
            <summary>
            Initializes a new instance of the GibraltarLicenseException class.
            </summary>
            <remarks>This contructor initializes the Message property of the new instance to a system-supplied
            message that describes the error and takes into account the current system culture.
            For more information, see the base constructor in Exception.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.VistaDBLicenseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the GibraltarLicenseException class with a specified error message.
            </summary>
            <param name="message">The error message string.</param>
            <remarks>This constructor initializes the Message property of the new instance using the
            message parameter.  The InnerException property is left as a null reference.
            For more information, see the base contructor in Exception.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.VistaDBLicenseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the GibraltarLicenseException class with a specified error message
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message string.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a
            null reference if no inner exception is specified.</param>
            <remarks>An exception that is thrown as a direct result of a previous exception should include
            a reference to the previous exception in the innerException parameter.
            For more information, see the base constructor in Exception.</remarks>
        </member>
        <member name="M:VistaDB.Engine.Core.VistaDBLicenseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the GibraltarLicenseException class with serialized data.
            </summary>
            <param name="info">The SerializationInfo that holds the serialized object data about
            the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about
            the source or destination.</param>
            <remarks>This constructor is called during deserialization to reconstitute the exception object
            transmitted over a stream.  For more information, see the base contructor in Exception.</remarks>
        </member>
        <member name="T:VistaDB.Engine.Internal.IQueryStatement">
            <summary>
            SQL query interface
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.CreateIndexStatement.ParseWithOptions(VistaDB.Engine.SQL.SQLParser)">
            <summary>
            Parse the optional WITH ( options... ) generated for SQL Server scripts.  We just ignore the contents.
            </summary>
            <param name="parser"></param>
        </member>
        <member name="T:VistaDB.Engine.SQL.SourceTable">
            <summary>
            A base class for all SourceTable rowsets.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.IRowSet">
            <summary>
            An interface for any type of rowset.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.Next(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Advance this IRowSet to next possible row matchup (considering constraints) given current row of
            any preceding tables and synchronize any following tables.
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc)</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.ExecuteRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Clear RowUpdated flag and consider current row matchup for this IRowSet and advance to next possible row
            (considering constraints) if necessary.
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc).</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.Prepare">
            <summary>
            Prepare this IRowSet and determine its schema.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.Optimize(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Optimize any ON clauses of a JOINed RowSet (recursively) into the constraints collection.
            </summary>
            <param name="constraintOperations">The constraints collection being formed.</param>
            <returns>True if able to optimize all JOINs into the collection.  False if some could not optimize. (?)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.RegisterOuterRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Mark that this IRowSet is part of an "outer" RowSet and must register every SourceTable within it as an "outer"
            SourceTable with the ConstraintOperations collection to ensure correct optimization results.
            </summary>
            <param name="constraintOperations">The constraints collection formed for the query which this IRowSet is within.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.GetMaxTableOrder">
            <summary>
            Recursively determine the MaxTableOrder for all Signatures within this rowset and register any external column
            references with their appropriate parent (SELECT) statement.
            </summary>
            <returns>The max table order value for this rowset within its immediate parent query statement
            (not counting external column references to any further outer parent statement).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.MarkRowNotAvailable">
            <summary>
            Mark all columns within this IRowSet as a null row (in an encapsulating OUTER JOIN).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.IRowSet.PrepareTables(VistaDB.DDA.IVistaDBTableNameCollection,VistaDB.Engine.Internal.IViewList,VistaDB.Engine.SQL.TableCollection,System.Boolean,System.Int32@)">
            <summary>
            Recursively Prepare all tables within this JOINed rowset.
            </summary>
            <param name="tableNames">The collection of all table names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="views">The collection of all view names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="tableList">Collection of all source tables in this SELECT (etc).  (?)</param>
            <param name="alwaysAllowNull">True if all columns of this JOINed rowset allow NULL in the output schema due to
            an enclosing OUTER JOIN.</param>
            <param name="tableIndex">Reference to the index of the first (left-most) table in this JOINed rowset within the
            tableList collection, and of the next table after this JOINed rowset upon return.</param>
            <returns>This Join instance</returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.IRowSet.RowUpdated">
            <summary>
            Get whether this IRowSet has changed to a new overall row that has not yet been executed.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.IRowSet.RowAvailable">
            <summary>
            Get whether this IRowSet has a row available.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.IRowSet.OuterRow">
            <summary>
            Get whether this IRowSet is currently a NULL row (in an encapsulating OUTER JOIN ?).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.SourceTable.stopNext">
            <summary>
            Used by Delete functionality to stop extra Next row movement that is actually done by Core with delete operations
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.SourceTable.rowUpdated">
            <summary>
            Signals about row updated status
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.SourceTable.rowAvailable">
            <summary>
            Signals about row data acceptable status
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.SourceTable.notEmpty">
            <summary>
            Signals about recordset is not empty. 
            It is used to mark empty recordset in optimization in order not to touch actual table
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.CreateSourceTableByName(VistaDB.DDA.IVistaDBTableNameCollection,VistaDB.Engine.Internal.IViewList)">
            <summary>
            Create the appropriate BaseViewSourceTable if this SourceTable is a view rather than a table
            (otherwise just returns this SourceTable). (Error if table name is not a valid table or view.)
            </summary>
            <param name="tableNames">The collection of table names to check in, or null to check among all tables
            in the Database.</param>
            <param name="views">The collection of view names to check in, or null to check among all views in the Database.</param>
            <returns>This SourceTable (eg. NativeSourceTable) or a BaseViewSourceTable representing a named view.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.DoOpenExternalRelationships(System.Boolean,System.Boolean)">
            <summary>
            Open all tables related with current implicitly or explicitly
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.SyncNextTables(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Synchronize any following table (reset to First, optimized considering constraints) for our new row position.
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc).</param>
            <returns>False if following table(s) failed to find any possible First row (considering constraints).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.First(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Reset position to First row (considering constraints) of this SourceTable.
            (Reset optimization and activate optimized filter for this SourceTable.)
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc).</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.SetJoinOptimizationColumns(VistaDB.Engine.SQL.Signatures.ColumnSignature,VistaDB.Engine.SQL.Signatures.ColumnSignature,System.String,System.Boolean)">
            <summary>
            Set optimized (optionally cached) columns compared by equality in a JOIN's ON clause.
            </summary>
            <param name="leftColumn">The column referenced on the left side of the equality compare.</param>
            <param name="rightColumn">The column referenced on the right side of the equality compare.</param>
            <param name="indexName">The name of the index found to use to for the scope in this SourceTable.</param>
            <param name="useCache">Whether the lookup is for a unique row and can be cached or should not use the cache
            because it may not be a single-row lookup.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.ClearJoinOptimizationColumns">
            <summary>
            Clear any JOIN optimization hints previously set.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.ClearJoinOptimizationCaching">
            <summary>
            Turn off JOIN optimization caching (eg. because the cache failed for some reason).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.ActivateOptimizedConstraints(System.Boolean@)">
            <summary>
            For now, this disables the cached-lookup join optimization.  Do not call this base if overriding to take advantage
            of cached-lookup optimization (such as in a NativeSourceTable).
            </summary>
            <param name="emptyResultSet">Outputs true if there are no possible results, false if there may be results.</param>
            <returns>True if optimized constraints have been applied (by an override), false if not applied (by default).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.RegisterColumnSignature(System.Int32)">
            <summary>
            Registers a column of this SourceTable as being referenced in the select list as a required column to include
            in the JOIN optimization caching if implemented in a derived class.
            </summary>
            <param name="columnIndex">The index of the column in the schema of this SourceTable.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.Next(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Advance to next row (within a possible filtering scope) in the active index of this table and synchronize
            any following tables (reset to First) for our new row.
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc).</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.ExecuteRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Mark rowAvailable status (true or false) and clear rowUpdated flag.
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc).</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.MarkRowNotAvailable">
            <summary>
            Mark all columns within this table as a null row (in an encapsulating OUTER JOIN).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.Prepare">
            <summary>
            Prepare this SourceTable and determine its schema.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.PrepareTables(VistaDB.DDA.IVistaDBTableNameCollection,VistaDB.Engine.Internal.IViewList,VistaDB.Engine.SQL.TableCollection,System.Boolean,System.Int32@)">
            <summary>
            Prepare this SourceTable within a SELECT (etc) statement.
            </summary>
            <param name="tableNames">The collection of all table names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="views">The collection of all view names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="tableList">Collection of all source tables in this SELECT (etc).  (?)</param>
            <param name="alwaysAllowNull">True if all columns of this JOINed rowset allow NULL in the output schema due to
            an enclosing OUTER JOIN.</param>
            <param name="tableIndex">Reference to the index of the first (left-most) table in this JOINed rowset within the
            tableList collection, and of the next table after this JOINed rowset upon return.</param>
            <returns>This Join instance</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.BeginOptimizedFiltering(VistaDB.Engine.Internal.IOptimizedFilter,System.String)">
            <summary>
            
            </summary>
            <param name="filter"></param>
            <param name="pivotIndex"></param>
            <returns>Eof status</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.SetScope(VistaDB.Engine.Internal.IRow,VistaDB.Engine.Internal.IRow)">
            <summary>
            
            </summary>
            <param name="leftScope"></param>
            <param name="rightScope"></param>
            <returns>Eof status</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SourceTable.SetNextTable(VistaDB.Engine.SQL.SourceTable)">
            <summary>
            Temporary hack to allow re-linking the "next table".  (Will most likely be removed in the long run.)
            </summary>
            <param name="table"></param>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.Version">
            <summary>
            Dynamic data version counter. Incremented when current row content is changed for some reason
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.OptimizedIndexColumn">
            <summary>
            The ColumnSignature in another SourceTable whose value is conditioned to equal a particular column of this
            SourceTable by an ON clause (etc) when ON-equality optimization is possible.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.OptimizedKeyColumn">
            <summary>
            The ColumnSignature in this SourceTable whose value is conditioned to equal a particular column of another
            SourceTable by an ON clause (etc) when ON-equality optimization is possible.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.OptimizedIndexName">
            <summary>
            The name of the index to use in the scope for this SourceTable when ON-equality optimization is possible.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.OptimizedCaching">
            <summary>
            Whether to use caching with ON-equality optimization--because this SourceTable's match is guaranteed
            to be a single row (single-column, UNIQUE index used)--or not.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.RowAvailable">
            <summary>
            Get whether this SourceTable has a row available.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.RowUpdated">
            <summary>
            Get whether this SourceTable has changed to a new overall row that has not yet been executed.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SourceTable.OuterRow">
            <summary>
            Get whether this SourceTable is currently a NULL row (in an encapsulating OUTER JOIN ?).
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.NativeSourceTable">
            <summary>
            A class for SourceTable rowsets from a native database table--including temporary tables, table variables, and
            as a placeholder reference to a named view.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.NativeSourceTable.FreeNativeTable">
            <summary>
            Actually free this NativeSourceTable to the table pool for reuse of its cache.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.NativeSourceTable.CreateSourceTableByName(VistaDB.DDA.IVistaDBTableNameCollection,VistaDB.Engine.Internal.IViewList)">
            <summary>
            Create the appropriate BaseViewSourceTable if this NativeSourceTable is a view rather than a table
            (otherwise just returns this NativeSourceTable). (Error if table name is not a valid table or view.)
            </summary>
            <param name="tableNames">The collection of table names to check in, or null to check among all tables
            in the Database.</param>
            <param name="views">The collection of view names to check in, or null to check among all views in the Database.</param>
            <returns>This NativeSourceTable (eg. NativeSourceTable) or a BaseViewSourceTable representing a named view.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.NativeSourceTable.CreateViewSource(VistaDB.Engine.Internal.IView)">
            <summary>
            Convert a view from its SQL expression into a LiveViewSourceTable or QueryViewSourceTable instance depending
            on the level of processing required for the query (live rows or spooled for additional processing required).
            </summary>
            <param name="view">The referenced IView instantiate into a BaseViewSourceTable.</param>
            <returns></returns>
        </member>
        <member name="T:VistaDB.Engine.SQL.QuerySourceTable">
            <summary>
            A class for SourceTable rowsets from a SELECT statement subquery.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.BaseViewSourceTable">
            <summary>
            A base class for SourceTable rowsets for a view.  Instantiated as either a LiveViewSourceTable or a
            QueryViewSourceTable.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.QueryViewSourceTable">
            <summary>
            A class for SourceTable rowsets from a view whose SQL expression constitutes a "non-live" query which requires
            spooling and additional processing and does not directly return rows as they are accepted by the query.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.LiveViewSourceTable">
            <summary>
            A class for SourceTable rowsets from a view whose SQL expression constitutes a "live" query which does not require
            spooling and additional processing and can directly return live rows as they are accepted by the query.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.FuncSourceTable">
            <summary>
            A class for SourceTable rowsets from a table-valued function call.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.RowSourceTable">
            <summary>
            A class for SourceTable rowsets from a single row (?) of references (only used in CHECK constraints?).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.AcceptJoinedRow">
            <summary>
            Move to the first available row result
            </summary>
            <returns>row available status status (not end of result set)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.AcceptJoinedRowset">
            <summary>
            Loop and accept all applicable rows in JOINed Rowset for a non-live query.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.ExecuteJoin">
            <summary>
            Execute entire JOINed Rowset for a non-live query.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.Optimize">
            <summary>
            Optimize this (SELECT, etc) statement for WHERE and ON clauses
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.InitOptimization">
            <summary>
            Process our WHERE and ON clauses (recursively) into optimizable constraints and severed top-level conditions.
            (New optimization mechanism.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.WhereClause.ResultValue">
            <summary>
            Evaluate WHERE clause signature and map result to a bool return value.
            </summary>
            <returns>True if the WHERE clause is TRUE.  False if WHERE clause is NULL or FALSE.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.WhereClause.Execute(System.Boolean)">
            <summary>
            Evaluate and test the WHERE clause signature (if any)... if not Full optimization or if forced to check.
            </summary>
            <param name="forceToCheck">True to force evaluation even for Full optimization.  False not to force
            evaluation when Full optimization already accounts for it.</param>
            <returns>True if the WHERE clause is TRUE (or no WHERE clause, or unforced Full optimization).
            False if WHERE clause is NULL or FALSE.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.WhereClause.Prepare">
            <summary>
            Prepare this WHERE clause to be evaluated and determine its DataType (must be Bit) and SignatureType
            (constant, etc).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.BaseSelectStatement.WhereClause.Optimize(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Optimize this conditions of this WHERE clause into the constraints collection.
            </summary>
            <param name="constraints">The constraints collection being formed.</param>
            <returns>True if able to optimize all parts of the WHERE clause.  False if some parts could not optimize.</returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.BaseSelectStatement.WhereClause.IsAlwaysFalse">
            <summary>
            Get whether this WHERE clause always evaluates to FALSE or NULL (as a constant) and will never accept any row.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.BaseSelectStatement.WhereClause.IsAlwaysTrue">
            <summary>
            Get whether this WHERE clause always evaluates to TRUE (as a constant) and will accept every row.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.DependencyType">
            <summary>
            Defines the level of dependencies in an expression Signature (tree) as far as what point in the optimization and
            query execution process they can be processed.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.Constant">
            <summary>
            Expressions dependent only on Constant are reduced and replaced during Prepare phase.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.Parameter">
            <summary>
            Logic expressions dependent on Paramter can be calculated at the start of query execution (during initial
            optimize set-up) and condensed.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.ExternalTable">
            <summary>
            Logic expressions dependent on ExternalTable (ExternalColumn) are fixed over the execution of a subquery
            and can be condensed much like Parameter.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.EarlierTable">
            <summary>
            Logic expressions dependent on EarlierTable can only be calculated dynamically during scope recalculation.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.CurrentTable">
            <summary>
            Leaf references to the current table may become optimizable as part of a comparison, but do not propagate up.
            Any non-comparison invocation would need to propagate up as TableSelfCompare???
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.TableSelfCompare">
            <summary>
            Comparisons between columns of the same current table can not be optimized and can only be evaluated as a
            post-optimization test after a specific row has been selected for the current table.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.LaterTable">
            <summary>
            References to later tables can not be evaluated until that later table is being optimized or has been selected.
            Expressions including these can not be processed for optimization of the current table.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.TableValue">
            <summary>
            References to table values in an expression can not necessarily be evaluated (unless being used as a scalar?).
            TODO: What effect should these have on processing?
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.DependencyType.Unknown">
            <summary>
            Signatures that have not yet been processed by a Condense pass have Unknown dependencies.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.Unknown">
            <summary>
            Catch-all for all other types including unquoted single-part identifiers and operators
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.String">
            <summary>
            A quoted string literal (with enclosing ' ' stripped off and internal escaped quotes de-escaped)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.Integer">
            <summary>
            A numeric integer literal
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.Float">
            <summary>
            A non-integer numeric literal (decimal and/or exponential notiation)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.LeftBracket">
            <summary>
            An open-parenthesis
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.Name">
            <summary>
            A quoted single-part name (enclosed in " " or in [ ])
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.ComplexName">
            <summary>
            A multi-part name with each part separately enclosed in " " or [ ] or unquoted
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.Binary">
            <summary>
            A hexadecimal numeric literal starting with 0x or 0X
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.Keyword">
            <summary>
            An unquoted keyword (new, not yet used)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.TokenType.Function">
            <summary>
            An unquoted name of a built-in function (new, not yet used)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.FilterOperation.NotExact">
            <summary>
            Start and end values not included into the scope
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.FilterOperation.StartExact">
            <summary>
            Start value included to the scope, while end value not
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.FilterOperation.EndExact">
            <summary>
            End value included to the scope, while start value not
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.FilterOperation.AllExact">
            <summary>
            Start and end values included into the scope
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.DatePart">
            <summary>
            Enumerates the parts of date/time related values for use in date/time manipulation functions.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.SqlDataType">
            <summary>
            Enumerates SQL language types as seen by the parser.
            </summary>
            <remarks>ATTENTION: Any changes to this enum list must also be reflected in VistaDB.Engine.SQL.Parser.cs in:
            SQLParser.sqlToNativeDataType, SQLParser,tyepsWithMaxLen, SQLParser.typesWithLen, and SQLParser.typesWithScale;
            Those arrays are indexed by a SqlDataType and depend on the order and assignment of these elements.</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.BitmapConjunction(VistaDB.Engine.Core.RowIdFilter@,VistaDB.Engine.Core.RowIdFilter)">
            <summary>
            Combines a newFilter into a scratchPadFilter (which can be modified or replaced) by Conjunction.
            </summary>
            <param name="scratchPadFilter">A reference to the scratch-pad holding a RowIdFilter, ConstantRowIdFilter,
            or null (for all-rows-acceptable).  The scratchPadFilter will be modified to hold the new result or
            replaced with a new filter containing the result if necessary.</param>
            <param name="newFilter">A new RowIdFilter, ConstantRowIdFilter, or null (for all-rows-accpetable) to
            combine into the scratchPadFilter by Conjunction.  The contents of this object will not be modified,
            and this instance will not be assigned as the scratchPadFilter (it will be cloned if necessary).</param>
            <returns>True if the scratchPadFilter has been replaced.  False if the scratchPadFilter has only
            been modified (or left unchanged if newFilter was null or constant True).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.BitmapDisjunction(VistaDB.Engine.Core.RowIdFilter@,VistaDB.Engine.Core.RowIdFilter)">
            <summary>
            Combines a newFilter into a scratchPadFilter (which can be modified or replaced) by Disjunction.
            </summary>
            <param name="scratchPadFilter">A reference to the scratch-pad holding a RowIdFilter, ConstantRowIdFilter,
            or null (for all-rows-acceptable).  The scratchPadFilter will be modified to hold the new result or
            replaced with a new filter containing the result if necessary.</param>
            <param name="newFilter">A new RowIdFilter, ConstantRowIdFilter, or null (for all-rows-accpetable) to
            combine into the scratchPadFilter by Disjunction.  The contents of this object will not be modified,
            and this instance will not be assigned as the scratchPadFilter (it will be cloned if necessary).</param>
            <returns>True if the scratchPadFilter has been replaced.  False if the scratchPadFilter has only
            been modified (or left unchanged if newFilter was null or constant True).</returns>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.optimizationLevel">
            <summary>
            Level of optimization
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.optimizationSetting">
            <summary>
            The OptimizationSetting (eg. On, or Old) for the connection as we start executing the SELECT statement (etc).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.constraints">
            <summary>
            The collection of constraints get with WHERE clause parsing
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.tableColumnOrders">
            <summary>
            The OptimizedTableColumnOrder to apply to each source table (or null if none specified for that table).
            Array will be null if no ORDER BY was specified.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.alwaysNeedSort">
            <summary>
            Gets set to true if parsing of ORDER BY can not be satisfied by an index selection.  (See also forceSortPass.)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.forceSortPass">
            <summary>
            Gets set to true if anything prevents index-optimized from fully providing the requested ORDER BY to ensure
            a spool-and-final-sort is performed for correctness.  (See also alwaysNeedSort.)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.tableConstraints">
            <summary>
            The set of each SourceTable's TableConstraintsCollection of constraints for optimization and evaluation when
            synchronizing that particular SourceTable. (Elements may be null if no constraints for that entry.)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.queryConstraints">
            <summary>
            A TableConstraintsCollection holding constraints which apply to the overall query without reference to any
            included SourceTable. (May be null if no applicable overall constraints.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AddOnConstraint(System.Int32,System.Int32,System.Boolean,VistaDB.Engine.SQL.Signatures.ColumnSignature,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.Internal.CompareOperation,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Add an optimizable constraint from the top-level of the ON clause Signature of a particular JOIN. (New optimization mechanism.)
            </summary>
            <param name="lowTableOrder">The minimum CollectionOrder of the SourceTable(s) added by the particular JOIN being processed.</param>
            <param name="highTableOrder">The maximum CollectionOrder of the SourceTable(s) added by the particular JOIN being processed.</param>
            <param name="isOuterJoin">True if the particular JOIN is an OUTER JOIN.  False for an INNER JOIN (or CROSS JOIN, etc).</param>
            <param name="optimizeColumn">The ColumnSignature whose value is constrained in comparison to the comparisonSignature.</param>
            <param name="comparisonSignature">The Signature that the optimizeColumn is being constrained against by comparison.
            (may be null for IsNull or IsNotNull comparisons).  This is NOT the Signature of a comparison operator itself.</param>
            <param name="compareOperation">The CompareOperation defining the nature of the comparison for this constraint.</param>
            <param name="sourceSignature">The Signature which gave rise to the constraint to add.</param>
            <returns>True if successfully added.  False if unable to add as an optimized constraint.</returns>
            <remarks>A BETWEEN comparison should be optimized as two separate comparison constraints (separate calls here). ???</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AddOnConstraint(System.Int32,System.Int32,System.Boolean,VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint)">
            <summary>
            Add an optimizable constraint from the top-level of the ON clause Signature of a particular JOIN. (New optimization mechanism.)
            </summary>
            <param name="lowTableOrder">The minimum CollectionOrder of the SourceTable(s) added by the particular JOIN being processed.</param>
            <param name="highTableOrder">The maximum CollectionOrder of the SourceTable(s) added by the particular JOIN being processed.</param>
            <param name="isOuterJoin">True if the particular JOIN is an OUTER JOIN.  False for an INNER JOIN (or CROSS JOIN, etc).</param>
            <param name="constraint">The TableColumnConstraint to add (after validation checks).</param>
            <returns>True if successfully added.  False if unable to add as an optimized constraint.</returns>
            <remarks>A BETWEEN comparison should be optimized as two separate comparison constraints (separate calls here). ???</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AddWhereConstraint(VistaDB.Engine.SQL.Signatures.ColumnSignature,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.Internal.CompareOperation,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Add an optimizable constraint from the top-level of the WHERE clause Signature of a SELECT (etc). (New optimization mechanism.)
            </summary>
            <param name="optimizeColumn">The ColumnSignature whose value is constrained in comparison to the comparisonSignature.</param>
            <param name="comparisonSignature">The Signature that the optimizeColumn is being constrained against by comparison.
            (may be null for IsNull or IsNotNull comparisons).  This is NOT the Signature of a comparison operator itself.</param>
            <param name="compareOperation">The CompareOperation defining the nature of the comparison for this constraint.</param>
            <param name="sourceSignature">The Signature which gave rise to the constraint to add.</param>
            <returns>True if successfully added.  False if unable to add as an optimized constraint.</returns>
            <remarks>A BETWEEN comparison should be optimized as two separate comparison constraints (separate calls here). ???</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AddWhereConstraint(VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint)">
            <summary>
            Add an optimizable constraint from the top-level of the WHERE clause Signature of a SELECT (etc). (New optimization mechanism.)
            </summary>
            <param name="constraint">The TableColumnConstraint to add (after validation checks).</param>
            <returns>True if successfully added.  False if unable to add as an optimized constraint.</returns>
            <remarks>A BETWEEN comparison should be optimized as two separate comparison constraints (separate calls here). ???</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AddOnCondition(System.Int32,System.Int32,System.Boolean,VistaDB.Engine.SQL.Signatures.Signature,System.Boolean)">
            <summary>
            Add a testable condition from the top-level of an ON clause of a particular join.  (New optimization mechanism.)
            </summary>
            <param name="lowTableOrder">The minimum CollectionOrder of the SourceTable(s) added by the particular JOIN being processed.</param>
            <param name="highTableOrder">The minimum CollectionOrder of the SourceTable(s) added by the particular JOIN being processed.</param>
            <param name="isOuterJoin">True if the particular JOIN is an OUTER JOIN.  False for an INNER JOIN (or CROSS JOIN, etc).</param>
            <param name="conditionSignature">The Signature of the condition to evaluate.</param>
            <param name="inverted">The result of this Signature should be inverted (NOT).</param>
            <returns>True if successfully added.  False if unable to add as a testable condition.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AddWhereCondition(VistaDB.Engine.SQL.Signatures.Signature,System.Boolean)">
            <summary>
            Add a testable condition from the top-level of the WHERE clause of SELECT.  (New optimization mechanism.)
            </summary>
            <param name="conditionSignature">The Signature of the condition to evaluate.</param>
            <param name="inverted">The result of this Signature should be inverted (NOT).</param>
            <returns>True if successfully added.  False if unable to add as a testable condition.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.RegisterOuterTable(System.Int32)">
            <summary>
            Register that a particular SourceTable is on the null-row side of an OUTER join and needs to keep its ON and WHERE
            constraints separate.
            </summary>
            <param name="tableOrder">The CollectionOrder of the SourceTable which might need a null-row if there is no match
            given the ON clause(s).</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.IsTableRowAcceptable(System.Int32,System.Boolean)">
            <summary>
            Test whether the SourceTable indicated by specified tableOrder passes the conditions and constraints that can
            be evaluated for that tableOrder before proceding to SyncNextTable(). (New optimization mechanism.)
            </summary>
            <param name="tableOrder">The tableOrder of the SourceTable being advanced to its next acceptable row.</param>
            <param name="useWhere">True to test both WHERE and ON clause conditions and constraints.  False to test only
            local ON clause conditions and constraints (eg. for an OUTER JOINed table).</param>
            <returns>True if the row passes the conditions and constraints that can be evaluated for that tableOrder.
            False if the row fails and the SourceTable should be advanced further before sync'ing any further tables.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AnalyzeOptimizationLevel">
            <summary>
            Analyze level of optimization
            </summary>
            <returns>Possible optimization status</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.InitOptimizedOrderColumns">
            <summary>
            Initialize handling for index-optimized ORDER BY columns (and clear any specified columns).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.AddOptimizedOrderColumn(VistaDB.Engine.SQL.Signatures.ColumnSignature,System.Boolean)">
            <summary>
            Add the next ORDER BY column for indexed-order optimization (attempt).  If unable to call this method to add
            the next column (eg. not a ColumnSignature) then call ForceOrderBySortPass() to ensure correct ORDER BY.
            </summary>
            <param name="column"></param>
            <param name="descending"></param>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.ForceOrderBySortPass">
            <summary>
            Call this method when optimized order columns are not sufficient for requested ORDER BY and sort spooling is
            still needed.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.ResetOptimizedOrderLogic">
            <summary>
            Reset the flag forcing a sort pass.  This needs to be called before a new execution is attempted or else the
            wrong execution branch might be taken.  (Call from SetChanged() when clearing other flags.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.ActivateOptimizedFilter(System.Int32)">
            <summary>
            Build optimization bitmap in all native source tables participating this constraint table
            </summary>
            <returns>Empty result set status</returns>
            <param name="tableOrder">The table order in the list of joined tables</param>
            <remarks>This activation called every time we start traversing for 
            the tail of tables in joined table list. So, we re-evaluate all 
            linking conditions and try to optimize traversing for the tail on the right hand of 
            joined table list</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.RollBackAddedConstraints(System.Int32)">
            <summary>
            Remove constraints added after a remembered point (by old Count value) before returning up a call stack.
            </summary>
            <param name="oldCount">The old Count, and thus the index at which to remove that and later constraints
            from the collection.</param>
            <returns>True if any constraints were removed, false if there were no new constraints to remove.</returns>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.ConstraintType">
            <summary>
            Helper constraint type used to analyze optimization level with WHERE clause
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.OptimizationParts">
            <summary>
            Collection of constraints filled out with WHERE clause parsing
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope">
            <summary>
            A representation of a dynamic scope for a particular SourceTable which can be calculated given determined rows
            for "previous" SourceTables to quickly determine its corresponding scope containing all possible matches.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.constraintOperations">
            <summary>
            The main ConstraintOperations collection that this DynamicTableScope is a part of.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.tableOrder">
            <summary>
            The order number (array index) of the SourceTable this DynamicTableScope applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.sourceTable">
            <summary>
            The particular JOINed SourceTable that this DynamicTableScope applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.activeIndex">
            <summary>
            The selected ActiveIndex used to optimize this particular JOINed SourceTable.  (null for not optimized by Index)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.indexKeyRow">
            <summary>
            The unmodified key Row info for our ActiveIndex of our SourceTable.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.indexKeyColumns">
            <summary>
            The IVistaDBIndexInformation for our ActiveIndex of our SourceTable.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.nextKeyColumnOrder">
            <summary>
            The index/order of the next column in the index key that can be constrained.  After complete is set
            this is left pointing to the column with range constraints (if any).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.currentTopKey">
            <summary>
            The computed key row for the Top of scope for the selected activeIndex (or Top row of SourceTable).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.currentBottomKey">
            <summary>
            The computed key row for the Bottom of scope for the selected activeIndex (or Bottom row of SourceTable).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.newTopKey">
            <summary>
            The key being computed for the new Top of scope for the selected activeIndex (or Top row of SourceTable).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.newBottomKey">
            <summary>
            The key being computed for the new Bottom of scope for the selected activeIndex (or Bottom row of SourceTable).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.excludeNulls">
            <summary>
            Whether this scope contains comparisons which implicitly exclude NULLs (most do).
            TODO: Expand this to a bitmap for which columns of activeIndex exclude nulls, and support in bitmap generation.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.doNotExcludeNulls">
            <summary>
            Whether this scope contains an explicit IS NOT NULL constraint which supersedes excludeNulls.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.excludeNullsColumns">
            <summary>
            A bitmap of columns for which this scope contains comparisons which implicitly exclude NULLs. TODO: ???
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.excludeNullsKeyOrders">
            <summary>
            An array of key column orders for which this scope contains comparisons which implicitly exclude NULLs.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.currentBitmap">
            <summary>
            The computed bitmap for the currently synchronized table rows (or null if not computed).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.equalityKeySignatures">
            <summary>
            The set of Signatures to evaluate into the key row for both Top and Bottom of scope for the selected activeIndex.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.hasRangeConstraints">
            <summary>
            Indicates that one or more range-type constraints have been added for the key column pointed to by
            nextKeyColumnOrder (no further equality constraints may be added once this is true).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.lowExcludedSignatures">
            <summary>
            An optional set of one or more Signatures to find the Max of as the lower boundary of the range on the
            column pointed to by nextKeyColumnOrder (but excluded).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.lowIncludedSignatures">
            <summary>
            An optional set of one or more Signatures to find the Max of as the lower boundary of the range on the
            column pointed to by nextKeyColumnOrder.  This applies only if higher than the lowExcludedSignatures boundary.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.highExcludedSignatures">
            <summary>
            An optional set of one or more Signatures to find the Min of as the upper boundary of the range on the
            column pointed to by nextKeyColumnOrder (but excluded).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.highIncludedSignatures">
            <summary>
            An optional set of one or more Signatures to find the Min of as the upper boundary of the range on the
            column pointed to by nextKeyColumnOrder.  This applies only if lower than the highExcludedSignatures boundary.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.exceptionValueSignatures">
            <summary>
            An optional set of one or more Signatures whose values should be excluded from the bitmap filter
            otherwise computed.  This applies to the column for which range constraints are allowed.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.complete">
            <summary>
            Locks out further changes to the scope settings.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.AddEqualityConstraint(VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Add a constraint on the next key column (identified by NextKeyColumnRowIndex) to be equal to a given
            Signature value.
            </summary>
            <param name="nextSignature">The Signature whose evaluated value should be matched.  A Signature which
            evaluates to a NULL will fail all matches, so a null should be passed for the Signature to indicate a
            match against NULL (eg. Col IS NULL).</param>
            <returns>True if the constraint was successfully added.  False if it was rejected. ???</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.AddLowerBoundConstraint(VistaDB.Engine.SQL.Signatures.Signature,System.Boolean)">
            <summary>
            Add a lower-bound range constraint on the column pointed at by nextKeyColumnOrder (locks out further
            equality constraints).  Also see the <see CREF="NextKeyColumnRowIndex">NextKeyColumnRowIndex</see> property.
            </summary>
            <param name="lowSignature">The Signature evaluating to the lower bound.  A Signature which evaluates to a NULL
            will fail all matches, so a null should be passed to indicate a match against NULL (eg. Col IS NOT NULL,
            or as a NULL-excluding constraint when any comparison to Col is made).</param>
            <param name="included">True if the value of this boundary should be inlcuded in the range (eg.
            Col &gt;= lowBound).  False if the value should be excluded from the range (eg. Col &gt; lowBound,
            Col IS NOT NULL).</param>
            <returns>True if the constraint was successfully added.  False if it was rejected. ???</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.AddUpperBoundConstraint(VistaDB.Engine.SQL.Signatures.Signature,System.Boolean)">
            <summary>
            Add a lower-bound range constraint on the column pointed at by nextKeyColumnOrder (locks out further
            equality constraints).  Also see the <see CREF="NextKeyColumnRowIndex">NextKeyColumnRowIndex</see> property.
            </summary>
            <param name="highSignature">The Signature evaluating to the upper bound.  A Signature which evaluates to a NULL
            will fail all matches.  To match Col IS NULL use AddEqualityConstraint(null) instead.</param>
            <param name="included">True if the value of this boundary should be inlcuded in the range (eg.
            Col &lt;= highBound).  False if the value should be excluded from the range (eg. Col &lt; highBound).</param>
            <returns>True if the constraint was successfully added.  False if it was rejected. ???</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.AddExcludedValueConstraint(VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Add an excluded-value (!=) constraint on the column pointed at by nextKeyColumnOrder (locks out further
            equality constraints).  Also see the <see CREF="NextKeyColumnRowIndex">NextKeyColumnRowIndex</see> property.
            </summary>
            <param name="excludedSignature">The Signature evaluating to a value which the column shall not equal.
            A Signature which evaluates to a NULL will fail all matches.  To match Col IS NOT NULL use
            AddLowerBoundConstraint(null, false) instead.</param>
            <returns>True if the constraint was successfully added.  False if it was rejected. ???</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.CompleteScope">
            <summary>
            Mark this DynamicTableScope as complete even if there are further key columns that could be constrained.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.ResetTableOptimization">
            <summary>
            Call this to invoke ResetOptimization() on our sourceTable if needed after we are set up.
            CALLING ResetOptimization() directly could get DynamicTableScope state out of sync with sourceTable's scope.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.RecalculateAndSetTableScope">
            <summary>
            Recalculate this DynamicTableScope for new determined rows of "previous" SourceTables and apply it to
            our SourceTable.
            </summary>
            <returns>True if the scope is empty.  False if the scope may be non-empty. (?)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.RecalculateScopeBoundaries">
            <summary>
            Recalculate this DynamicTableScope for new determined rows of "previous" SourceTables and determine
            the necessary boundary keys.
            </summary>
            <returns>True if the scope is empty.  False if the scope may be non-empty. (?)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.AddListSignature(System.Collections.Generic.List{VistaDB.Engine.SQL.Signatures.Signature}@,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Helper method to add a Signature to a list after creating the list if necessary.
            </summary>
            <param name="signatureList">Reference to the List&lt;Signature&gt; to add the newSignature to.</param>
            <param name="newSignature">The Signature to add to the list.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.CalculateLowRangeValue(System.Boolean@)">
            <summary>
            Helper method to calculate the current highest lower-bound constraint value (and whether included in or
            excluded from the range).
            </summary>
            <param name="excluded">Outputs true if boundary value is excluded from the range or true if boundary value
            is included in the range.</param>
            <returns>The lower-bound column value to use.  A Value of (SQL) NULL means that all matches fail.
            A returned null means to use NULL as the lower bound key value.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.CalculateHighRangeValue(System.Boolean@)">
            <summary>
            Helper method to calculate the current lowest upper-bound constraint value (and whether included in or
            excluded from the range).
            </summary>
            <param name="excluded">Outputs true if boundary value is excluded from the range or true if boundary value
            is included in the range.</param>
            <returns>The upper-bound column value to use.  A Value of (SQL) NULL means that all matches fail.
            A returned null means to use NULL as the upper bound key value.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.MarkNullsExcluded(System.Int32)">
            <summary>
            Mark a key column as excluding NULLs.
            </summary>
            <param name="keyColumnOrder">The keyColumnOrder in the index key structure for the column which should
            exclude NULLs.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.GetNullsExcludedKeyOrders">
            <summary>
            Get the int array indicating which column key orders should exclude NULLs. (Contents must not be modified!)
            </summary>
            <returns>An array of int</returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.NextKeyColumnRowIndex">
            <summary>
            The RowIndex (in the parent table) of the next key column that can be constrained.  (int.MaxValue if none left
            or this DynamicTableScope has been completed)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.NextKeyColumnNumber">
            <summary>
            The column number (in the activeIndex) of the next key column that can be constrained.  Not the RowIndex
            in the parent table (see NextKeyColumnRowIndex).  (int.MaxValue if none left or this DynamicTableScope
            has been completed)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.IndexColumnCount">
            <summary>
            The number of columns in the index key, or 0 if there is no activeIndex set for this DynamicTableScope.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope.HasScope">
            <summary>
            Get whether this DynamicTableScope has an actual scope on an active index (true) or represents a non-indexed
            table scope.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection">
            <summary>
            A collection of constraints applying to a particular table for optimization and optimal evaluation.
            </summary>
            <remarks>This class will collect constraints and expression signatures to be used to optimize the advancement
            of a particular SourceTable and filter candidate rows prior to synchronization of further SourceTables.
            The ConstraintsOperations collection will maintain a TableConstraintsCollection for each of the SourceTables
            and for the no-table case if applicable.  Constraints and Signatures within a TableConstraintsCollection will
            be further divided based on whether they come from the ON clause which JOINed this SourceTable or from the
            WHERE clause (or possibly from another ON clause of an INNER JOIN).</remarks>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.constraintOperations">
            <summary>
            The main ConstraintOperations collection that this TableConstraintsCollection is a part of.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.tableOrder">
            <summary>
            The order number (array index) of the JOINed table this collection applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.sourceTable">
            <summary>
            The particular JOINed SourceTable that this collection applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.isOuterJoin">
            <summary>
            Whether the particular JOIN that this collection applies to is an OUTER join (only for level of care with
            optimization; this does not create OUTER JOIN behavior).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.optimizedColumnOrder">
            <summary>
            The requested column order for this table to try to optimize by index selection.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.topOnConstraints">
            <summary>
            The collection of individually-optimizable top-level TableColumnConstraints from the ON clause
            (also from WHERE clause for INNER JOINs, etc ?).
            </summary>
            <remarks>
            This collects individual top-level constraints from the ON clause of this particular JOINed SourceTable.
            </remarks>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.localOnConditions">
            <summary>
            The collection of other (non-optimizable) expression Signatures from the ON clause which can be independently
            tested for this particular JOINed SourceTable (also from WHERE clause for INNER JOINs, etc).
            </summary>
            <remarks>
            This collects Signatures (?) of other conditions from the ON clause of this particular JOINed SourceTable
            which could not be broken down into individual optimizable constraints.  A false (or NULL) by any of these
            Signatures would mean that there are no matches and that a NULL row should be considered if this is a
            LEFT OUTER JOIN case.  (TODO: How to handle RIGHT OUTER JOINs?)
            </remarks>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.localOnConditionsInverted">
            <summary>
            The set of flags corresponding to Signatures in localOnConditions which need to be evaluated as inverted.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.topOtherConstraints">
            <summary>
            The collection of individually-optimizable top-level TableColumnConstraints that can be applied to this
            SourceTable but are not from this SourceTable's ON clause, if any (and not an INNER JOIN, etc).
            </summary>
            <remarks>
            This collects individual top-level constraints from the WHERE clause or possibly from other ON clauses
            when they can be safely optimized here (rare). (TODO: Should these just use the externalConditions collection?)
            (Or do we collect them here first and for INNER JOINs then add them to the two On collections?)
            </remarks>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.externalConditions">
            <summary>
            The collection of other (non-optimizable) expression Signatures which can be evaluated for this SourceTable
            but are not from this SourceTable's ON clause, if any (and not an INNER JOIN, etc).
            </summary>
            <remarks>
            This collects Signatures (?) of other conditions from the WHERE clause and from other ON clauses which
            could not be broken down into individual optimizable constraints but which can be evaluated for this
            SourceTable (after OUTER handling) before synchronization of further SourceTables.
            </remarks>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.externalConditionsInverted">
            <summary>
            The set of flags corresponding to Signatures in externalConditions which need to be evaluated as inverted.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.topOnPeerGroup">
            <summary>
            The collection of TableColumnConstraints (?) and ConstraintOrPeerGroups which are AND peers within the
            top of the ON clause (null if none have been added).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.topWherePeerGroup">
            <summary>
            The collection of TableColumnConstraints (?) and ConstraintOrPeerGroups which are AND peers within the
            top of the WHERE clause whose MaxTableOrder associates them with this TableConstraintsCollection
            (null if none have been added).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.columnSetMap">
            <summary>
            The set of columns for which this collection has any optimized constraints.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.activeIndex">
            <summary>
            The selected ActiveIndex used to optimize this particular JOINed SourceTable.  (null for not optimized by Index)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.dynamicScope">
            <summary>
            The representative dynamically-calculated scope (for the selected activeIndex) for our particular SourceTable.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.currentFinalBitmap">
            <summary>
            The RowIdFilter for the combined constraints in this collection given the current earlier tables' rows.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.globalForceBitmaps">
            <summary>
            Force the use of bottom-up bitmaps to handle the use of OR (and/or possibly NOT) logic.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.indexForColumn">
            <summary>
            Caches the index found for use in converting a TableColumnConstraint into a leaf bitmap.
            (Maps columnOrder to indexName.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.InitializeOptimization">
            <summary>
            Initialize optimization: Select the ActiveIndex (if possible) to use for our SourceTable (if there is one),
            and initialize the key expressions.
            </summary>
            <returns>???</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.FirstRow(System.Boolean)">
            <summary>
            Initialize optimization (if specified) and reset to the first row of the query/operation.
            </summary>
            <returns>True if there is an available row.  False if no row is available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.ApplyOptimizedScope">
            <summary>
            Go to the first row of our SourceTable given the current rows of SourceTables to the left.
            </summary>
            <returns>True if the scope is empty.  False if the scope may be non-empty. (?)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.AddOnConstraint(VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint)">
            <summary>
            Add a TableColumnConstraint from an ON clause to this TableConstraintsCollection.
            </summary>
            <param name="columnConstraint">The TableColumnConstraint to add.</param>
            <returns>True if successful.  False if columnConstraint or its Column are null.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.AddWhereConstraint(VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint)">
            <summary>
            Add a TableColumnConstraint from the WHERE clause to this TableConstraintsCollection.
            </summary>
            <param name="columnConstraint">The TableColumnConstraint to add.</param>
            <returns>True if successful.  False if columnConstraint or its Column are null.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.AddOnCondition(VistaDB.Engine.SQL.Signatures.Signature,System.Boolean)">
            <summary>
            Add a testable condition Signature from an ON clause to this TableConstraintsCollection.
            </summary>
            <param name="conditionSignature">The condition Signature to add.</param>
            <param name="inverted">The result of this Signature should be inverted (NOT).</param>
            <returns>True if successful.  False if conditionSignature is null or can't be added to this collection.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.AddWhereCondition(VistaDB.Engine.SQL.Signatures.Signature,System.Boolean)">
            <summary>
            Add a testable condition Signature from the WHERE clause to this TableConstraintsCollection.
            </summary>
            <param name="conditionSignature">The condition Signature to add.</param>
            <param name="inverted">The result of this Signature should be inverted (NOT).</param>
            <returns>True if successful.  False if conditionSignature is null or can't be added to this collection.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.DoOnConditionsPass">
            <summary>
            Test whether the constraints and conditions from the local ON clause pass for the current row of our
            SourceTable (eg. before bothering to call SyncNextTable()).
            </summary>
            <param name="useWhere">False to test constraints and conditions ONLY from the local ON clause (eg. for
            an OUTER JOINed table).  True to test all constraints and conditions for our tableOrder (eg. INNER JOINed
            table or after OUTER JOIN effect has been accounted for).</param>
            <returns>True if the constraints and conditions evaluated all pass and the row is worth proceeding with.
            False if the current row fails to pass and should be skipped.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.DoOtherConditionsPass">
            <summary>
            Test whether the constraints and conditions from the WHERE clause (etc) pass for the current row of our
            SourceTable (eg. before bothering to call SyncNextTable()).
            </summary>
            <returns>True if the constraints and conditions evaluated all pass and the row is worth proceeding with.
            False if the current row fails to pass and should be skipped.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.FindIndexForColumnBitmap(VistaDB.Engine.SQL.Signatures.ColumnSignature,System.Boolean)">
            <summary>
            Find the best available indexName to use for turning a TableColumnConstraint (group) into a leaf bitmap.
            </summary>
            <param name="column">The ColumnSignature in the underlying table for which to find an index.</param>
            <param name="createTempIndex">Whether to create a temporary index if no usable index can be found.</param>
            <returns>The name of an index to use, or null if none was available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.FindBestAvailableIndex(VistaDB.Engine.SQL.ConstraintOperations.TableIndexedColumnSet,System.Boolean)">
            <summary>
            Find the best available index given the set of columns for which there are optimized constraints,
            giving preference to an index that matches the optimizedColumnOrder;
            </summary>
            <param name="columnSet">The TableIndexedColumnSet representing the set of columns for which there are
            optimized contraints.</param>
            <param name="useWhere">True to use all WHERE and ON constraints.  False to use only local ON constraints
            (eg. for an OUTER JOINed table).</param>
            <returns>The IVistaDBIndexInformation for the selected "best" index to use for optimization of the
            particular sourceTable for this TableConstraintsCollection.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.AssessConstrainedColumns">
            <summary>
            Assess the set of constraints on columns to determine how to weight available indexes for optimization.
            </summary>
            <returns>True if constraints are found.  False if there are no constraints and index optimization is unnecessary.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableConstraintsCollection.IncorporateConstraintsForBitmapping">
            <summary>
            Add any TableColumnConstraints we have that are not Optimized and add them to the appropriate top AND peer
            group.  (Call after InitializeOptimization() has marked constraints Optimized.) 
            </summary>
            <returns></returns>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.TableIndexedColumnSet">
            <summary>
            A class to represent the set of columns for a specific given table for which there are constraints and/or
            which exist in the key for a specific given index on that table.
            </summary>
            <remarks><para>This class must be able to represent a shorthand for the set of columns for which there are
            constraints and track distinctions such as whether the constraint is a single-value equality constraint or a
            range-type constraint and whether the constraint is from the ON clause or WHERE clause.  An additional weight
            based on data type may also be retained (eg. BIT have less value than an INT).</para>
            <para>This class must also be able to evaluate an index for its suitability for optimizing the available
            constraints and calculate an overall weight value for that index in order to allow selection of the "best"
            available index.  An index which can uniquely select a single row from the available constraints (with the
            fewest necessary column constraints, ie. the shortest index key) is most ideal.  An index which has additional
            unused key columns is less ideal.</para></remarks>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint">
            <summary>
            A simple representation of a constraint on a column of a table, for use with a TableConstraintsCollection.
            (New optimization system.  Does not inherit from Constraint.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.#ctor(VistaDB.Engine.SQL.Signatures.ColumnSignature,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.Internal.CompareOperation,System.Boolean,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Create a TableColumnConstraint upon a specific table Column based upon an optimizable comparison to a
            constraintValue.
            </summary>
            <param name="constrainedColumn">The ColumnSignature representing the column constrained by this
            TableColumnConstraint.</param>
            <param name="constraintValue">The Signature representing the expression or simple value compared against by
            this TableColumnConstraint. (evaluation to a Value of (SQL) NULL would fail the match, so a .NET null means
            deliberate match against null)</param>
            <param name="compareOperation">The CompareOperation enum value identifying the nature of the comparison
            for this TableCompareConstraint. (The Column is considered to be on the left of the operation for binary
            comparison operators.)</param>
            <param name="invertedOperation">Indicates a special inverted-sense operator, such as IS NOT NULL. 
            (Might also work to apply a NOT operator to the constraint. ???)</param>
            <param name="sourceSignature">The Signature which gave rise to this constraint.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.ApplyInversion(System.Boolean)">
            <summary>
            Invert the current sense of the comparison for this constraint (as if wrapped by a NOT operator).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.AddToScope(VistaDB.Engine.SQL.ConstraintOperations.DynamicTableScope,System.Boolean,System.Boolean)">
            <summary>
            Add this TableColumnConstraint (optionally inverted) as boundaries in a given scope, optionally as
            multi-column key equality values, or as excluded values (for use with bitmap logic).
            </summary>
            <param name="scope">The DynamicTableScope to apply this TableColumnConstraint to.</param>
            <param name="multiColumnEquality">True to use multi-column key values and advance to the next key column.
            False to apply Equals (or inverted NotEquals) as boundaries on the current key column (prevents use of
            further key columns).</param>
            <param name="inverse">False to apply this constraint with its current InvertedOperation setting.
            True to apply the inverse of the current InvertedOperation setting.</param>
            <returns>True if this constraint was successfully added to the scope.  False if it was rejected.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.DoesConstraintPass">
            <summary>
            Evaluate the Column and Expression for the current SourceTable rows and check the comparison.
            </summary>
            <returns>Null if the constraint evaluates to NULL/UNKNOWN.  True if the constraint accepts the current
            rows.  False if the constraint fails (comparison is false).</returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.Column">
            <summary>
            The ColumnSignature representing the column constrained by this TableColumnConstraint.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.ColumnIndex">
            <summary>
            The unique index number of the column constrained by this TableColumnConstraint within its table's schema.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.Expression">
            <summary>
            The Signature representing the expression or simple value compared against by this TableColumnConstraint.
            (evaluation to a Value of (SQL) NULL would fail the match, so a .NET null means deliberate match against null)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.CompareOperation">
            <summary>
            The CompareOperation enum value identifying the nature of the comparison for this TableCompareConstraint.
            (The Column is considered to be on the left of the operation for binary comparison operators.)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.IsFts">
            <summary>
            Indicates whether this is a normal constraint (false) or a special FTS constraint.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.InvertedOperation">
            <summary>
            Indicates a special inverted-sense operator, such as IS NOT NULL.  (Might also work to apply a NOT operator
            to the constraint.)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.Optimized">
            <summary>
            Indicates that this TableColumnConstraint has been specifically incorporated into optimization filtering.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.Bitmapped">
            <summary>
            Indicates that this TableColumnConstraint has been incorporated into a bitmap filter.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.IsBitmapRequired">
            <summary>
            Indicates whether this constraint requires a bitmap for optimization (True) or can be applied
            as part of a scope (False).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint.IsSingleValue">
            <summary>
            Indicates whether this constrains its column to a single value (True) or to a possible range of
            values (False).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.TableColumnFtsConstraint.#ctor(VistaDB.Engine.SQL.Signatures.ColumnSignature,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.Internal.CompareOperation,System.Boolean,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Create a TableColumnFtsConstraint upon a specific table Column based upon an optimizable CONTAINS
            function call.
            </summary>
            <param name="constrainedColumn">The ColumnSignature representing the column constrained by this
            TableColumnConstraint.</param>
            <param name="constraintValue">The Signature representing the expression or simple value compared against by
            this TableColumnConstraint. (evaluation to a Value of (SQL) NULL would fail the match, so a .NET null means
            deliberate match against null)</param>
            <param name="compareOperation">The CompareOperation enum value identifying the nature of the comparison
            for this TableCompareConstraint. (The Column is considered to be on the left of the operation for binary
            comparison operators.)</param>
            <param name="invertedOperation">Indicates a special inverted-sense operator, such as IS NOT NULL. 
            (Might also work to apply a NOT operator to the constraint. ???)</param>
            <param name="sourceSignature">The Signature which gave rise to this constraint.</param>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup">
            <summary>
            Represents a group of constraints that are logically combined by the same operation all under the same
            common root within a WHERE or ON clause and are thus peers.  This also includes any sub-groups whose
            root is a peer within this group.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.constraintOperations">
            <summary>
            The main ConstraintOperations collection that this OrTierAcceptanceCollection is a part of.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.tableConstraints">
            <summary>
            The particular TableConstraintsCollection that this OrTierAcceptanceCollection is part of.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.tableOrder">
            <summary>
            The order number (array index) of the JOINed table this collection applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.sourceTable">
            <summary>
            The particular JOINed SourceTable that this collection applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.groupSignature">
            <summary>
            The Signature of the OR (or IN, etc) containing this entire group. (After condensing-out any fixed values.)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.peerConstraints">
            <summary>
            The List of leaf TableColumnConstraint instances in this peer group (not in sub-groups).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.columnScopes">
            <summary>
            A dictionary mapping of the DynamicTableScope instance which holds the scope optimization information
            from this group (not including sub-groups) by each included column from which to compute individual bitmaps.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.peerPostConditions">
            The collection of other (non-optimizable) expression Signatures from this peer group which can be
            independently tested (possibly as inverted) after a row of our sourceTable has been chosen.
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.peerPostConditionsInverted">
            <summary>
            The set of flags corresponding to Signatures in peerPostConditions which need to be evaluated as inverted.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.peerPreConditions">
            The collection of other (non-optimizable) expression Signatures from this peer group which can be
            independently tested (possibly as inverted) before choosing any row of our sourceTable (based only
            on earlier tables).
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.peerPreConditionsInverted">
            <summary>
            The set of flags corresponding to Signatures in peerPreConditions which need to be evaluated as inverted.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.groupOptimized">
            <summary>
            A flag whether this ConstraintPeerGroup is fully optimized (true) or not fully optimizable (false).
            This may affect whether any optimization is possible for this group and its sub-groups.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.currentPreBitmap">
            <summary>
            A ConstantRowIdFilter bitmap representing the pre-optimization state of this group (and those under it).
            A null represents undetermined state; otherwise, the bitmap's Constant represents the forced state for all rows.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.preBitmapDetermined">
            <summary>
            A flag to indicate that the currentPreBitmap has been calculated (true) or not (false).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.InitializeLocalBitmapScopes(System.Boolean)">
            <summary>
            Process local constraints for this ConstraintPeerGroup into a DynamicTableScope for each constrained
            column (grouped for each column) as ANDed (Conjunction / set-intersection) constraints, optionally
            inverted first.
            </summary>
            <param name="inverse">Whether to invert all inputs (eg. to implement an OR peer group).</param>
            <returns>True if successfully fully-optimized.  False if one or more constraints could not be included.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.CombineBitmaps(System.Boolean)">
            <summary>
            Combine all constraint bitmaps into one overall RowIdFilter for this ConstraintPeerGroup (optionally
            inverted) including local constraints, local excluded values (all applicable columns), and sub-groups.
            </summary>
            <param name="finalInvert">Whether the final RowIdFilter for constraints under this ConstraintPeerGroup
            should be inverted (eg. because outer level needs its inputs inverted).</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.ConstraintPeerGroup.GenerateBitmap(System.Boolean)">
            <summary>
            Generate a combined RowIdFilter for this ConstraintPeerGroup (and all below it), and optionally
            invert the final result.
            </summary>
            <param name="finalInvert">Whether to invert the final RowIdFilter we compute (eg. if the level
            above us needs its inputs inverted).</param>
            <returns>A RowIdFilter representing the combined optimized effect of constraints in this
            ConstraintPeerGroup and all groups beneath it (or the inverse of that, if requested).</returns>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.ConstraintAndPeerGroup">
            <summary>
            Represents a group of constraints that are logically combined with each other by AND under the same
            common root within a WHERE or ON clause and are thus AND-peers.  This also includes any sub-groups whose
            root is an AND-peer within this group.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintAndPeerGroup.subOrGroups">
            <summary>
            The List of sub-groups under this peer group.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.ConstraintOrPeerGroup">
            <summary>
            Represents a group of constraints that are logically combined with each other by OR under the same
            common root within a WHERE or ON clause and are thus AND-peers.  This also includes any sub-groups whose
            root is an OR-peer within this group.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.ConstraintOrPeerGroup.subAndGroups">
            <summary>
            The List of sub-groups under this peer group.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.OrTierAcceptanceCollection">
            <summary>
            Represents a peer group of (typcally) ORed signatures which are themselves grouped into the "top AND" set of an
            ON or WHERE clause and thus must be satisfied but can be satisfied by any of possibly many alternatives.
            </summary>
            <remarks><para>The goal of an instance of this class is to identify, for a specific table, the next-occuring
            row of a selected index which <b>might</b> satisfy the Signature of this group and needs to be checked.  More
            specifically, it needs to be able to determine what current or next range of key values <b>might</b> satisfy
            the group and needs to be checked and what current or next range of key values <b>can't</b> satisfy the
            group and can be efficiently skipped by this group as a filter.</para>
            <para>Towards that end, any alternatives which are a fixed value of false (or null/unknown) can be ignored,
            and any alternatives with a fixed value of true mean that this entire group can be ignored (a wide-open filter).
            Any alternatives which reference columns of earlier tables need to be evaluated (or if also reference the
            current table need to be dynamically condensed) and if reduced to a "known" value the same rules applied
            (for the current pass of the current table) as for fixed values.</para>
            <para>This means that each alternative in the collection could represent:<list>
            <item>A Signature with a value which is fixed (after static condensing) over a single execution of the query.</item>
            <item>A Signature which requires dynamic evaluation to a "known" value based only on earlier tables.</item>
            <item>A Signature which requires dynamic condensing to a "known" value or simplified form which may provide
            dynamic constraints. (??? How to handle ???)</item>
            <item>A Signature with references to earlier tables <i>only</i> in comparisons to the current table which does
            not need to be dynamically condensed but does produce dynamic constraints.</item>
            <item>A Signature with references to the current table <i>only</i> in comparison to values fixed over a
            single execution of the query which thus produce fixed constraints.</item>
            </list>TODO: Other cases...?</para></remarks>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.OrTierAcceptanceCollection.constraintOperations">
            <summary>
            The main ConstraintOperations collection that this OrTierAcceptanceCollection is a part of.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.OrTierAcceptanceCollection.tableConstraints">
            <summary>
            The particular TableConstraintsCollection that this OrTierAcceptanceCollection is part of.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.OrTierAcceptanceCollection.tableOrder">
            <summary>
            The order number (array index) of the JOINed table this collection applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.OrTierAcceptanceCollection.sourceTable">
            <summary>
            The particular JOINed SourceTable that this collection applies to.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.OrTierAcceptanceCollection.groupSignature">
            <summary>
            The Signature of the OR (or IN, etc) containing this entire group. (After condensing-out any fixed values.)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.OrTierAcceptanceCollection.staticAlternatives">
            <summary>
            The set of alternatives which can satisfy this group which do not require dynamic condensing.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.ConstraintOperations.AccumulatedResults">
            <summary>
            Optimization scope and filters collected by table reference they should be applied to
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.AccumulatedResults.OptimizationInfo.ShouldBeMerged">
            <summary>
            Test if all AND constraints should be merged into bitmap before OR operation
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.column">
            <summary>
            The column this constraint is compared with
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.leftValue">
            <summary>
            Left value this constraint is compared with
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.rightValue">
            <summary>
            Right value this constraint is compared with
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.optimizedResult">
            <summary>
            When it is set nothing depends on index scopes or another optimized filter objects
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.alwaysNull">
            <summary>
            When true, the constraint always evaluates to Null (or actually Undefined as a result of compare against Null).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.compareOperation">
            <summary>
            This constraint operation type
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.optimized">
            <summary>
            Helper flag to analyze optimization level
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.ConstraintOperations.Constraint.fullOptimized">
            <summary>
            Helper flag to analyze optimization level
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.Constraint.SimplifyConjunction(System.Int32,System.Boolean@)">
            <summary>
            Decrease number of scopes down to single index to use by every table. 
            If to invert, and there are several tables then we cannot invert and could just set optimizable true 
            </summary>
            <param name="tableOrder"></param>
            <param name="resetFullOptimization"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.ConstraintOperations.Constraint.ActivateFilter(System.Int32,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="tableOrder"></param>
            <returns>The result set is empty</returns>
            <param name="resetFullOptimization"></param>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.Constraint.IsAlwaysNull">
            <summary>
            When true, the constraint always evaluates to Null (or actually Undefined as a result of compare against Null).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.Constraint.NullValuesExcluded">
            <summary>
            Whether this class of Constraint excludes all matches when a null boundary value is specified.
            (Overridden to true for compare constraints.)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.Constraint.ExcludeNulls">
            <summary>
            Whether this instance of a derived Constraint should exclude Null column values from the scope.
            (Only false for IsNull constraint.)
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.Constraint.ShouldBeMerged">
            <summary>
            Test if all AND constraints should be merged into bitmap before OR operation
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.ConstraintOperations.IsNullConstraint.MatchNulls">
            <summary>
            Get whether this constraint matches NULL values (IS NULL) or not (IS NOT NULL).
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.Signature">
            <summary>
            Base class for signatures
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.signatureType">
            <summary>
            Signature type
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.dataType">
            <summary>
            Result value data type
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.lineNo">
            <summary>
            Signature position in the SQL text
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.symbolNo">
            <summary>
            Signature position in the SQL text
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.text">
            <summary>
            Name of the signature in the SQL text
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.parent">
            <summary>
            Signature parent
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.maxTableOrder">
            <summary>
            The max tableOrder referenced by this Signature tree.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.maxAggTableOrder">
            <summary>
            The max tableOrder referenced within any aggregate function referenced by this Signature tree.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.dependencyType">
            <summary>
            The recursively-determined DependencyType of this Signature (tree).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.Signature.evalVersion">
            <summary>
            The version counter for the latest evaluation of this Signature for change-detection.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OnPrepare">
            <summary>
            Prepare signature
            </summary>
            <returns>Prepared signature type</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OnCondenseOptimizedClause(VistaDB.Engine.SQL.ConstraintOperations,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Condense (simplify) a query clause (already prepared and statically condensed) to eliminate sub-clauses
            with values that are fixed or are known as we determine the scope for a selected table (ie. earlier tables).
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="lowTableOrder">The minimum table order of the table whose scope we are dynamically building,
            or the MaxTableOrder of the root Signature being condensed.</param>
            <param name="highTableOrder">The maximum table order of the table whose scope we are dynamically building,
            or the MaxTableOrder of the root Signature being condensed.</param>
            <param name="dynamic">True for full Dynamic condensing, False for only Static condensing.</param>
            <param name="suppressReplacement">True to block replacement and only calculate DependencyType.  False to allow
            actual condense replacement at applicable levels.</param>
            <returns>The new condensed Signature, or the original Signature if condensing was not needed or not possible.</returns>
            <remarks>Implementations must update this.dependencyType representing the worst level of dependency for this
            Signature tree.  For example:  DependencyType.Parameter or DependencyType.EarlierTable.</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OnOptimizeTopOnClause(VistaDB.Engine.SQL.ConstraintOperations,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This Signature is ANDed into the top of an ON clause.  Optimizable Signatures should override to add an applicable
            constraint to the collection (and not call this base).  All other Signatures (must be VistaDBType.Bit) will
            automatically pass this call over to OnOptimizeLogicalOnCondition instead.
            </summary>
            <remarks>The AND operator Signature should propagate this to its operands by calling
            opSig.OptimizeTopOnClause(...)</remarks>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="lowTableOrder">The minimum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="highTableOrder">The maximum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="isOuterJoin">True if this is for an OUTER JOIN.  False for an INNER JOIN or CROSS JOIN (etc).</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.CondenseOptimizedClause(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Statically condense (simplify) a query clause (already prepared) to eliminate sub-clauses with effectively fixed
            values over the execution of the query (eg. parameters).
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <returns>The new condensed Signature instance, or this same Signature instance.</returns>
            <remarks>Implementations will update this.DependencyType representing the worst level of dependency for this
            Signature tree.  For example:  DependencyType.Parameter or DependencyType.EarlierTable.</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.CondenseOptimizedClause(VistaDB.Engine.SQL.ConstraintOperations,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Condense (simplify) a query clause (already prepared) to eliminate sub-clauses with effectively fixed values over
            the execution of the query (eg. parameters), or dynamically condense given current row values for earlier tables.
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="lowTableOrder">The minimum table order of the table whose scope we are dynamically building,
            or the MaxTableOrder of the root Signature being condensed.</param>
            <param name="highTableOrder">The minimum table order of the table whose scope we are dynamically building,
            or the MaxTableOrder of the root Signature being condensed.</param>
            <param name="dynamic">True for full Dynamic condensing, False for only Static condensing.</param>
            <param name="suppressReplacement">True to block replacement and only calculate DependencyType.  False to allow
            actual condense replacement at applicable levels.</param>
            <returns>The new condensed Signature instance, or this same Signature instance.</returns>
            <remarks>Implementations will update this.DependencyType representing the worst level of dependency for this
            Signature tree.  For example:  DependencyType.Parameter or DependencyType.EarlierTable.</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeTopOnClause(VistaDB.Engine.SQL.ConstraintOperations,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This Signature is ANDed into the top of an ON clause and is a candidate for optimization.
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="lowTableOrder">The minimum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="highTableOrder">The maximum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="isOuterJoin">True if this is for an OUTER JOIN.  False for an INNER JOIN or CROSS JOIN (etc).</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeTopWhereClause(VistaDB.Engine.SQL.ConstraintOperations,System.Boolean)">
            <summary>
            This Signature is ANDed into the top of a WHERE clause and is a candidate for optimization.
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeAndPeer(VistaDB.Engine.SQL.ConstraintOperations,VistaDB.Engine.SQL.ConstraintOperations.ConstraintAndPeerGroup,System.Boolean,VistaDB.Engine.SQL.Signatures.NotOperator)">
            <summary>
            This Signature is a (possibly inverted) peer within an AND peer group and should be added to the peer group
            as an optimized constraint or as a logical condition.
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="andPeerGroup">The ConstraintAndPeerGroup within which this Signature instance is a peer.</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <param name="notOperator">The immediate enclosing NotOperator of this Signature instance, or null.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeOrPeer(VistaDB.Engine.SQL.ConstraintOperations,VistaDB.Engine.SQL.ConstraintOperations.ConstraintOrPeerGroup,System.Boolean,VistaDB.Engine.SQL.Signatures.NotOperator)">
            <summary>
            This Signature is a (possibly inverted) peer within an OR peer group and should be added to the peer group
            as an optimized constraint or as a logical condition.
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="orPeerGroup">The ConstraintOrPeerGroup within which this Signature instance is a peer.</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <param name="notOperator">The immediate enclosing NotOperator of this Signature instance, or null.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeLogicalOnCondition(VistaDB.Engine.SQL.ConstraintOperations,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This Signature is ANDed into the top of an ON clause and is therefore a severable condition of the JOIN
            even if not directly optimizable.
            </summary>
            <remarks>Provided the Signature can be evaluated for the specified tableOrder it will be added to the set of
            logical conditions for that tableOrder.  However, if its MaxTableOrder is less than tableOrder and this is not
            an OUTER JOIN this Signature can instead be added for an earlier tableOrder (tricky, must not break OUTER JOINs).</remarks>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="lowTableOrder">The minimum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="highTableOrder">The maximum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="isOuterJoin">True if this is for an OUTER JOIN.  False for an INNER JOIN or CROSS JOIN (etc).</param>
            <param name="inverted">The result of this Signature should be inverted (NOT).</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeLogicalWhereCondition(VistaDB.Engine.SQL.ConstraintOperations,System.Boolean)">
            <summary>
            This Signature is ANDed into the top of a WHERE clause and is therefore a severable condition of the SELECT (etc)
            even if not directly optimizable.
            </summary>
            <remarks>Provided the Signature can be evaluated for the specified tableOrder it will be added to the set of
            logical conditions for that tableOrder.  However, if its MaxTableOrder is less than tableOrder and this is not
            an OUTER JOIN this Signature can instead be added for an earlier tableOrder (tricky, must not break OUTER JOINs).</remarks>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="inverted">The result of this Signature should be inverted (NOT).</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeAndPeerCondition(VistaDB.Engine.SQL.ConstraintOperations,VistaDB.Engine.SQL.ConstraintOperations.ConstraintAndPeerGroup,System.Boolean)">
            <summary>
            This Signature is a (possibly inverted) peer within an AND peer group and should be added to the peer group
            as a logical condition (was not optimizable).
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="andPeerGroup">The ConstraintAndPeerGroup within which this Signature instance is a peer.</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Signature.OptimizeOrPeerCondition(VistaDB.Engine.SQL.ConstraintOperations,VistaDB.Engine.SQL.ConstraintOperations.ConstraintOrPeerGroup,System.Boolean)">
            <summary>
            This Signature is a (possibly inverted) peer within an OR peer group and should be added to the peer group
            as a logical condition (was not optimizable).
            </summary>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="orPeerGroup">The ConstraintOrPeerGroup within which this Signature instance is a peer.</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.Signature.OptimizableAsConstraint">
            <summary>
            Provided as a hint to new optimization system when a signature derived from an optimizable type is not optimizable
            as a constraint.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.Signature.IsAllowNull">
            <summary>
            Gets whether this signature might produce a null result (true unless set otherwise in a derived class).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.Signature.DataType">
            <summary>
            Result value data type
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.Signature.SignatureType">
            <summary>
            Signature data type
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.Signature.DependencyType">
            <summary>
            DependencyType for this Signature (tree) as determined recursively by a Condense pass during query optimization.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Function.AllowProcedureSyntax">
            <summary>
            Allows inheritors to alter the base parsing of parameters to allow procedure calling syntax (no parentheses).
            </summary>
            <retuns>False by default to require function calling syntax (parentheses).  Override to return true to allow
            procedure calling syntax without parentheses.</retuns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.Function.AllowFunctionSyntax">
            <summary>
            Allows inheritors to alter the base parsing of parameters to block function calling syntax (disallow parentheses).
            </summary>
            <returns>True by default to allow function calling syntax (parentheses).  Override to return false to block
            function calling syntax with parentheses.</returns>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.CLRStoredProcedure.TypesMap">
            <summary>
            Map of internal VistaDBValue types, native .NET system types, and System.Data.SqlTypes types to
            a VistaDBType enum value for the type used to represent the value internally.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.PatternIndexFunction">
            <summary>
            This pattern index function is used within the fulltext search system and the CONTAINS() operator to search it
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.RandFunction.#ctor(VistaDB.Engine.SQL.SQLParser)">
            <summary>
            Parse any parameters and construct a Signature representing the RAND() Function.  
            </summary>
            <remarks>RAND() returns the next FLOAT from the pseudorandom generator for this SQL connection.
            RAND(@seed INT) initializes the generator with a new seed and returns the first FLOAT from it.</remarks>
            <param name="parser"></param>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.NullIfFunction">
            <summary>
            Returns a null value if the two specified expressions are equal. Otherwise the result of evaluating for the first expression
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.ContainsFunction">
            <summary>
            SQL CONTAINS() function for searching FullTextSearch indexes.  We do not support a LOT of the syntax needed.
            Right now we support single word match, and word starts with sequence
            No AND OR NOT logical operators are supported
            TODO: Errors we need to handle
            Keywords not supported - FORMSOF INFLECTIONAL THESAURUS ISABOUT WEIGHT LANGUAGE 
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.ContainsFunction.OptimizeFts(VistaDB.Engine.SQL.Signatures.Signature@,VistaDB.Engine.SQL.Signatures.Signature@)">
            <summary>
            Prepare the common portion of Fts optimization
            </summary>
            <param name="low"></param>
            <param name="high"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.ContainsFunction.IsStopWord(System.String)">
            <summary>
            Determine if this word is categorized as a stop word by the FTSIndex.WordBreaker
            </summary>
            <param name="word">Word to be checked</param>
            <returns>bool - TRUE if the word is marked as a stop word</returns>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.LookupFunction">
            <summary>
            A temporary internal function to experiment with keyed table lookup and caching.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.IValueList">
            <summary>
            An interface for any type of value list which can be tested for whether or not it contains a given (IColumn) value.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Join">
            <summary>
            A base class for all types of JOINed rowsets.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.ExecuteRightRowSet(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Helper method to test for a valid right row match for current left row in INNER or LEFT JOIN and advance until
            a valid row is matched or the right rowset is exhausted.  (Not used for cross join with no ON clause.)
            </summary>
            <param name="constraints"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.Next(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Advance this JOIN rowset to next possible left-right row match (considering constraints) given current row of
            any encapsulating JOIN.
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc)</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.ExecuteRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Check RowAvailable and (if necessary) advance to next matched row to pass all constraints (WHERE and ON clauses).
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc)</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.MarkRowNotAvailable">
            <summary>
            Mark all columns within this JOINed rowset as a null row (in an encapsulating OUTER JOIN).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.Prepare">
            <summary>
            Prepare parsed signature tree for ON clause for evaluation and determine the resulting DataType (must be Bit)
            and SignatureType (constant, etc).  Prepare RowSet and determine resulting schema.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.Optimize(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Optimize the ON clauses of this JOIN and all JOINs under us (recursively) into the constraints collection.
            </summary>
            <param name="constraintOperations">The constraints collection being formed.</param>
            <returns>True if able to optimize all JOINs into the collection.  False if some could not optimize. (?)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.InitOptimization(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Optimize the ON clauses of this JOIN and all JOINs under us (recursively) into the constraints collection
            (for new optimization system).
            </summary>
            <param name="constraintOperations">The constraints collection being formed.</param>
            <returns>True if able to optimize all JOINs into the collection.  False if some could not optimize. (?)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Join.PrepareTables(VistaDB.DDA.IVistaDBTableNameCollection,VistaDB.Engine.Internal.IViewList,VistaDB.Engine.SQL.TableCollection,System.Boolean,System.Int32@)">
            <summary>
            Recursively Prepare all tables within this JOINed rowset.
            </summary>
            <param name="tableNames">The collection of all table names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="views">The collection of all view names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="tableList">Collection of all source tables in this SELECT (etc).  (?)</param>
            <param name="alwaysAllowNull">True if all columns of this JOINed rowset allow NULL in the output schema due to
            an enclosing OUTER JOIN.</param>
            <param name="tableIndex">Reference to the index of the first (left-most) table in this JOINed rowset within the
            tableList collection, and of the next table after this JOINed rowset upon return.</param>
            <returns>This Join instance</returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.Join.RowAvailable">
            <summary>
            Get whether this JOINed RowSet has a row available.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Join.RowUpdated">
            <summary>
            Get whether this JOINed RowSet has changed to a new overall row that has not yet been executed.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Join.OuterRow">
            <summary>
            Get whether this JOINed RowSet is currently a NULL row (in an encapsulating OUTER JOIN ?).
            (False unless overridden in an inheriting OUTER JOIN type.)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.OuterJoin">
            <summary>
            Support for LEFT, RIGHT, and FULL OUTER joins. (new)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.OuterJoin.PrepareTables(VistaDB.DDA.IVistaDBTableNameCollection,VistaDB.Engine.Internal.IViewList,VistaDB.Engine.SQL.TableCollection,System.Boolean,System.Int32@)">
            <summary>
            Recursively Prepare all tables within this JOINed rowset.
            </summary>
            <param name="tableNames">The collection of all table names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="views">The collection of all view names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="tableList">Collection of all source tables in this SELECT (etc).  (?)</param>
            <param name="alwaysAllowNull">True if all columns of this JOINed rowset allow NULL in the output schema due to
            an enclosing OUTER JOIN.</param>
            <param name="tableIndex">Reference to the index of the first (left-most) table in this JOINed rowset within the
            tableList collection, and of the next table after this JOINed rowset upon return.</param>
            <returns>This Join instance</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.OuterJoin.OnExecuteRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Advance to next matched row (could be already on it) to pass all constraints (WHERE and ON clauses).
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc)</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="T:VistaDB.Engine.SQL.LeftJoin">
            <summary>
            A class for LEFT JOIN rowsets.  (Also handles RIGHT JOIN rowsets by swapping left and right sub-rowsets.)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.LeftJoin.PrepareTables(VistaDB.DDA.IVistaDBTableNameCollection,VistaDB.Engine.Internal.IViewList,VistaDB.Engine.SQL.TableCollection,System.Boolean,System.Int32@)">
            <summary>
            Recursively Prepare all tables within this JOINed rowset.
            </summary>
            <param name="tableNames">The collection of all table names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="views">The collection of all view names in the Database (for this Connection).
            (May be passed as null to defer lookup.)</param>
            <param name="tableList">Collection of all source tables in this SELECT (etc).  (?)</param>
            <param name="alwaysAllowNull">True if all columns of this JOINed rowset allow NULL in the output schema due to
            an enclosing OUTER JOIN.</param>
            <param name="tableIndex">Reference to the index of the first (left-most) table in this JOINed rowset within the
            tableList collection, and of the next table after this JOINed rowset upon return.</param>
            <returns>This Join instance</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.LeftJoin.OnExecuteRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Advance to next matched row (could be already on it) to pass all constraints (WHERE and ON clauses).
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc)</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="T:VistaDB.Engine.SQL.InnerJoin">
            <summary>
            A class for INNER JOIN rowsets.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.InnerJoin.OnExecuteRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Advance to next matched row (could be already on it) to pass all constraints (WHERE and ON clauses).
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc)</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.CrossJoin.OnExecuteRowset(VistaDB.Engine.SQL.ConstraintOperations)">
            <summary>
            Advance to next matched row (could be already on it) to pass all constraints (WHERE clause, etc).
            </summary>
            <param name="constraints">The constraints collection (WHERE clause, etc)</param>
            <returns>True if a row is available.  False if no row available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.UnaryOperator.#ctor(VistaDB.Engine.SQL.SQLParser,System.Int32)">
            <summary>
            Base constructor for a unary operator, called from derived classes.
            </summary>
            <param name="parser">The parser instance parsing the expression.</param>
            <param name="priority">The priority limit for the loosest precedence grouping to accept when parsing the
            right operand.  Generally equal to the priority of this operator when parsed with right-to-left grouping
            as required for unary operators.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.UnaryArithmeticOperator.#ctor(VistaDB.Engine.SQL.SQLParser,System.Int32)">
            <summary>
            Base constructor for a unary arithmetic operator, called from derived classes.
            </summary>
            <param name="parser">The parser instance parsing the expression.</param>
            <param name="priority">The priority limit for the loosest precedence grouping to accept when parsing the
            right operand.  Generally equal to the priority of this operator when parsed with right-to-left grouping
            as required for unary operators.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BinaryOperator.#ctor(VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.SQL.SQLParser,System.Int32)">
            <summary>
            Base constructor for a binary operator, called from derived classes.
            </summary>
            <param name="leftOperand">The leftOperand Signature for the operator.</param>
            <param name="parser">The parser instance parsing the expression.</param>
            <param name="priority">The priority limit for the loosest precedence grouping to accept when parsing the
            right operand.  Generally 1 less than the priority of this operator when parsed with left-to-right grouping
            or equal to the priority of this operator when parsed with right-to-left grouping.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BinaryOperator.#ctor(VistaDB.Engine.SQL.Signatures.BinaryOperator,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Base constructor for creating a condensed binary operator (eg. OR, AND) with replacement (condensed) operands.
            (Operands and replacedOperator must already be "prepared".)
            </summary>
            <param name="replacedOperator">The operator that this condensed BinaryOperator is replacing.</param>
            <param name="leftOperand">The new (or original) left operand Signature for this condensed BinaryOperator.</param>
            <param name="rightOperand">The new (or original) right operand Signature for this condensed BinaryOperator.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.ArithmeticP2Operator.#ctor(VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.SQL.SQLParser,System.Int32)">
            <summary>
            Base constructor for a binary operator, called from derived classes.
            </summary>
            <param name="leftOperand">The leftOperand Signature for the operator.</param>
            <param name="parser">The parser instance parsing the expression.</param>
            <param name="priority">The priority limit for the loosest precedence grouping to accept when parsing the
            right operand.  Generally 1 less than the priority of this operator when parsed with left-to-right grouping
            or equal to the priority of this operator when parsed with right-to-left grouping.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BinaryCompareOperator.#ctor(VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.SQL.SQLParser)">
            <summary>
            Base constructor for a binary operator, called from derived classes.
            </summary>
            <param name="leftOperand">The leftOperand Signature for the operator.</param>
            <param name="parser">The parser instance parsing the expression.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BinaryCompareOperator.#ctor(VistaDB.Engine.SQL.Signatures.BinaryCompareOperator,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Base constructor for creating a condensed binary compare operator (eg. IN, NOT IN) with replacement (condensed)
            operands.  (Operands and replacedOperator must already be "prepared".)
            </summary>
            <param name="replacedOperator">The operator that this condensed BinaryOperator is replacing.</param>
            <param name="leftOperand">The new (or original) left operand Signature for this condensed BinaryCompareOperator.</param>
            <param name="rightOperand">The new (or original) right operand Signature for this condensed BinaryCompareOperator.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BinaryCompareOperator.InternalExecute">
            <summary>
            
            </summary>
            <returns>left or right null is followed by resulting null</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BinaryCompareOperator.OnOptimizeTopOnClause(VistaDB.Engine.SQL.ConstraintOperations,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This Signature is ANDed into the top of an ON clause.  Optimizable Signatures should override to add an applicable
            constraint to the collection (and not call this base unless fail as optimized).  All other Signatures (must be
            VistaDBType.Bit) will automatically pass this call over to OnOptimizeLogicalOnCondition instead.
            </summary>
            <remarks>The AND operator Signature should propagate this to its operands by calling
            opSig.OptimizeTopOnClause(...)</remarks>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="lowTableOrder">The minimum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="highTableOrder">The maximum table CollectionOrder of the SourceTable(s) joined in by the particular
            JOIN whose ON clause is being processed.</param>
            <param name="isOuterJoin">True if this is for an OUTER JOIN.  False for an INNER JOIN or CROSS JOIN (etc).</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BinaryCompareOperator.OnOptimizeTopWhereClause(VistaDB.Engine.SQL.ConstraintOperations,System.Boolean)">
            <summary>
            This Signature is ANDed into the top of a WHERE clause.  Optimizable Signatures should override to add an applicable
            constraint to the collection (and not call this base unless fail as optimized).  All other Signatures (must be
            VistaDBType.Bit) will automatically pass this call over to OnOptimizeLogicalOnCondition instead.
            </summary>
            <remarks>The AND operator Signature should propagate this to its operands by calling
            opSig.OptimizeTopWhereClause(...)</remarks>
            <param name="constraintOperations">The ConstraintOperations collection being built.</param>
            <param name="inverted">Indicates whether the logical sense of this Signature must be inverted.</param>
            <returns>True if successfully added to the collection.  False if not completely (?) successful.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.InOperator.CreateCondensedInOperator(VistaDB.Engine.SQL.Signatures.InOperator,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Create a new InOperator (or NotInOperator) with condensed (new) operands.
            (Operands and replacedOperator must already be "prepared".)
            </summary>
            <param name="replacedOperator">The InOperator or NotInOperator being replaced.</param>
            <param name="leftOperand">The new (or original) left operand Signature for the condensed InOperator.</param>
            <param name="rightOperand">The new (or original) right operand Signature for the condensed InOperator.</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.NotInOperator.CreateCondensedNotInOperator(VistaDB.Engine.SQL.Signatures.NotInOperator,VistaDB.Engine.SQL.Signatures.Signature,VistaDB.Engine.SQL.Signatures.Signature)">
            <summary>
            Create a new NotInOperator with condensed (new) operands.  (Normally, use InOperator.CreateCondensedInOperator()
            instead.)  (Operands and replacedOperator must already be "prepared".)
            </summary>
            <param name="replacedOperator">The InOperator or NotInOperator being replaced.</param>
            <param name="leftOperand">The new (or original) left operand Signature for the condensed InOperator.</param>
            <param name="rightOperand">The new (or original) right operand Signature for the condensed InOperator.</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.LikeOperator.GenerateConstraints(System.Int32,System.Int32,System.Boolean,System.Int32@,VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint@,VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint@)">
            <summary>
            Performs common logic to generate constraints, if possible. (New optimization)
            </summary>
            <param name="lowTableOrder">The minumum tableOrder constraints can be made for in this context.</param>
            <param name="highTableOrder">The maxumum tableOrder constraints can be made for in this context.</param>
            <param name="inverted">Whether this operator needs to be inverted (NOT) in this context.</param>
            <param name="chunkCount">Outputs the number of "chunks" found in the pattern. 1: Exact match.
            More than 1: Prefix match.</param>
            <param name="lowerConstraint">The constraint for the lower-bound of a prefix match, or the
            exact-match constraint.</param>
            <param name="upperConstraint">The constraint for the upper-bound of a prefix match, or null
            when an exact-match applies.</param>
            <returns>True if constraints could be generated.  False if constraints could not be generated.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.BetweenOperator.GenerateConstraints(System.Int32,System.Int32,System.Boolean,VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint@,VistaDB.Engine.SQL.ConstraintOperations.TableColumnConstraint@)">
            <summary>
            Performs common logic to generate constraints, if possible. (New optimization)
            </summary>
            <param name="lowTableOrder">The minimum tableOrder being optimized, or -1 if severable to any tableOrder.</param>
            <param name="highTableOrder">The maximum tableOrder being optimized, or -1 if severable to any tableOrder.</param>
            <param name="inverted">Whether this operator needs to be inverted (NOT) in this context.</param>
            <param name="leftConstraint">Outputs the constraint for the comparison to the left endpoint operand,
            or null if not possible.</param>
            <param name="rightConstraint">Outputs the constraints for the comparison to the right endpoing operand,
            or null if not possible.</param>
            <returns>True if one or both constraints could be generated (also check for individual null constraints).
            False if no constraints could be generated.</returns>
        </member>
        <member name="T:VistaDB.Engine.Internal.IParameterScope">
            <summary>
            SQL query interface
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.SetCompatibilityMode(VistaDB.Provider.VistaDBConnection.CompatibilityMode)">
            <summary>
            Set the CompatibilityMode in this SQLParser intance to reflect the mode for this connection.
            (Only call while parser is idle--such as when reinitializing a pooled connection.)
            </summary>
            <param name="compatibilityMode"></param>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.NextSignature(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Parse the next expression Signature within the specified operator precedence priority level.
            </summary>
            <param name="needSkip">True to skip to next token first.  False to start with current token.</param>
            <param name="raiseException">True to raiseException upon end of query text.  False if error should not be
            raised if end of query text is reached before or after parsing the next Signature.</param>
            <param name="priority">The operator precedence priority level (or -1 for a new sub-expression, such as
            within parentheses).</param>
            <returns>The top of the Signature tree for the expression.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ExpectedExpression(System.String,System.String[])">
            <summary>
            Check if current token matches an expected given token keyword (any TokenType except string)
            and throw an error if it is not (listing optional alternatives).
            </summary>
            <param name="expression">The token keyword to match.</param>
            <param name="alternative">Optional additional keywords which would also be accepted at this point to list
            in the error (not checked against the current token; should have already been checked for).</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.IsToken(System.String)">
            <summary>
            Tests if current token matches the given token keyword (any TokenType except String)
            by ordinal comparison ignoring case.
            </summary>
            <param name="expression">The token keyword to match.</param>
            <returns>True if matched.  False if not a match.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.TokenEndsWith(System.String)">
            <summary>
            Tests if current token ends with the given suffix (any TokenType except String)
            by ordinal comparison ignoring case.
            </summary>
            <param name="expression">The token suffix to match.</param>
            <returns>True if matched.  False if not a match.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.CreateSpecialFunction(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Parse any parameters for a table-valued function call and return an ITableValuedFunction Signature instance
            representing the table result.
            </summary>
            <param name="name">The function name (special function or user-defined table-valued function).</param>
            <param name="rowNo">The rowNo of the function reference.</param>
            <param name="colNo">The colNo of the function reference.</param>
            <param name="symbolNo">The symbolNo position of the function reference.</param>
            <returns>An ITableValuedFunction instance representing the table result of the function call.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.CheckVariableName">
            <summary>
            Check if current token is a valid variable/parameter name format and throw an error if it fails.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.SkipSemicolons">
            <summary>
            Skip current token if it is a semicolon, and skip any further semicolon tokens to parse next meaningful token.
            </summary>
            <returns>True if the end of the query text is reached (no further token).  False if another token is available.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.SuppressNextSkipToken">
            <summary>
            Hack suppression of the next SkipToken() so that it results in the token we are already on.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.SkipToken(System.Boolean)">
            <summary>
            Skip past current token and parse next token (if any).
            </summary>
            <param name="raiseException">True to throw error if text ends before an expected next token.  False if error
            should not be thrown here at end of text.</param>
            <returns>True if next token is available.  False if text ends and there is no next token (and raiseException is
            false; otherwise throws error).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ReadBinary">
            <summary>
            Read a hexadecimal number starting from a discovered 0x or 0X prefix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ReadString(System.Char)">
            <summary>
            Read a string literal starting from a discovered single-quote character ( ' ).
            </summary>
            <param name="c">The starting character (currently ignored and will be skipped without checking).</param>
            <returns>TokenType.String if successful (throws exception on error).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ReadNumeric(System.Char)">
            <summary>
            Read a (decimal) numeric token starting from a discovered decimal point or digit (and not a 0x/0X prefix).
            </summary>
            <param name="c">The current symbol (to distinguish a starting decimal point as a Float vs Integer).</param>
            <returns>TokenType.Float if the token is any floating-point format (decimal point and/or exponential notation).
            TokenType.Integer if the token is an integer.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ReadUnknown(System.Char,System.Boolean@)">
            <summary>
            Read an alphanumeric word which does not start with any quote or special characters.  (IncrementSymbolNo()
            performed to start.)
            </summary>
            <param name="c">The first character of the word--and current symbol--which should have already been checked
            before calling.</param>
            <param name="doNotCheckAlias">Reference to the flag in SkipToken() ultimately passed to tokenValue.SetToken()
            which indicates whether the token is a quoted identifier (true) and allowed to contain a reserved word.  This
            method always sets it to false unless a dot and quoted name part is encountered.</param>
            <returns>The TokenType, either Unknown or ComplexName.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ReadName(System.Char,System.Boolean@)">
            <summary>
            Read a name reference which starts with an identifier quote (either [ or ") as the current symbol.
            (IncrementSymbolNo() performed to start)
            </summary>
            <param name="c">The starting quote character (current symbol).</param>
            <param name="doNotCheckAlias">Reference to the flag in SkipToken() ultimately passed to tokenValue.SetToken()
            which indicates whether the token is a quoted identifier (true) and allowed to contain a reserved word.  This
            method always sets it to true (unless errors out first).</param>
            <returns>The TokenType, either Name (single part) or ComplexName (multiple parts).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.SkipComments">
            <summary>
            Skip past whitespace and one possible comment (either /*...*/ or --to EOL).
            </summary>
            <returns>True if one comment was skipped (so call again).  False if no comment was encountered (ready to parse
            next token from current symbol).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.SkipSpaces">
            <summary>
            Skip over spaces, tabs, and control characters (including line breaks) to next non-whitespace symbol.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.IncrementSymbolNo(System.Boolean)">
            <summary>
            Advance to next symbol in text and handle special cases of tabs and line-break symbols.
            </summary>
            <param name="addNewLineLen">True if scanning a string literal and need to count exact length.  False if scanning
            outside a quoted string and line-breaks aren't counted in length of current token because they end it.</param>
            <returns>True if a non-special (tab or line-break) special symbol is next.  False if a tab or line-break was
            encountered and potentially ends the current token.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.IsLetter(System.Char)">
            <summary>
            Is given character a valid identifier character (excluding digits; see IsNumeric).
            </summary>
            <param name="c">The given character to check.</param>
            <returns>True if given character is a letter, underscore, @ symbol, or dot.  Otherwise false.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.IsNumeric(System.Char)">
            <summary>
            Is given character a valid decimal digit.
            </summary>
            <param name="c">The given character to check.</param>
            <returns>True if given charcter is a digit (0-9).  Otherwise false.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.IsNumericExt(System.Char)">
            <summary>
            Is given character a possible numeric or extension character for exponential notation.
            </summary>
            <param name="c">The given character to check.</param>
            <returns>True if given character is a digit, decimal point (dot), e, E, +, or -.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.IsHex(System.Char)">
            <summary>
            Is given character a valid hexadecimal digit.
            </summary>
            <param name="c">The given character to check.</param>
            <returns>True if given character is a valid hex digit (0-9 or a-f or A-F)</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ParsePriority(System.Int32)">
            <summary>
            Parse the sub-expression within the current operator precedence priority level starting with the current token.
            </summary>
            <param name="priority">The operator precedence priority level for the target sub-expression
            (lower numbers mean more-immediate grouping).</param>
            <returns>The top of the Signature tree for the sub-expression.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ParseExpressions">
            <summary>
            Parse one top-level expression (recursively) of any Signature type.
            </summary>
            <returns>The top of the Signature tree for the expression.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SQLParser.ParseComplexName(System.String@)">
            <summary>
            Parse complex or simple name. E.g. [tableName].[columnName]
            </summary>
            <param name="objectName">the object name</param>
            <returns>namespace the </returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.SQLParser.IsLegacyMode">
            <summary>
            Gets whether the connection was opened with CompatibilityMode="Legacy".
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SQLParser.IsStrictMode">
            <summary>
            Gets whether the connection was opened with CompatibilityMode="Strict".
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.PatternFinder.#ctor(System.String,VistaDB.Engine.Internal.LocalSQLConnection)">
            <summary>
            Internal constructor for Contains function
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.PatternFinder.GetOptimizationLevel(System.Int32@)">
            <summary>
            Determines optimization level possible (for current logic) for the current parsed pattern value and outputs
            the count of "chunks" (pattern tokens) to guide optimization usage.
            </summary>
            <param name="chunkCount">Outputs the number of "chunks" (pattern tokens).  0 indicates a match-all case,
            1 indicates an exact match case, and &gt; 1 indicates wildcards following some matchable prefix (if return
            indicates Full optimization).</param>
            <returns>OptimizationLevel.Full if pattern can be optimized with an index search on one or two constraints,
            or OptimizationLevel.None if pattern can only be tested against.  (Could return OptimizationLevel.Part to
            indicate a partial optimization requiring evaluation as well, but this case is not currently used.)</returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.PatternFinder.AlwaysMatch">
            <summary>
            Does this PatternFinder always match against any non-NULL?
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.StoredProcedure.CheckInheritSprocParams">
            <summary>
            Determines whether a sproc call should inherit parameters from the outer calling scope (true) or only from
            its inline arguments and Default values.
            </summary>
            <returns>True if outer calling scope variables should be checked.  False if outer calling scope should not
            be checked.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.BatchStatement.OnExecuteQuery">
            <summary>
            This method may be called by nested batch operations, 
            IF statement, WHILE statement and Stored Procedures
            </summary>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Engine.SQL.BatchStatement.ReturnParamCascade">
            <summary>
            Controls whether the current batch should cascade the request for a ReturnParameter to its parent batch
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.BatchStatement.IsSprocCommand">
            <summary>
            Indicates that this BatchStatement was called as a CommandType.StoredProcedure and contains parameters intended for
            the enclosed sproc call (true) as opposed to a CommandType.Text query which only passes parameters inline (false).
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.BatchStatement.ResultSetData">
            <summary>
            The universal result of statement execution. For INSERT/DELETE/UPDATE
            the result doesn't include resultSet and schema
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.BatchStatement.ResultSetData.resultSet">
            <summary>
            The result of statement execution as a resultSet. This may be null if nothing was returned.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.BatchStatement.ResultSetData.schema">
            <summary>
            The result set schema
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.BatchStatement.ResultSetData.affectedRows">
            <summary>
            The number of modified rows
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SelectStatement.FindReplaceableLookupTables(VistaDB.Engine.SQL.IRowSet,System.Collections.Generic.Dictionary{System.String,VistaDB.Engine.SQL.SourceTable},System.Boolean)">
            <summary>
            Process a join tree, node, or leaf table for cached-lookup-table replacement.
            </summary>
            <param name="currentRowset">The current node to walk or leaf to process.</param>
            <param name="candidates">The collection of candidate tables to optimize as a cached lookup table.</param>
            <param name="leftmost">Whether currentRowset is the leftmost at this tree level or is down a right-hand branch.</param>
            <returns>True if the reference to the node needs to be removed from the parent.</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SelectStatement.IsLiveQuery">
            <summary>
            This SELECT is (possibly) a "Live" query if there is a FROM rowset, it has no aggregate functions, it has no
            UNION applied, there is no addRowMethod (?), it is not selecting DISTINCT rows, and it either has no ORDER BY
            or is able to completely optimize ORDER BY.
            </summary>
            <returns>True if this SELECT does not require spooling and additional processing and can directly return
            live rows from the rowset as they are accepted by the query.  False if spooling and additonal processing
            is required or if it selects just a single row of values (no FROM rowset).</returns>
            <remarks>Prior to execution this returns true if it is still <i>possible</i> as a live query.  Once execution
            has been started this returns true if a live query ended up being possible and is a definitive answer.</remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.SelectStatement.IsDefiniteLiveQuery">
            <summary>
            This SELECT is definitely a "Live" query if there is a FROM rowset, it has no aggregate functions, it has no
            ORDER BY columns, it has no UNION applied, there is no addRowMethod (?), and it is not selecting DISTINCT rows.
            </summary>
            <returns>True if this SELECT does not require spooling and additional processing and can directly return
            live rows from the rowset as they are accepted by the query.  False if spooling and additonal processing
            is required or if it selects just a single row of values (no FROM rowset).</returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SelectStatement.TryAsLiveQuery">
            <summary>
            Perform enough of initial execution (PreExecute() and optimization initialization) to determine if a live query
            is possible.  (This method will check IsLiveQuery() first and immediately return if false.)
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.SelectStatement.FirstRow">
            <summary>
            Start the SELECT and go to the first accepted row (if any).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SelectStatement.NextRow">
            <summary>
            Advance the SELECT to the next accepted row (if any).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SelectStatement.CacheFactory">
            <summary>
            (Is this needed?)  Ultimately, this should go away in favor of safer method calls.
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.SelectStatement.AggregateFunctionCount">
            <summary>
            Returns the count of aggregates functions used by this select satement. Used by The Count Aggregate to determine optimization potential.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.SelectStatement.ResultColumn.ReplaceSignature(VistaDB.Engine.Internal.QuickJoinLookupColumn)">
            <summary>
            This is a hack to replace the ColumnSignature with a QuickJoinLookupColumn. (This should go away in the long run.)
            </summary>
            <param name="newColumnSignature"></param>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.ConstantSignature">
            <summary>
            Signature with constant result
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.ConstantSignature.InternalExecute">
            <summary>
            Result value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.ConstantSignature.OnPrepare">
            <summary>
            Prepare signature
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.ColumnSignature">
            <summary>
            Signature with column value result
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.ColumnSignature.table">
            <summary>
            Source table
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.ColumnSignature.columnIndex">
            <summary>
            Source row index
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.ColumnSignature.columnName">
            <summary>
            Column name
            </summary>
        </member>
        <member name="F:VistaDB.Engine.SQL.Signatures.ColumnSignature.tableVersion">
            <summary>
            Replicates data version of table and used to check current up to date status for the column
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.ColumnSignature.InternalExecute">
            <summary>
            Result value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.ColumnSignature.OnPrepare">
            <summary>
            Prepare signature
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.ColumnSignature.TableVersion">
            <summary>
            Gets the Version of the table data held in this column instance (or -1 if it has changed for this instance).
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.ColumnSignature.ColumnName">
            <summary>
            Column name
            </summary>
        </member>
        <member name="P:VistaDB.Engine.SQL.Signatures.ColumnSignature.TableAlias">
            <summary>
            Table name
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.Priority0Descr">
            <summary>
            Base priority class for unary numeric/bitwise and exists operators.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.Priority1Descr">
            <summary>
            Base priority class for binary multiplicative operators.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.Priority2Descr">
            <summary>
            Base priority class for binary addative and bitwise operators.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.Priority3Descr">
            <summary>
            Base priority class for comparative operators.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.EntityTableValuedFunction">
            <summary>
            An abstract base class to use for convenience in creating table-valued functions to be called by
            Entity Framework to obtain schema details.
            </summary>
            <remarks>Derived classes must implement a derived constructor (calling the base constructor) and override
            implementations of FillRow and ExecuteSubProgram() (neither base method needs to be called).  See summary and
            remarks on these methods for further implementation details.
            </remarks>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.EntityTableValuedFunction.#ctor(VistaDB.Engine.SQL.SQLParser,System.Int32,System.Int32)">
            <summary>
            Base constructor must be called by a derived constructor specifying the expected parameter count
            (often 0) and result table column count, and then assign names and types for the result table schema.
            </summary>
            <remarks>The underlying base class (SpecialFunction) will allocate the member arrays resultColumnNames and
            resultColumnTypes.  The derived constructor must fill in the appropriate values for the number of columns
            specified to the base class as columnCount.  The derived constructor should also perform validation of the
            parsed ParamCount against expectations and throw an error if appropriate; the SQL function name defined
            in the parser should be passed as a hint in the exception. <see cref="T:VistaDB.Engine.SQL.Signatures.SpStoredProcedures"/>
            </remarks>
            <param name="parser">The SQLParser creating this function instance.</param>
            <param name="paramCount">The expected parameter count being parsed for this function.</param>
            <param name="columnCount">The number of columns to allocate in the result set table for this function.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.EntityTableValuedFunction.FillRow(VistaDB.Engine.Internal.IRow,System.Object)">
            <summary>
            Overridden by an inheritor to insert values into the provided IRow object based on the currentEntry
            from the established enumerator.
            </summary>
            <param name="row">The target IRow matching the previously-established schema in which to set values for
            the current row of the result set table based on the provided currentEntry object.</param>
            <param name="currentEntry">The currentEntry object from the established enumerator whose content
            assists in determining the values for the current row of the result set table.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.EntityTableValuedFunction.ExecuteSubProgram">
            <summary>
            Derived class is responsible for creating an IEnumerator (and assigning to this.enumerator) when this
            virtual method is called.  DO NOT CALL THIS BASE METHOD from an overriding implementation.
            </summary>
            <remarks>This virtual method is automatically called by the underlying base class (SpecialFunction)
            when ITableValuedFunction.Open() is called on an instance.</remarks>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.EntityTableValuedFunction.FillColumnValues(VistaDB.DDA.IVistaDBColumnAttributes,System.Object[])">
            <summary>
            Fill an object[5] array with the key information from the IVistaDBColumnAttributes for a column.
            </summary>
            <param name="column">The IVistaDBColumnAttributes for the relevant column.</param>
            <param name="values">An object[5] array to hold the values.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.EntityTableValuedFunction.FillColumnSchema(System.Object[],VistaDB.Engine.Internal.IRow,System.Int32)">
            <summary>
            Fill a provided IRow with the 14 values of common schema info for a column starting at a specified offset in the
            IRow, taking the column attribute values from a provided object[5] array (as filled in by FillColumnValues()).
            </summary>
            <param name="values">An object[5] array with the column attribute values (as filled in by
            FillColumnValues()).</param>
            <param name="row">The IRow to fill starting at the specified offset index position.</param>
            <param name="offset">The offset index position in the IRow at which to start filling in
            with the column name, etc.</param>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.EntityTableValuedFunction.FillColumnSchema(System.String,System.Int32,System.Boolean,VistaDB.VistaDBType,System.Int32,VistaDB.Engine.Internal.IRow,System.Int32)">
            <summary>
            Fill a provided IRow with the 14 values of common schema info for a column starting at a specified offset
            in the IRow.
            </summary>
            <param name="name"></param>
            <param name="index"></param>
            <param name="allowNull"></param>
            <param name="type"></param>
            <param name="maxLength"></param>
            <param name="row"></param>
            <param name="offset">The offset index of the column in the IRow to start filling in with the
            column name, etc.</param>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4Tables">
            <summary>
            A class implementing special table-valued function VistaDBEF4Tables() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4TableColumns">
            <summary>
            A class implementing special table-valued function VistaDBEF4TableColumns() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4Views">
            <summary>
            A class implementing special table-valued function VistaDBEF4Views() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4ViewColumns">
            <summary>
            A class implementing special table-valued function VistaDBEF4ViewColumns() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4Constraints">
            <summary>
            A class implementing special table-valued function VistaDBEF4Constraints() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4ConstraintColumns">
            <summary>
            A class implementing special table-valued function VistaDBEF4ConstraintColumns() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4FkConstraints">
            <summary>
            A class implementing special table-valued function VistaDBEF4FKConstraints() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="T:VistaDB.Engine.SQL.Signatures.VistadbEntity4ForeignKeys">
            <summary>
            A class implementing special table-valued function VistaDBEF4ForeignKeys() for EntityFramework 4 (and 5). (6 ???)
            </summary>
        </member>
        <member name="M:VistaDB.Engine.SQL.Signatures.SubQuerySignature.IsValuePresent(VistaDB.Engine.Internal.IColumn,System.Boolean,VistaDB.Engine.Internal.CompareOperation)">
            operation:
            -1 val must be less then other values
            
        </member>
        <member name="T:VistaDB.Diagnostic.Errors">
            <summary>
            The collection of error string messages raised by VistaDB library
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.Nonsupported">
            <summary>
            Method or property not supported
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NonSupportedFileExtension">
            <summary>
            Database file extension not supported
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.lic_Invalid">
            <summary>
            License file appears to be corrupt or invalid - NOT used by the runtime engine - only the GUI designers and setup apps
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.lic_WrongVersion">
            <summary>
            The license file is for another version of VistaDB
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UpdateSpecification">
            <summary>
            Database specification changed. Pack is required to update database schema.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidVDBFormat">
            <summary>
            File is not a valid VistaDB 4 database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UpdateFTSSpecification">
            <summary>
            FullTextSearch index specification changed. Pack database to update
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidPageSize">
            <summary>
            Files page size is not in the allowable range. Pack is required to change page size.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NewerSpecification">
            <summary>
            Database specification is newer than what this version supports. Database cannot be used.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateStorage">
            <summary>
            Cannot create data storage or file
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_OpenStorage">
            <summary>
            Cannot open data storage or file
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateHeader">
            <summary>
            Cannot create data storage header
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateHeader">
            <summary>
            Cannot activate data storage header
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateHeaderStructure">
            <summary>
            Cannot initialize header data
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ReadHeader">
            <summary>
            Cannot read header
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_WriteHeader">
            <summary>
            Cannot write header
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AllocateRowStructure">
            <summary>
            Allocate row structure in data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_StorageReadOnlyMode">
            <summary>
            Incompatible mode. Database storage is read-only. You cannot access it for write operations
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_RowsetExlusiveMode">
            <summary>
            Incompatible mode. There is exclusive table instance already opened
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ReadStorage">
            <summary>
            Cannot read data storage or file
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_WriteStorage">
            <summary>
            Cannot write data storage or file
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DatastorageDeclaration">
            <summary>
            Cannot declare new data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateDatabase">
            <summary>
            Cannot create database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateIsolatedDatabase">
            <summary>
            Cannot create database in isolated storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateTemporaryDatabase">
            <summary>
            Cannot create temporary database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_EncryptionKeyInvalid">
            <summary>
            Invalid encryption key. Cannot decrypt database data.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_OpenDatabase">
            <summary>
            Cannot open database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_OpenIsolatedDatabase">
            <summary>
            Cannot open database in isolated storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateTable">
            <summary>
            Cannot create table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AlterTable">
            <summary>
            Cannot rename or alter table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DropTable">
            <summary>
            Cannot drop table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_TableToDropOpened">
            <summary>
            Table is opened and cannot be dropped at current moment
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateTableHeader">
            <summary>
            Cannot create table header
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_EmptyTableSchema">
            <summary>
            At least one column should be created in the table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_OpenTable">
            <summary>
            Cannot open table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NonExistedTable">
            <summary>
            Table is not found
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NonExistedIndex">
            <summary>
            Index is not found
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CloseTable">
            <summary>
            An error happened while table was being closed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CloseStorage">
            <summary>
            An error happened while data storage was being closed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateIndex">
            <summary>
            Cannot create index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DropIndex">
            <summary>
            Cannot delete index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CannotDropFKIndex">
            <summary>
            Cannot explicitly delete foreign key index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_EmptyIndexInformation">
            <summary>
            Index information absent
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateIndex">
            <summary>
            Cannot activate index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateDatabase">
            <summary>
            Cannot activate database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DeactivateIndex">
            <summary>
            Index deactivation
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateDefaultRow">
            <summary>
            Cannot create default values in table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateDefaultRow">
            <summary>
            Cannot initialize default values in table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateNodeAtPosition">
            <summary>
            Cannot access node at position
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SchemaChanges">
            <summary>
            Schema was changed by another instance. Data storage must be reopened
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CompactFrameworkMode">
            <summary>
            You cannot use this database opening mode on Compact Framework
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PrimaryKeyContainsNull">
            <summary>
            Primary key cannot contains column with null value
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PrimaryKeySingle">
            <summary>
            The primary key already exists. Only one primary key index allowed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PrimaryKeyRefencedInDelete">
            <summary>
            Table contains primary key referenced and cannot be deleted
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateTableName">
            <summary>
            Duplicate table name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateIndexName">
            <summary>
            Duplicate index name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateColumnName">
            <summary>
            Duplicate Column name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PerColumnEncryptionType">
            <summary>
            Older database file format uses a per-column encryption type.
            </summary>
            <remarks>Overlaps with obsolete value 148, but this is only used internally, anyway.</remarks>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IndexKeyColumnCountExceeds">
            <summary>
            Index key column count exceeds maximum allowed count
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IndexKeyColumnInvalid">
            <summary>
            Index key cannot contain the column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_WrongBlockEncryptionType">
            <summary>
            Database open attempted with a different encryption algorithm than used in the database file.
            </summary>
            <remarks>Overlaps with obsolete value 151, but this is only used internally, anyway.</remarks>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidName">
            <summary>
            Invalid name or alias
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ColumnType">
            <summary>
            Unsupported VistaDB type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_MaximumColumns">
            <summary>
            Column number exceeds maximum allowed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_FtsActiveIndex">
            <summary>
            Full text index cannot be made active
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_FullTextSingle">
            <summary>
            The full text index already exists. Only one full text index allowed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateTimestamp">
            <summary>
            Row cannot contain two and more columns with same VistaDB.Timestamp data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IsolateStorageAccessMode">
            <summary>
            Isolated database does not support access mode
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CannotRenameFKIndex">
            <summary>
            Cannot rename foreign key index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateLockPolicy">
            <summary>
            Storage cannot activate lock policy
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_LockStorage">
            <summary>
            Cannot lock data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_LockStreamPosition">
            <summary>
            Cannot lock file position
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_LockTimeout">
            <summary>
            Lock timeout expired
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_LockRow">
            <summary>
            Cannot lock row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UnlockRow">
            <summary>
            Cannot unlock row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ReleaseLocks">
            <summary>
            Cannot release locks
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_RowExceedsPage">
            <summary>
            Row data size will exceed a single page in the database.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_Filter">
            <summary>
            Cannot pass over expression filter statement
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DefaultValueFault">
            <summary>
            Cannot execute default value generator
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ConstraintFault">
            <summary>
            Cannot pass constraint
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ReadonlyFault">
            <summary>
            Column marked as readonly
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NullFault">
            <summary>
            Column cannot contain null value
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NonSupportedDataType">
            <summary>
            Operation PutFromFile/GetToFile is not supported for data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_TableClosed">
            <summary>
            Cannot access closed table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidColumnByName">
            <summary>
            Cannot find the column specified by name. Verify the column exists in target table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidColumnByIndex">
            <summary>
            Cannot get column by index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NullValue">
            <summary>
            Column value is null
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IdentityExist">
            <summary>
            Identity assigned to the column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IdentityNonExist">
            <summary>
            Identity does not exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SetIdentity">
            <summary>
            Cannot create identity
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DropIdentity">
            <summary>
            Cannot drop identity
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SeedNullValue">
            <summary>
            Seed value cannot be null
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_StepNullValue">
            <summary>
            Step value cannot be null
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidIdentityStep">
            <summary>
            Invalid step value
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NonSupportedIdentity">
            <summary>
            Column data type is not supported by identity
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DefaultValueNonExist">
            <summary>
            Default value script has not been assigned to column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SetDefaultValue">
            <summary>
            Cannot assign default value script for column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DropDefaultValue">
            <summary>
            Cannot drop default value script for column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ConstraintNotExist">
            <summary>
            Constraint is not existing
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SetConstraint">
            <summary>
            Cannot set constraint
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DropConstraint">
            <summary>
            Cannot delete constraint
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NonSupportedDefaultValue">
            <summary>
            Column data type is not supported by default value expression
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PrimaryKeyReferenced">
            <summary>
            Primary key is referenced by foreign key constraint
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateForeignKey">
            <summary>
            Cannot set foreign key constraint
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DropForeignKey">
            <summary>
            Cannot drop foreign key constraint
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PrimaryKeyNotFound">
            <summary>
            Primary key is not existing in table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PrimaryKeyCannotBeSelfReferenced">
            <summary>
            Foreign key cannot relate to primary key
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_RelationshipExist">
            <summary>
            Relationship with same name exists
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_RelationshipDoesNotExist">
            <summary>
            Relationship does not exists
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PrimaryKeyIdenticalForeignKey">
            <summary>
            Parent key and child key are identical
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AlterSystemColumn">
            <summary>
            Cannot alter or drop system column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ModifySystemTable">
            <summary>
            Cannot modify table structure or data in the table. The table is used by VistaDB core
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DropSyncTable">
            <summary>
            Table is used by sync service and cannot be dropped
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateSyncService">
            <summary>
            Cannot activate sync service for table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DeactivateSyncService">
            <summary>
            Cannot deactivate sync service for table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_TombstoneName">
            <summary>
            Cannot apply tombstone table name. The table with same name already exists
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AnchorTablename">
            <summary>
            Cannot apply name for anchor table. The table with same name already exists
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateRow">
            <summary>
            Cannot create row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UpdateRow">
            <summary>
            Cannot update row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DeleteRow">
            <summary>
            Cannot delete row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ActivateLink">
            <summary>
            Cannot activate link
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateLink">
            <summary>
            Cannot create link
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateLinks">
            <summary>
            Cannot create linked data
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UpdateLink">
            <summary>
            Cannot update link
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UpdateLinks">
            <summary>
            Cannot update linked data
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DeleteLink">
            <summary>
            Cannot delete link
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DeleteLinks">
            <summary>
            Cannot delete linked data
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidRowInUpdate">
            <summary>
            Trying to update inaccessible row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidRowInDelete">
            <summary>
            Trying to delete inaccessible row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_RowOutdated">
            <summary>
            Row is modified or deleted by another thread or process
            </summary>
            <remarks>This error may happen while the reading of the Text, NText or Image
            column is postponed and not happend at the moment of reading the main row buffer. 
            In such case the engine core ensures the possibility to read an external data buffer 
            containing content of the column.</remarks>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CannotFindKey">
            <summary>
            Find key procedure cannot be executed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CannotSynchKey">
            <summary>
            Cannot synchronize key position
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidOrderToFindKey">
            <summary>
            Invalid index to look for key
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IncorrectString">
            <summary>
            The string expression or object name is null reference or empty
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CompileExpression">
            <summary>
            Cannot compile expression
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CompileKeyExpression">
            <summary>
            Cannot compile index key expression
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidExpression">
            <summary>
            Invalid expression
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ParenthesisMismatch">
            <summary>
            Parenthesis mismatch
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidDelimiter">
            <summary>
            Invalid delimiter
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidParameter">
            <summary>
            Invalid parameter or parameter type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_VDBType">
            <summary>
            Incorrect parameter type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ExpressionTypeCheck">
            <summary>
            Cannot match data types in expression or v-function signature
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidLogicalExpression">
            <summary>
            Expression should be logical
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_EvaluateOperator">
            <summary>
            Cannot evaluate operator
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidIfElse">
            <summary>
            Invalid If-Else group
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UnexpectedThen">
            <summary>
            Unexpected Then
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_UnexpectedElse">
            <summary>
            Unexpected Else
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_MissingStringDelimiter">
            <summary>
            String constant has no end delimiter
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IncompleteExpression">
            <summary>
            Incomplete expression
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidOperation">
            <summary>
            Invalid operation
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidFloatFormat">
            <summary>
            Invalid float number format
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DynamicRange">
            <summary>
            Value exceeds dynamic range of the data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_StringExceedMaximum">
            <summary>
            Character column data exceeds maximum length
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DatatypeConversion">
            <summary>
            Cannot convert data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidCharLength">
            <summary>
            Data type maximum length should be between 1 and max length 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidPageCount">
            <summary>
            Invalid page count request to allocate by extended column data
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InitSpool">
            <summary>
            Cannot initialize sort spool
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_EvaluateKey">
            <summary>
            Cannot evaluate index key
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_EvaluateExpression">
            <summary>
            Cannot evaluate expression
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateKey">
            <summary>
            Duplicate key found in index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CannotAssignEnvironmentVariable">
            <summary>
            Cannot assign environment variable
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CannotAlterRelationship">
            <summary>
            Cannot alter relationships in table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NodeEncryption">
            <summary>
            Cannot encrypt node
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NodeDecryption">
            <summary>
            Cannot decrypt node
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DataImport">
            <summary>
            Cannot import data from data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DataExport">
            <summary>
            Cannot export data to data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PackStorage">
            <summary>
            Cannot pack data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ZapStorage">
            <summary>
            Cannot delete all rows in data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PackDatabase">
            <summary>
            Cannot pack database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ReadOnlyMode">
            <summary>
            Operation cannot be applied in read-only data storage mode
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SharedMode">
            <summary>
            Operation cannot be applied in shared data storage mode
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CleanStorage">
            <summary>
            Cannot clean up data storage
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_BeforeInsertingRow">
            <summary>
            Cannot execute script before inserting a new row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AfterInsertingRow">
            <summary>
            Cannot execute script after inserting a new row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_BeforeUpdatingRow">
            <summary>
            Cannot execute script before updating row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AfterUpdatingRow">
            <summary>
            Cannot execute script after updating row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AfterDeletingRow">
            <summary>
            Cannot execute script after deleting row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InitRecycling">
            <summary>
            Cannot initialize recycling
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_PackViaDDA">
            <summary>
            The specified database cannot be packed via a VistaDBConnection object.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ExportTable">
            <summary>
            Cannot export table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_InvalidClrProcedureName">
            <summary>
            Name of CLR Proc with public static attributes not found
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateClrProcedureName">
            <summary>
            Duplicate CLR Proc name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ParametersNumberInClrProcedure">
            <summary>
            Invalid parameters number passed to invoke Clr Procedure
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrProcedureNotRegistered">
            <summary>
            The CLR Proc is not registered in database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrProcedureFillRowNotRegistered">
            <summary>
            The helper FillRow CLR Proc is not registered in database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrProcedureReferenced">
            <summary>
            The assembly references CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrProcedureRegisterFailed">
            <summary>
            Cannot register CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrProcedureRemoveFailed">
            <summary>
            Cannot unregister CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrProcedureInvokeFailed">
            <summary>
            Cannot invoke CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AssemblyNameRegistered">
            <summary>
            The name of assembly is already registered
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AssemblyNotRegistered">
            <summary>
            The assembly is not registered
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AssemblyAddFault">
            <summary>
            Cannot add assembly
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AssemblyUpdateFault">
            <summary>
            Cannot update assembly
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_AssemblyDeleteFault">
            <summary>
            Cannot delete assembly
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateClrTriggerName">
            <summary>
            Duplicate CLR Trigger name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrTriggerRegisteringFault">
            <summary>
            Cannot register CLR Trigger
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrTriggerUnregisteringFault">
            <summary>
            Cannot unregister CLR Trigger
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrTriggerNotRegistered">
            <summary>
            The CLR Proc is not registered in database
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrTriggerReferenced">
            <summary>
            The assembly references CLR Trigger
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_ClrTriggerInvalidEvent">
            <summary>
            Cannot set event type for CLR trigger
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_DuplicateSPName">
            <summary>
            Duplicate stored procedure or udf name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SPRegisteringFault">
            <summary>
            Cannot register stored procedure or udf
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_SPUnregisteringFault">
            <summary>
            Cannot unregister stored procedure or udf
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_BeginTransaction">
            <summary>
            Cannot begin transaction
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CommitTransaction">
            <summary>
            Cannot commit transaction
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_RollbackTransaction">
            <summary>
            Cannot rollback transaction
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CreateTransactionLogTable">
            <summary>
            Cannot create transaction log for table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_OpenTransactionLogTable">
            <summary>
            Cannot open transaction log for table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_TransactionConcurrency">
            <summary>
            Opening transacted version of
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_IncorrectTpIsolationLevel">
            <summary>
            Isolation level not supported
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_NestedTransactionsNotSupported">
            <summary>
            Nested transactions not supported
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_RollbackHasNoBegin">
            <summary>
            The ROLLBACK TRANSACTION request has no corresponding BEGIN TRANSACTION
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_CommitHasNoBegin">
            <summary>
            The COMMIT TRANSACTION request has no corresponding BEGIN TRANSACTION
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_TransactionModeOff">
            <summary>
            The TransactionMode is set to Off on the transaction, none may be created
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_EncryptionKeyEmpty">
            <summary>
            Encryption key for a database cannot be an empty string
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dda_TransactionModeOnlyOff">
            <summary>
            The TransactionMode is set to Off on the transaction, none may be created
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExpectedSymbol">
            <summary>
            Expected some symbol, but found another
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidParameterCount">
            <summary>
            Invalid parameter count in function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExpectedExprButFound">
            <summary>
            Expected some expression, but found another
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnterminatedString">
            <summary>
            Unterminated string
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnterminatedTableName">
            <summary>
            Unterminated table name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnterminatedColumnName">
            <summary>
            Unterminated column name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnterminatedComment">
            <summary>
            Unterminated comment
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExpectedExpression">
            <summary>
            Expected some expression, but found another
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnknownDataType">
            <summary>
            Unknown data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidStatement">
            <summary>
            Invalid statement
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidDatePartForFunction">
            <summary>
            Invalid date part specifier for function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidDatePartForDataType">
            <summary>
            Invalid date part specifier for provided data type in function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidParameterDataType">
            <summary>
            Invalid parameter data type in function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_NestedAggregateFunction">
            <summary>
            Aggregate function cannot have nested aggregate functions
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_PatternMustBeString">
            <summary>
            Pattern must be string
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidPatternEscapeSymbol">
            <summary>
            Invalid pattern. Escape character must be enclosed in the single quotes and have only one symbol
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnterminatedPattern">
            <summary>
            Unterminated pattern
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidPatternFirstCharacter">
            <summary>
            Invalid pattern. First character in range must be smaller than second
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnexpectedError">
            <summary>
            Unexpected error
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidJoinCondition">
            <summary>
            Join condition must have boolean result
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidOperandDataType">
            <summary>
            Invalid operand data type for operator
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidLikeMatchExpression">
            <summary>
            LIKE match expression must be string compatible data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidUsingOfIS">
            <summary>
            Invalid using of IS operator. Expected NULL or NOT NULL, but found another
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidExprInResultColumn">
            <summary>
            Invalid expression in the result column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_AggColumnNotInGroupBy">
            <summary>
            Columns used in expression with aggregate function is not defined in GROUP BY clause
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_TableAliasDuplicated">
            <summary>
            Table alias duplicated
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExpectedBooleanExpression">
            <summary>
            Expected boolean expression
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_WhereCannotHaveAggregate">
            <summary>
            WHERE clause cannot have aggregate functions
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ColumnDoesNotExist">
            <summary>
            Column does not exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExprAlreadyPresentInGroup">
            <summary>
            Expression already present in GROUP BY clause
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExprNotPresentInGroup">
            <summary>
            Expression is not present in GROUP BY clause
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidHavingClauseCondition">
            <summary>
            HAVING clause must have boolean result
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidHavingExpressions">
            <summary>
            HAVING can have only expressions which is in SELECT result or in GROUP BY
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_TableNotExist">
            <summary>
            Table does not exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidGroupWithoutAggregate">
            <summary>
            GROUP BY cannot be used if result does not have aggregate function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidGroupWithAggregate">
            <summary>
            GROUP BY clause cannot have aggregate functions
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidHavingWithoutAggregate">
            <summary>
            HAVING clause cannot be used if result does not have aggregate functions
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExpectedKeyword">
            <summary>
            Expected some keyword, but found another
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidUnionColumnCount">
            <summary>
            All SELECTs in union must have the same column count
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidUnionColumnTypes">
            <summary>
            All SELECTs in union must have the columns with compatible types
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_SameColumnInSomeTables">
            <summary>
            In some tables exists the same column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidGroupStatic">
            <summary>
            GROUP BY expression must contain at least one column
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_CaseMustHaveWhen">
            <summary>
            CASE function must have at least one WHEN operator
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_CaseWhenMustBeBoolean">
            <summary>
            If in CASE function is not defined input expression, than WHEN expressions must has boolean results
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_CaseWhenMustBeInputDataType">
            <summary>
            In CASE function WHEN expressions must have data type compatible with input expression data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidCaseResultDataType">
            <summary>
            CASE function results must have the same (or compatible) data types
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidTableName">
            <summary>
            Invalid table name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidColumnName">
            <summary>
            Invalid column name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InsertColumnFewerThanValues">
            <summary>
            There are fewer columns in the INSERT statement than values specified in the VALUES clause. The number of values in the VALUES clause must match the number of columns specified in the INSERT statement
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InsertColumnMoreThanValues">
            <summary>
            There are more columns in the INSERT statement than values specified in the VALUES clause. The number of values in the VALUES clause must match the number of columns specified in the INSERT statement
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InsertColumnFewerThanSelect">
            <summary>
            The select list for the INSERT statement contains more items than the insert list. The number of SELECT values must match the number of INSERT columns
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InsertSelectFewerThanColumn">
            <summary>
            The select list for the INSERT statement contains fewer items than the insert list. The number of SELECT values must match the number of INSERT columns
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidQueryIndex">
            <summary>
            Invalid query index
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidToken">
            <summary>
            Invalid token in statement
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidCreateDatabaseParams">
            <summary>
            Invalid parameters in CREATE DATABASE
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_CreateTableColumnsDuplicated">
            <summary>
            Column names duplicated in CREATE TABLE
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_CreateTableConstraintDuplicated">
            <summary>
            Constraint names duplicated in CREATE TABLE
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_PrimaryKeyDuplicated">
            <summary>
            Table can have only one instance of primary key
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_TwoClusteredIndexes">
            <summary>
            Only one clustered index is valid on a table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidForeignKeyCount">
            <summary>
            Foreign key column count and primary key column count must be the same
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_IdentityAndDefaultValue">
            <summary>
            Column cannot have default value and identity at the same time
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_PrimaryKeyDoesNotExist">
            <summary>
            Primary key does not exist in the table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidPrimaryKeyInReferences">
            <summary>
            Primary key in references invalid
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidColumnCountInView">
            <summary>
            Column count defined in the view differs from column count defined in the SELECT
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ViewNameDuplicated">
            <summary>
            View name duplicated
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_SubQueryIsReadOnly">
            <summary>
            Sub query is read only.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ViewIsReadOnly">
            <summary>
            View is read only.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ViewNotExist">
            <summary>
            View does npt exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_FunctionNotExist">
            <summary>
            Function does npt exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidIdentifier">
            <summary>
            Invalid identifier
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_StoredProcIsReadOnly">
            <summary>
            Stored procedure result set is read only
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_FirstParameterMustBeObject">
            <summary>
            First parameter must have System.Object data type in the FillRow method
            for CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExpectedOutParameter">
            <summary>
            Expected out parameter for CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_FillRowDoesNotExist">
            <summary>
            FillRow method does not exist in CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_AssemblyNameNotDefined">
            <summary>
            Assembly name is not defined for CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidCLRProcParamType">
            <summary>
            Invalid parameter data type in CLR Proc
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_CLRProcExecutionError">
            <summary>
            CLR Proc execution error
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ParamNotDeclared">
            <summary>
            Parameter not declared
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ReservedWordNameOrAlias">
            <summary>
            Name or alias cannot be reserved word
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ExpectedConstraintEnd">
            <summary>
            Expected end of constraint
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidConstraintExpr">
            <summary>
            Constraint expression must have boolean result data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ParamRedeclaration">
            <summary>
            Parameter redeclaration
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidParamName">
            <summary>
            Invalid parameter name
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ConstraintNotExist">
            <summary>
            Constraint does not exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_DatabaseNotOpened">
            <summary>
            Database not opened
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidDataTypeSpec">
            <summary>
            Invalid data type specification
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_DataTypeLenIsTooLong">
            <summary>
            Data type length is too big
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidSchemaName">
            <summary>
            Invalid schema name. DBO must be used instead
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidNewNameInRename">
            <summary>
            Invalid new object name in sp_rename function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidObjectTypeInRename">
            <summary>
            Invalid object type in sp_rename function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_DuplicateAction">
            <summary>
            Duplicate specification of the action in the trigger declaration.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidTriggerDeclaration">
            <summary>
            Value is not a recognized trigger     
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_IncorrectSyntax">
            <summary>
            Incorrect syntax near the keyword "hint parameter"
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidFtsPattern">
            <summary>
            Syntax error in the full text search condition
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidCaseSyntax">
            <summary>
            Syntax error in the case function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_FtsIndexRequired">
            <summary>
            Cannot use CONTAINS(*) predicate on table because it is not full-text indexed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_OnlySingleExpressionInSelectList">
            <summary>
            Only one expression can be specified in the select list.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidParamForm">
            <summary>
            Must pass parameter and subsequent parameters as @name = value. 
            After the form @name = value has been used, 
            all subsequent parameters must be passed in the same form.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidOutParam">
            <summary>
            The formal parameter was not declared as an OUTPUT parameter, but the actual parameter passed in requested output. Parameter name:
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_TooManyArguments">
            <summary>
            Procedure or function has too many arguments specified. Procedure name:
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ParameterIsNotDefined">
            <summary>
            Procedure or Function expects parameter,which was not supplied. Procedure name:
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_AssignValueSelect">
            <summary>
            A SELECT statement that assigns a value to a variable must not be combined with data-retrieval operations.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidContinueUsnig">
            <summary>
            Cannot use a CONTINUE statement outside the scope of a WHILE statement.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidBreakUsing">
            <summary>
            Cannot use a BREAK statement outside the scope of a WHILE statement.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_wrongRowGuidCol">
            <summary>
            The ROWGUIDCOL property can only be specified on the uniqueidentifier data type.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_AggregateTableAsterix">
            <summary>
            Aggregate function cannot use Asterix, must be qualified
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_AggregateAllAsterix">
            <summary>
            Aggregate function with ALL clause cannot use Asterix, must be qualified
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_AggregateDistinctAsterix">
            <summary>
            Aggregate function with DISTINCT clause cannot use Asterix, must be qualified
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_CustomError">
            <summary>
            Custom error thrown with the raise error statement
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_WithIsUnsupported">
            <summary>
            The WITH syntax is not supported at this location
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_NumericParameterRequired">
            <summary>
            A function was called with a non-numeric type.  (ROUND() called with a string)
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_UnableToImplicitCastType">
            <summary>
            Unable to perform the implicit case operation requested by the users action in SQL.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_IncorrectTypeProvided">
            <summary>
            Incorrect type provided for a convert operation, convert failed
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_InvalidConvertStyle">
            <summary>
            Invalid CONVERT function style value
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ResultOverflowsType">
            <summary>
            Result value overflows return type of function
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_ColumnAsCondition">
            <summary>
            A column is referenced in a context where a boolean condition is expected (should compare column to a value)
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_BitAsBooleanContext">
            <summary>
            A literal or expression BIT value type is not legal in SQL Server in a logical boolean context and is
            an error under Strict compaitiblity mode.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_BooleanAsBitValue">
            <summary>
            A logical boolean expression context is not legal in SQL Server as a data value and is an error under
            Strict compatibility mode (use CASE or IF to choose a data value)
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_TrueFalseLiteralsNotLegal">
            <summary>
            Keywords TRUE, FALSE, YES, and NO are not legal in SQL Server and are rejected under Strict compatibility mode
            (use 0, 1 for BIT literals or comparison for logical boolean)
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_SubQueryRequiresAlias">
            <summary>
            Sub-queries used as rowsets in a FROM or JOIN must be given an explicit unique alias under Strict
            compatibility mode.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_BadArgumentValueNull">
            <summary>
            Value may not be NULL for argument:
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_BadArgumentValueNegative">
            <summary>
            Value may not be negative for argument:
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_BadArgumentValueZero">
            <summary>
            Value may not be zero for argument:
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.sql_BadArgumentValueNotPositive">
            <summary>
            Value must be greater than zero for argument:
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_SupportedOnlyCommand">
            <summary>
            VistaDB supports only Text and StoredProcedureInformation command types
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_UnknownDataType">
            <summary>
            Unknown data type
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_SecondDataReader">
            <summary>
            VistaDBCommand cannot be executed while associated VistaDBDataReader object opened
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_ChangePropWhileDataAdapter">
            <summary>
            VistaDBCommand properties cannot be changed while associated VistaDBDataReader object opened
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_ChangePropWhileConnOpened">
            <summary>
            VistaDBConnection properties cannot be changed while it opened
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_InvalidNameSuffix">
            <summary>
            Name can support as suffix only "]"
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_InvalidNamePrefix">
            <summary>
            Name can support as prefix only "["
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_CommandTextEmpty">
            <summary>
            Command text is empty
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_ContextConnNotAvailable">
            <summary>
            Context connection is not available
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_CBSchemaCannotBeGenerated">
            <summary>
            Schema cannot be generated
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_ConnectionMustBeAssigned">
            <summary>
            Connection property must be assigned
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_ConnectionMustBeOpened">
            <summary>
            Connection must be opened
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_ReadCommittedIsolationOnly">
            <summary>
            Only Read Committed Isolation is supported for isolation levels.
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.ado_KeywordNotSupported">
            <summary>
            The keyword passed in was not found in our dictionary. 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_Position">
            <summary>
            Cannot position to cached row in the table 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_LastKeyPosition">
            <summary>
            Last cached row does not exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_RowsAdded">
            <summary>
            New rows were added to the table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_SetScope">
            <summary>
            Cannot set scope on the table 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_ResetScope">
            <summary>
            Cannot reset scope from the table 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_SetFilter">
            <summary>
            Cannot set filter on the table 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_RowIsNotExist">
            <summary>
            Cached row does not exist
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_FindRow">
            <summary>
            Cannot find needed row 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_ActiveIndex">
            <summary>
            Cannot set active index 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_UpdateRow">
            <summary>
            Cannot update row
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_HideNewRow">
            <summary>
            New row does not exist in the current scope
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_InsertRow">
            <summary>
            Cannot insert new row to the table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_DeleteRow">
            <summary>
            Cannot delete row from the table 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_OpenTable">
            <summary>
            Cannot open table
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_Reset">
            <summary>
            Cannot reset cache 
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_ReadSchema">
            <summary>
            Cannot load table schema
            </summary>
        </member>
        <member name="F:VistaDB.Diagnostic.Errors.dt_ReadData">
            <summary>
            Cannot load table data
            </summary>
        </member>
        <member name="M:VistaDB.Diagnostic.Errors.GetMessage(System.Int32)">
            <summary>
            Get the error message for a given error ID.  This information may not include specific error help.
            </summary>
            <param name="id">ID from an exception</param>
            <returns></returns>
        </member>
        <member name="T:VistaDB.Diagnostic.VistaDBException">
            <summary>
            The DDA exception class
            <seealso>Class Errors</seealso>
            </summary>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the VistaDBException class with serialized data.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or System.Exception.HResult is zero (0).</exception>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the System.Runtime.Serialization.SerializationInfo with information about the exception.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBException.GetNonVistaDBExceptionMessage(System.Exception)">
            <summary>
            Helper method. Gets the messages describing the chain of nested non VistaDB exceptions 
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBException.Contains(System.Int64)">
            <summary>
            Checks the error identifiers in the chain of nested InnerExceptions which caused this exception instance.
            (Does not check this instance's own <see cref="P:VistaDB.Diagnostic.VistaDBException.ErrorId"/>; caller should check property explicitly if necessary.)
            </summary>
            <param name="errorId">Error identifier to look for</param>
            <returns>Found status</returns>
            <seealso cref="T:VistaDB.Diagnostic.Errors"/>
        </member>
        <member name="P:VistaDB.Diagnostic.VistaDBException.Message">
            <summary>
            Gets the message describing the chain of nested exceptions caused the current one
            </summary>
        </member>
        <member name="P:VistaDB.Diagnostic.VistaDBException.LevelMessage">
            <summary>
            Get the message describing only current exception
            </summary>
        </member>
        <member name="P:VistaDB.Diagnostic.VistaDBException.ErrorId">
            <summary>
            VistaDB error identifier for this exception
            </summary>
            <seealso cref="T:VistaDB.Diagnostic.Errors"/>
        </member>
        <member name="T:VistaDB.Diagnostic.VistaDBSQLException">
            <summary>
            The SQL exception class
            </summary>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBSQLException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the VistaDBSQLException class with serialized data.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or System.Exception.HResult is zero (0).</exception>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBSQLException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the System.Runtime.Serialization.SerializationInfo with information about the exception.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
        </member>
        <member name="P:VistaDB.Diagnostic.VistaDBSQLException.LineNo">
            <summary>
            Line number in SQL text when exception happened
            </summary>
        </member>
        <member name="P:VistaDB.Diagnostic.VistaDBSQLException.ColumnNo">
            <summary>
            Column number in SQL text when exception happened
            </summary>
        </member>
        <member name="T:VistaDB.Diagnostic.VistaDBDataTableException">
            <summary>
            The Data table exception class.  Users should never create these objects 
            directly.
            
            They may be thrown by the VistaDB engine during DataTable operations.
            <seealso>Class Errors</seealso>
            </summary>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBDataTableException.#ctor(System.Int32)">
            <summary>
            Creates new instance of DataTable Exception class.
            <seealso>Class VistaDBDataTableException</seealso>
            </summary>
            <param name="errorId">
            Error number
            </param>
            <remarks>
            Not for end user application creation.
            </remarks>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBDataTableException.#ctor(System.Exception,System.Int32)">
            <summary>
            Creates new instance of DataTable Exception class
            <seealso>Class VistaDBDataTableException</seealso>
            </summary>
            <param name="e">
            Internal exception
            </param>
            <param name="errorId">
            Error number
            </param>
            <remarks>
            Not for end user application creation.
            </remarks>
        </member>
        <member name="M:VistaDB.Diagnostic.VistaDBDataTableException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the VistaDBDataTableException class with serialized data.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or System.Exception.HResult is zero (0).</exception>
        </member>
        <member name="P:VistaDB.Diagnostic.VistaDBDataTableException.IsCritical">
            <summary>
            Returns critical exception flag
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.Context.PopContext">
            <summary>
            Returns old context
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBConnection">
            <summary>
            Connection settings supported by local and DDA connections.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConnection.Id">
            <summary>
            Unique identifier assigned to this IVistaDBConnection.  This ID should not be held across database connections or in multiple threads.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConnection.LCID">
            <summary>
            Default locale id to use by CreateDatabase
            </summary>
            <seealso cref="M:VistaDB.DDA.IVistaDBDDA.CreateDatabase(System.String,System.Boolean,System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConnection.PageSize">
            <summary>
            Default page size in kilobytes to use by CreateDatabase
            </summary>
            <seealso cref="M:VistaDB.DDA.IVistaDBDDA.CreateDatabase(System.String,System.Boolean,System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConnection.LockTimeout">
            <summary>
            Get or set timeout for lock operations in seconds.  Default is 10 seconds, negative values reset to default. Max timeout is 1 hour.
            </summary>
        </member>
        <member name="P:VistaDB.DDA.IVistaDBConnection.PersistentLockFiles">
            <summary>
            Get or set policy for lock files. When it is true files, which correspond to specific table will not be deleted with its closing. 
            It allows some performance increasing in multi-user environment.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.Connection.connectionId">
            <summary>
            Unique id assigned to this connection
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.Connection.environment">
            <summary>
            Local connection environment
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Internal.Connection.LockTimeout">
            <summary>
            An INT32 value that represents the time in seconds as the maximum time a transaction is locked.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.Connection.Settings">
            <summary>
            Environment settings
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.ILocalSQLConnection">
            <summary>
            Local sql connection stuff
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.ILocalSQLConnection.CreateQuery(System.String)">
            <summary>
            Instantiates new query object
            </summary>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Engine.Internal.ILocalSQLConnection.Item(System.Int64)">
            <summary>
            Get IVistaDBQuery by its id
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.LocalSQLConnection.IsSyntaxCorrect(System.String,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Check SQL command correctness
            </summary>
            <param name="text">SQL Command Text</param>
            <param name="lineNo">Line number in the text, where mistake occured</param>
            <param name="symbolNo">Symbol number in the text, where mistake occured</param>
            <param name="errorMessage">Error message</param>
            <returns>True - if syntax is correct, else false</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.LocalSQLConnection.IsViewSyntaxCorrect(System.String,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Check SQL command correctness
            </summary>
            <param name="text">SQL Command Text</param>
            <param name="lineNo">Line number in the text, where mistake occured</param>
            <param name="symbolNo">Symbol number in the text, where mistake occured</param>
            <param name="errorMessage">Error message</param>
            <returns>True - if syntax is correct, else false</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.LocalSQLConnection.IsConstraintSyntaxCorrect(System.String,System.Int32@,System.Int32@,System.String@)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="lineNo"></param>
            <param name="symbolNo"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.LocalSQLConnection.TryToCorrect(System.String,System.String@,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Tries to correct SQL command
            </summary>
            <param name="oldText">SQL Command Text for correction</param>
            <param name="newText">Corrected SQL Command Text</param>
            <param name="lineNo">Line number in the text, where mistake occured</param>
            <param name="symbolNo">Symbol number in the text, where mistake occured</param>
            <param name="errorMessage">Error message</param>
            <returns>True - if conversion completed successfully</returns>
        </member>
        <member name="P:VistaDB.Engine.Internal.LocalSQLConnection.IsLegacyMode">
            <summary>
            Gets whether the connection was opened with CompatibilityMode="Legacy".
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Internal.LocalSQLConnection.IsStrictMode">
            <summary>
            Gets whether the connection was opened with CompatibilityMode="Strict".
            </summary>
        </member>
        <member name="P:VistaDB.Engine.Internal.LocalSQLConnection.RandomSource">
            <summary>
            Gets or sets the current pseudo-random source for this connection.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.LocalSQLConnection.OptimizationSetting.Off">
            <summary>
            Disable optimization.  Use core VistaDB logic only.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.LocalSQLConnection.OptimizationSetting.Original">
            <summary>
            Use original VistaDB 4 query optimization (lookup caching disabled, equivalent to 4.2).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.LocalSQLConnection.OptimizationSetting.Old">
            <summary>
            Use old VistaDB 4.3 query optimization (including lookup caching enabled).
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.LocalSQLConnection.OptimizationSetting.On">
            <summary>
            Use new 4.4/5.0 optimization system (with lookup caching enabled).
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.LocalSQLConnection.TablePool">
            <summary>
            Pool of tables. Lists unused but still opened tables. 
            This collection is used by multiple threads due to GC
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBDDA">
            <summary>
            DDA connection
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.CreateDatabase(System.String,System.Boolean,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Instantiates secure/unsecured DDA database object and creates it physically on hard drive
            </summary>
            <returns>IVistaDBDatabase object instance</returns>
            <param name="fileName">Full database file name including path.  The database will be written to the current working directory if no path is provided.</param>
            <param name="stayExclusive">Database file will be left in exclusive mode after the database is created.</param>
            <param name="encryptionKeyString">Phrase used as a base string for encryption key.  Encrypts entire database file or null for non encrypted database.  String empty is NOT valid for an encryption key string.</param>
            <param name="pageSize">Page size to use by database storage in kilobytes. If 0 is passed default page size is used</param>
            <param name="LCID">Locale id to use by culture info assigned to the database. If 0 is passed default locale id is used</param>
            <param name="caseSensitive">Database character data are case sensitive</param>
            <remarks>Parameter stayExclusive is not used by Compact Framework VistaDB version. Database file cannot be opened for writing by another application on Compact Framework.
            <para>
            VB.NET does not have a null primitive and should use Nothing when null is noted.
            </para></remarks>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.LCID"/>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.PageSize"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.CreateIsolatedDatabase(System.String,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Instantiates secure/unsecured DDA database object and creates it physically in isolated storage
            </summary>
            <returns>IVistaDBDatabase object instance</returns>
            <param name="fileName">Full database file name</param>
            <param name="encryptionKeyString">Phrase as a base string for encryption key. Encrypts entire database file or null for non encrypted database.  Empty string is not valid.</param>
            <param name="pageSize">Page size to use by database storage in kilobytes. If 0 is passed default page size is used</param>
            <param name="LCID">Locale id to use by culture info assigned to the database. If 0 is passed default locale id is used</param>
            <param name="caseSensitive">Database character data are case sensitive</param>
            <remarks>Parameter stayExclusive is not used by Compact Framework VistaDB version. Database file cannot be opened for writing by another application on Compact Framework.
            <para>
            VB.NET does not have a null primitive and should use Nothing when null is noted.
            </para></remarks>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.LCID"/>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.PageSize"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.CreateInMemoryDatabase(System.String,System.Int32,System.Boolean)">
            <summary>
            Creates temporary memory backed database for use during a single session (exclusive mode only).  This database is deleted when the application
            is closed or when the application disposes of the database connection.  The database is a virtual memory backed temporary file located in the 
            users temporary directory path.
            </summary>
            <returns>IVistaDBDatabase object instance</returns>
            <param name="encryptionKeyString">Phrase as a base string for encryption key. Encrypts entire database file or null for non encrypted database.  Empty string is not valid.</param>
            <param name="LCID">Locale id to use by culture info assigned to the database. If 0 is passed default locale id is used</param>
            <param name="caseSensitive">Should character data be case sensitive</param>
            <remarks>
            <para>
            VB.NET does not have a null primitive and should use Nothing when null is noted.
            </para></remarks>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.LCID"/>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.PageSize"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.CreateInMemoryDatabase(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates temporary memory backed database for use during a single session (exclusive mode only).  This database is deleted when the application
            is closed or when the application disposes of the database connection.  The database is a virtual memory backed temporary file located in the 
            users temporary directory path.
            The pagesize determines limits in the database engine routines for things like max table columns, indexes, etc.
            </summary>
            <returns>IVistaDBDatabase object instance</returns>
            <param name="encryptionKeyString">Phrase as a base string for encryption key. Encrypts entire database file or null for non encrypted database.  Empty string is not valid.</param>
            <param name="pageSize">Pagesize in kilobytes. If 0 is passed default page size is used (varies by license type).</param>
            <param name="LCID">Locale id to use by culture info assigned to the database. If 0 is passed default locale id is used</param>
            <param name="caseSensitive">Should character data be case sensitive</param>
            <remarks>
            <para>
            VB.NET does not have a null primitive and should use Nothing when null is noted.
            </para>
            </remarks>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.LCID"/>
            <seealso cref="P:VistaDB.DDA.IVistaDBConnection.PageSize"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.OpenDatabase(System.String,VistaDB.VistaDBDatabaseOpenMode,System.String)">
            <summary>
            Instantiates secure/unsecured DDA database object and opens database file
            </summary>
            <param name="fileName">Full database file name</param>
            <param name="mode">Database access mode</param>
            <param name="encryptionKeyString">Phrase as a base string for encryption key. Encrypts entire database file or null for non encrypted database.  Empty string is not valid.</param>
            <returns>IVistaDBDatabase instance</returns>
            <remarks>On Compact Framework VistaDBDatabaseOpenMode may be ExclusiveReadWrite, ExclusiveReadOnly, SharedReadOnly</remarks>
            <seealso cref="T:VistaDB.VistaDBDatabaseOpenMode"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.OpenIsolatedDatabase(System.String,VistaDB.VistaDBDatabaseOpenMode,System.String)">
            <summary>
            Instantiates secure/unsecured DDA database object and open database file in isolated storage
            </summary>
            <param name="fileName">Full database file name</param>
            <param name="mode">Database access mode. Only VistaDBDatabaseOpenMode.ExclusiveReadWrite and VistaDBDatabaseOpenMode.ExclusiveReadOnly are allowed</param>
            <param name="encryptionKeyString">Phrase as a base string for encryption key. Encrypts entire database file or null for non encrypted database.  Empty string is not valid.</param>
            <returns>IVistaDBDatabase instance</returns>
            <remarks>On Compact Framework VistaDBDatabaseOpenMode may be ExclusiveReadWrite, ExclusiveReadOnly, SharedReadOnly</remarks>
            <seealso cref="T:VistaDB.VistaDBDatabaseOpenMode"/>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.PackDatabase(System.String,System.String,System.Boolean,VistaDB.DDA.OperationCallbackDelegate)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <param name="encryptionKeyString">
            String used as base for generating encryption crypto key. Null or Nothing 
            for non encrypted database.
            </param>
            <param name="backup">
            True to create a backup copy before packing.  The backup file will be named
                          the same as the original database, but with a .backupCopy 
            appended to the
                         end of the filename.  If the file exists it will be 
            overwritten.
            </param>
            <param name="operationCallbackDelegate">
            Operation Information delegate method giving feedback during long running 
            operations.
                         You may pass null or Nothing meaning there is no delegate to 
            callback.
            </param>
            <returns>void</returns>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            ' VB.NET Code
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
               DDAObj.PackDatabase(&quot;C:\dest.vdb3&quot;, Nothing, False, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            // C# Code
            public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, null, false, new 
            OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            }
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
             VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.PackDatabase(System.String,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Boolean,VistaDB.DDA.OperationCallbackDelegate)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the new 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <param name="encryptionKeyString">
            Current encryptionKey
            </param>
            <param name="newencryptionKeyString"></param>
            <param name="newPageSize">
            New page size.
                         Pass a 0 here to leave the page size at the current setting.
            </param>
            <param name="newLCID">
            New locale LocaleID.
                         Pass a value of 0 to leave the LocaleID with it's current 
            setting.
            </param>
            <param name="newCaseSensitive">
            New case sensitivity setting.  This cannot be null, so if you want to
                         preserve your case sensitivity you must pass the same value as
             the database
                          was created with initially.
            </param>
            <param name="backup">
            True to create a backup copy before packing.  The backup file will be named
                          the same as the original database, but with a .backupCopy 
            appended to the
                         end of the filename.  If the file exists it will be 
            overwritten.
            </param>
            <param name="operationCallbackDelegate">
            Operation Information delegate method for feedback from pack progress.
                         You may pass null or Nothing meaning there is no delegate.
            </param>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                Dim OldPassword As String
                Dim NewPassword As String
                ' In this example we are modifying a database that had no encryptionKey
             to now have one
                ' Reverse to remove a encryptionKey
                OldCryptoPhrase = Nothing
                NewPhrase = &quot;pass.word&quot;
                DDAObj.PackDatabase(&quot;C:\test.vdb3&quot;, OldCryptoPhrase, 
            NewPhrase, 0, 0, True, True, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               string OldPhrase = null;
               string NewPhrase = &quot;pass.word&quot;;
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, OldPhrase, NewPhrase, pageSize, LCID, 
            caseSensitive, false, new OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            
            }
            
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
             VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.PackDatabase(System.String,VistaDB.DDA.OperationCallbackDelegate)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the new 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <param name="operationCallback">
            Delegate called by the Pack operation for progress and informational messages.  NULL means no callback should be used.
            </param>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                Dim OldPassword As String
                Dim NewPassword As String
                ' In this example we are modifying a database that had no encryptionKey
             to now have one
                ' Reverse to remove a encryptionKey
                OldCryptoPhrase = Nothing
                NewPhrase = &quot;pass.word&quot;
                DDAObj.PackDatabase(&quot;C:\test.vdb3&quot;, OldCryptoPhrase, 
            NewPhrase, 0, 0, True, True, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               string OldPhrase = null;
               string NewPhrase = &quot;pass.word&quot;;
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, OldPhrase, NewPhrase, pageSize, LCID, 
            caseSensitive, false, new OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            
            }
            
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
            VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.PackDatabase(System.String)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the new 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                Dim OldPassword As String
                Dim NewPassword As String
                ' In this example we are modifying a database that had no encryptionKey
             to now have one
                ' Reverse to remove a encryptionKey
                OldCryptoPhrase = Nothing
                NewPhrase = &quot;pass.word&quot;
                DDAObj.PackDatabase(&quot;C:\test.vdb3&quot;, OldCryptoPhrase, 
            NewPhrase, 0, 0, True, True, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               string OldPhrase = null;
               string NewPhrase = &quot;pass.word&quot;;
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, OldPhrase, NewPhrase, pageSize, LCID, 
            caseSensitive, false, new OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            
            }
            
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
             VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.RepairDatabase(System.String,System.String,VistaDB.DDA.OperationCallbackDelegate)">
             <summary>
             Attempt to repair a physically or logically corrupted database file.
             </summary>
             <param name="fileName">
             Full database file name including path unless the database is in the local 
             directory.
             </param>
             <param name="encryptionKeyString">
             Current encryptionKey.  Null or Nothing if no encryptionKey is needed for database.
             </param>
             <param name="operationCallbackDelegate">
             Operation Information delegate method providing feedback of progress.
             You may pass null or Nothing meaning there is no callback (silent).
             </param>
             <code lang="vbnet">
             Sub Main()
            		Dim DDAObj As VistaDB.DDA.IVistaDBDDA
            		' We must have a valid DDA Object loaded to call Repair
            		DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                 DDAObj.RepairDatabase("C:\test.vdb3", Nothing, Nothing)
            		' Path does not have to be absolute, Dot Net looks in the current working directory by default.
            		' The base of the encryption key is passed as a string
            		DDAObj.RepairDatabase("test.vdb3", "pass.word", Nothing)
             End Sub
             </code>
             <code lang="cs">
            	IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
            	try
            	{
            		// Attempt to repair the database
            		DDAObj.RepairDatabase("databasename.vdb3", null, null);
            
            		// It is always a good practice to Pack the database after a repair.  Repair can leave the
            		// constraints or other high level database data in a bad logical state.
            		DDAObj.PackDatabase(rwdbName, null, false, null);
            	}
            	catch (System.Exception e)
            	{
            		System.Diagnostics.Debug.WriteLine("Exception: " + e.ToString());
            	}
            	</code>
             <summary>
             Attempt to repair a physically or logically corrupted database file.
             <seealso>Interface IVistaDBDDA</seealso>
             <seealso>IVistaDBDDA.PackDatabase</seealso>
             </summary>
             <remarks>
             If PackDatabase cannot update or pack a database file you may need to 
             attempt a RepairDatabase. This function attempts a much lower level repair 
             of the database than a pack operation. All of the high level database 
             constructs like constraints and triggers are ignored during this operation.
               As a result there still may be logical corruption (Foreign Key 
             Constraints, etc) that are invalid after this operation completes.  You 
             must then run PackDatabase to validate the logical portions of the 
             database. This method does not guarantee database schema and data to be 
             accurate after a repair.  Repair is a best effort attempt to get as much 
             data back out of a database as possible.  It is not recommended you 
             automate this call without user interaction.  The schema and data should be
              verified after running a repair operation.
             </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.RepairDatabase(System.String,VistaDB.DDA.OperationCallbackDelegate)">
             <summary>
             Attempt to repair a physically or logically corrupted database file.
             </summary>
             <param name="fileName">
             Full database file name including path unless the database is in the local 
             directory.
             </param>
             <code lang="vbnet">
             Sub Main()
            		Dim DDAObj As VistaDB.DDA.IVistaDBDDA
            		' We must have a valid DDA Object loaded to call Repair
            		DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                 DDAObj.RepairDatabase("C:\test.vdb3", Nothing, Nothing)
            		' Path does not have to be absolute, Dot Net looks in the current working directory by default.
            		' The base of the encryption key is passed as a string
            		DDAObj.RepairDatabase("test.vdb3", "pass.word", Nothing)
             End Sub
             </code>
             <code lang="cs">
            	IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
            	try
            	{
            		// Attempt to repair the database
            		DDAObj.RepairDatabase("databasename.vdb3", null, null);
            
            		// It is always a good practice to Pack the database after a repair.  Repair can leave the
            		// constraints or other high level database data in a bad logical state.
            		DDAObj.PackDatabase(rwdbName, null, false, null);
            	}
            	catch (System.Exception e)
            	{
            		System.Diagnostics.Debug.WriteLine("Exception: " + e.ToString());
            	}
            	</code>
             <summary>
             Attempt to repair a physically or logically corrupted database file.
             <seealso>Interface IVistaDBDDA</seealso>
             <seealso>IVistaDBDDA.PackDatabase</seealso>
             </summary>
             <param name="operationCallback">
             Operation Information delegate method providing feedback of progress.
             You may pass null or Nothing meaning there is no callback (silent).
             </param>
             <remarks>
             If PackDatabase cannot update or pack a database file you may need to 
             attempt a RepairDatabase. This function attempts a much lower level repair 
             of the database than a pack operation. All of the high level database 
             constructs like constraints and triggers are ignored during this operation.
               As a result there still may be logical corruption (Foreign Key 
             Constraints, etc) that are invalid after this operation completes.  You 
             must then run PackDatabase to validate the logical portions of the 
             database. This method does not guarantee database schema and data to be 
             accurate after a repair.  Repair is a best effort attempt to get as much 
             data back out of a database as possible.  It is not recommended you 
             automate this call without user interaction.  The schema and data should be
              verified after running a repair operation.
             </remarks>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBDDA.RepairDatabase(System.String)">
             <summary>
             Attempt to repair a physically or logically corrupted database file.
             </summary>
             <param name="fileName">
             Full database file name including path unless the database is in the local 
             directory.
             </param>
             <code lang="vbnet">
             Sub Main()
            		Dim DDAObj As VistaDB.DDA.IVistaDBDDA
            		' We must have a valid DDA Object loaded to call Repair
            		DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                 DDAObj.RepairDatabase("C:\test.vdb3", Nothing, Nothing)
            		' Path does not have to be absolute, Dot Net looks in the current working directory by default.
            		' The base of the encryption key is passed as a string
            		DDAObj.RepairDatabase("test.vdb3", "pass.word", Nothing)
             End Sub
             </code>
             <code lang="cs">
            	IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
            	try
            	{
            		// Attempt to repair the database
            		DDAObj.RepairDatabase("databasename.vdb3", null, null);
            
            		// It is always a good practice to Pack the database after a repair.  Repair can leave the
            		// constraints or other high level database data in a bad logical state.
            		DDAObj.PackDatabase(rwdbName, null, false, null);
            	}
            	catch (System.Exception e)
            	{
            		System.Diagnostics.Debug.WriteLine("Exception: " + e.ToString());
            	}
            	</code>
             <summary>
             Attempt to repair a physically or logically corrupted database file.
             <seealso>Interface IVistaDBDDA</seealso>
             <seealso>IVistaDBDDA.PackDatabase</seealso>
             </summary>
             <remarks>
             If PackDatabase cannot update or pack a database file you may need to 
             attempt a RepairDatabase. This function attempts a much lower level repair 
             of the database than a pack operation. All of the high level database 
             constructs like constraints and triggers are ignored during this operation.
               As a result there still may be logical corruption (Foreign Key 
             Constraints, etc) that are invalid after this operation completes.  You 
             must then run PackDatabase to validate the logical portions of the 
             database. This method does not guarantee database schema and data to be 
             accurate after a repair.  Repair is a best effort attempt to get as much 
             data back out of a database as possible.  It is not recommended you 
             automate this call without user interaction.  The schema and data should be
              verified after running a repair operation.
             </remarks>
        </member>
        <member name="F:VistaDB.Engine.Internal.DirectConnection.storageManager">
            <summary>
            External data storage manager
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.DirectConnection.CreateInMemoryDatabase(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create temporary database
            </summary>
            <param name="cryptoKeyString">User defined string to salt database encryption key</param>
            <param name="pageSize"></param>
            <param name="LCID">Locale identifier to use by database</param>
            <param name="caseSensitive">Character data are case sensitive</param>
            <returns>The instance of created database</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.DirectConnection.CreateDatabase(System.String,System.Boolean,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create standard database
            </summary>
            <param name="fileName"></param>
            <param name="stayExclusive"></param>
            <param name="cryptoKeyString">User defined string to salt database encryption key.  String empty is not valid.</param>
            <param name="pageSize"></param>
            <param name="LCID"></param>
            <param name="caseSensitive"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.DirectConnection.CreateInMemoryDatabase(System.String,System.Int32,System.Boolean)">
            <summary>
            Create temporary database
            </summary>
            <param name="cryptoKeyString">User defined string to salt database encryption key</param>
            <param name="LCID">Locale identifier to use by database</param>
            <param name="caseSensitive">Character data are case sensitive</param>
            <returns>The instance of created database</returns>
        </member>
        <member name="T:VistaDB.Engine.Internal.CacheFactory">
            <summary>
            CacheFactory maintains a set of TableCache and ColumnCache objects related to optimizing a single query
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.CacheFactory.m_CachedTables">
            <summary>
            The internal collection of TableCaches managed by this factory.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.CacheFactory.m_KeyedTables">
            <summary>
            The internal collection of KeyedLookupTables associated with TableCaches managed by this factory.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.GetLookupTable(VistaDB.DDA.IVistaDBDatabase,VistaDB.Engine.SQL.SourceTable,System.String,VistaDB.Engine.SQL.Signatures.ColumnSignature)">
            <summary>
            Get a KeyedLookupTable for a given SourceTable (alias) and key column (from another table) looking up within
            an underlying ITableCache.
            </summary>
            <param name="database">Temporarily needed, but should ultimately go away.</param>
            <param name="table">The SourceTable object for a specific alias of a table as joined.</param>
            <param name="activeIndex">The name of the index to search.  (Temporarily, the name of the column instead.)</param>
            <param name="keyColumn">The ColumnSignature of the key column of another table whose value will key the search.</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.GetLookupTable(System.String)">
            <summary>
            Get a KeyedLookupTable (previously created) for a given table alias.
            </summary>
            <param name="tableAlias">The alias name of the table.</param>
            <returns>The KeyedLookupTable for the given table alias, or null if not found.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.GetTableCache(VistaDB.DDA.IVistaDBDatabase,System.String,System.String,VistaDB.VistaDBType)">
            <summary>
            Returns the requested TableCache. It is created on first request and subsequent requests return the same instance.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.GetColumnCache(VistaDB.DDA.IVistaDBDatabase,System.String,System.String,VistaDB.VistaDBType,System.String)">
            <summary>
            Returns the requested ColumnCache. It is created on first request and subsequent requests return the same instance.
            All ColumnCaches referenceing the same indexColumn or a table will share a reference to the same TableCache.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.FindTableCache(System.String,System.String)">
            <summary>
            Private method to return an existing TableCache, if it already exists
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.CreateTableCache(VistaDB.DDA.IVistaDBDatabase,System.String,System.String,VistaDB.VistaDBType,System.String)">
            <summary>
            Private method to create a needed TableCache.
            NOTE: This method will return null for unsupported index types
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.GetTableCacheKey(System.String,System.String)">
            <summary>
            Each TableCache relates to one index column on a table.  If a table is indexed by
            multiple columns, we need a seperate TableCache for each one. To allow easy indexing,
            the Dictionary key will be a string formed by concatenating table and index column
            names.  We force the names to uppercase to allow case-insensitive retrieval
            with efficient ordinal text compare.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.CacheFactory.GetFilterFormatString(System.String,VistaDB.VistaDBType)">
            <summary>
            This private method creates a format string that properly quotes the
            key value for use in the DDA SetFilter method. For example, strings
            are quoted and Guids are quoted with '{xxx}'
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.ITableCache">
            <summary>
            TableCache use a generic key for optimal indexing. The ITableCache interface
            allows simple access to a cached value without having to worry about the key type
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.TableCache`1">
            <summary>
            TableCache is a specialization of WeakReferenceCache for use caching the relevant column values
            for tables associated with a particular index key. This is particularly useful for optimizing
            access to domain tables (i.e. child table has a FK to the PK in the parent domain table).
            Common examples include database implementations of enums or accessing parent table fields
            such as the Employer associated with an Employee.
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.TableCache`1.m_RegisteredColumns">
            <summary>
            Bitmap of columns for which data is required (null -> all columns for the table; index beyond array -> not registered)
            </summary>
        </member>
        <member name="F:VistaDB.Engine.Internal.TableCache`1.m_RegisteredColumnsList">
            <summary>
            List of columns (by index number) for which data is required (null -> needs computing, unless registeredColumns is null).
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.TableCache`1.#ctor(VistaDB.DDA.IVistaDBDatabase,System.String,System.String)">
            <summary>
            This is the normal constructor for most table caches other than ones indexed by a text column
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.TableCache`1.#ctor(VistaDB.DDA.IVistaDBDatabase,System.String,System.String,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            This constructor is specialized with the ability to pass in culture and case sensitivity preferences
            to allow correct indexing of text values as the key of a TableCache
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.TableCache`1.GetColumnCache(System.String)">
            <summary>
            Factory method to return a ColumnCache related to this table
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.TableCache`1.GetRegisteredColumns">
            <summary>
            Get a list (for read/iterating only, DO NOT MODIFY) of registered columns (by index number).
            (null means ALL columns in the table are required)
            </summary>
            <returns>An IEnumerable&lt;int&gt; list of columns (by index number), or null to indicate that ALL columns
            should be included.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.TableCache`1.GetValues(System.Object)">
            <summary>
            Return the array of relevant column values from table row associated with the specified key column value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.TableCache`1.FetchValue(`0)">
            <summary>
            This is the magic virtual method invoked by WeakReferenceCache when we actually need to read a new
            row into the cache.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.KeyedLookupTable">
            <summary>
            Represents a particular table joined by a match of its PK against another particular ColumnSignature.  It represents
            a specific alias of a (or the unaliased) table in a given query.
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.KeyedLookupTable.GetValue(System.Int32)">
            <summary>
            Read a single column value for the current row (as determined by our key column).
            </summary>
            <param name="dataIndex">The index of the desired column in the cached data values.</param>
            <returns>The data value for the specified column.</returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.KeyedLookupTable.GetValues">
            <summary>
            Read the array of values for the current row (as determined by our key column).
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.KeyedLookupTable.GetKeyValue">
            <summary>
            Get the current key value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Engine.Internal.KeyedLookupTable.SetValues(System.Object[])">
            <summary>
            Save an array of values for the current row into the cache (keyed by our key column).
            </summary>
            <param name="values">The array of values to save for the current key.</param>
        </member>
        <member name="M:VistaDB.Engine.Internal.KeyedLookupTable.GetRegisteredColumns">
            <summary>
            Get an iteratable list of registered columns (by index number). (null means ALL columns in the table are required)
            </summary>
            <returns>An IEnumerable&lt;int&gt; list of columns (by index number), or null to indicate that ALL columns
            should be included.</returns>
        </member>
        <member name="T:VistaDB.Engine.Internal.QuickJoinLookupColumn">
            <summary>
            Represents a particular column in the select output which comes from a particular KeyedLookupTable.
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.ColumnCache">
            <summary>
            ColumnCache is a wrapper for a TableCache that simplifies getting a particular column value
            from the row associated with a index key value
            </summary>
        </member>
        <member name="M:VistaDB.Engine.Internal.ColumnCache.GetValue(System.Object)">
            <summary>
            GetValue gets the underlying row matching the key and returns the appropriate column value
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.SimpleTimer">
            <summary>
            Singleton facade around timers fo 
            </summary>
        </member>
        <member name="T:VistaDB.Engine.Internal.SynchronizedWeakReferenceCache`2">
            <summary>
            Thread-safe wrapper for WeakReferenceCache
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBType">
            <summary>
            VistaDB 4 data types
            </summary>
            <remarks>
            The only SQL Server 2005 type not currently supported natively is the XML column type.  This is due to the way
            that SQL Server allows for XPath queries to be executed against the XML columns.  We plan to add support for this at 
            a later time. (That was before GibraltarSoftware.  No longer currently planned. -RSP)
            .Net Decimal types are different than Sql Server (see the Decimal column).
            SQL Server 2008 types for date and time are planned for 4.x. (New types implemented in 5.0)
            </remarks>
        </member>
        <member name="F:VistaDB.VistaDBType.Uninitialized">
            <summary>
            Uninitialized is used internally to indicate when a VistaDBType has not yet been set to anything.
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Char">
            <summary>
            System.String. Char(x)
            <para>
            Fixed length character data with length of N characters. 
            N must be a value from 1 through 8192. 
            Storage size is N bytes of the data converted from Unicode string to non-Unicode character array.
            </para>
            </summary>
            <remarks>Corresponding to SqlDbType.Char</remarks>
            <seealso cref="F:System.Data.SqlDbType.Char"/>
        </member>
        <member name="F:VistaDB.VistaDBType.NChar">
            <summary>
            System.String. NChar(x)<para>
            Fixed length Unicode character data of N characters. 
            N must be a value from 1 through 8192. Storage size is two times N bytes
            </para>
            <remarks>Corresponding to SqlDbType.NChar</remarks>
            <seealso cref="F:System.Data.SqlDbType.NChar"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.VarChar">
            <summary>
            System.String. Varchar(x)<para>
            Variable length character data with length of N characters. 
            N must be a value from 1 through 8192. 
            Storage size is the actual length in bytes of the data entered and converted 
            from Unicode string to non-Unicode character array, not a fixed size. 
            The data entered can be 0 characters in length. 
            Varchar data are stored inside the record.
            </para>
            <remarks>Corresponding to SqlDbType.VarChar</remarks>
            <seealso cref="F:System.Data.SqlDbType.VarChar"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.NVarChar">
            <summary>
            System.String. NVarchar(x)<para>
            Variable length character data with length of N characters. 
            N must be a value from 1 through 8192. 
            Storage size, in bytes, is two times the number of characters entered. 
            The data entered can be 0 characters in length. 
            NVarchar data are stored inside the record.
            </para>
            <remarks>Corresponding to SqlDbType.NVarChar</remarks>
            <seealso cref="F:System.Data.SqlDbType.NVarChar"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Text">
            <summary>
            System.String. <para>Variable length character data with no explicit length. 
            Storage is outside the record (extended type). Storage data is non-Unicode character array.
            Maximum length is 134213632 characters multiplied by .vdb3 file page size 
            expressed in kilobytes (1 throw 16). </para>
            <remarks>Corresponding to SqlDbType.Text</remarks>
            <seealso cref="F:System.Data.SqlDbType.Text"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.NText">
            <summary>
            System.String. <para>Variable length Unicode character data with no explicit length. 
            Storage is outside the record (extended type). Storage data is Unicode character array.
            Maximum length is 67106816 characters multiplied by .vdb3 file page size 
            expressed in kilobytes (1 through 16).</para> 
            <remarks>Corresponding to SqlDbType.NText</remarks>
            <seealso cref="F:System.Data.SqlDbType.NText"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.TinyInt">
            <summary>
            System.Byte. <para>8-bit unsigned integer.</para>
            <remarks>Corresponding to SqlDbType.TinyInt</remarks>
            <seealso cref="F:System.Data.SqlDbType.TinyInt"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.SmallInt">
            <summary>
            System.Int16. <para>16-bit signed integer.</para>
            <remarks>Corresponding to SqlDbType.SmallInt</remarks>
            <seealso cref="F:System.Data.SqlDbType.SmallInt"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Int">
            <summary>
            System.Int32. <para>32-bit signed integer.</para>
            <remarks>Corresponding to SqlDbType.Int</remarks>
            <seealso cref="F:System.Data.SqlDbType.Int"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.BigInt">
            <summary>
            System.Int64. <para>64-bit signed integer.</para>
            <remarks>Corresponding to SqlDbType.BigInt</remarks>
            <seealso cref="F:System.Data.SqlDbType.BigInt"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Real">
            <summary>
            System.Single. <para>A floating point number within 
            the range of -3.40E +38 through 3.40E +38.</para>
            <remarks>Corresponding to SqlDbType.Real</remarks>
            <seealso cref="F:System.Data.SqlDbType.Real"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Float">
            <summary>
            System.Double
            A double-precision (64-bit) floating-point number within the range of -1.79E +308 through 1.79E +308.
            <remarks>Corresponding to SqlDbType.Float</remarks>
            <seealso cref="F:System.Data.SqlDbType.Float"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Decimal">
            <summary>
            System.Decimal
            128-bit (16-byte) integer scaled by a variable power of 10.
            <seealso>Enumeration VistaDBType</seealso>
            <seealso>System.Data.SqlDbType.Decimal</seealso>
            </summary>
            <remarks>
            Corresponding to SqlDbType.Decimal with the same limits implied as the .Net
             framework System.Decimal.
            
            .Net decimals cannot store as much data as SqlDecimal.  Sql Server uses a 
            format that is not compatible with .Net datatypes.  Attempting to pull a 
            value outside the .Net range will result in an error.
            
            VistaDB uses all managed .Net types.  Therefore our decimal type matches 
            that of the System Decimal type, not that of Sql Server.
            </remarks>
        </member>
        <member name="F:VistaDB.VistaDBType.Money">
            <summary>
            System.Decimal. <para>Signed 64-bit (8-byte) integers with scaling factor '4'. Store 8 bytes
            Relies on .Net Decimal type with fixed scaling factor</para>
            <remarks>Corresponding to SqlDbType.Money</remarks>
            <seealso cref="F:System.Data.SqlDbType.Money"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.SmallMoney">
            <summary>
            System.Decimal. <para>Signed 32-bit (4-byte) integers with scaling factor '4'. 
            Store 4 bytes. Same as Currency but with less dynamic borders
            from -214,748.3648 through +214,748.3647</para>
            <remarks>Corresponding to SqlDbType.SmallMoney</remarks>
            <seealso cref="F:System.Data.SqlDbType.SmallMoney"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Bit">
            <summary>
            System.Boolean. <para>Boolean value that can be true, false, or null.</para>
            <remarks>Corresponding to SqlDbType.Bit</remarks>
            <seealso cref="F:System.Data.SqlDbType.Bit"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.DateTime">
            <summary>
            System.DateTime. <para>Same as the SQL Server type DateTime2 (a .NET DateTime).
            Internal storage of this data type is 8 bytes. 
            Date and time data ranging and accuracy are respective System.DateTime 
            ranging and accuracy</para>
            <remarks>Corresponding to SqlDbType.DateTime2</remarks>
            <seealso cref="F:System.Data.SqlDbType.DateTime2"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Image">
            <summary>
            System.Byte[]. <para>Variable length binary data with a maximum length of 134213632 bytes
            multiplied by database page size expressed in kilobytes (1 through 16). 
            Actual data is outside the record (extended row data).</para>
            <remarks>Corresponding to SqlDbType.Image</remarks>
            <seealso cref="F:System.Data.SqlDbType.Image"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.UniqueIdentifier">
            <summary>
            System.Guid. <para>A globally unique identifier (or GUID). Storage is inside the record</para>
            <remarks>Corresponding to SqlDbType.UniqueIdentifier</remarks>
            <seealso cref="F:System.Data.SqlDbType.UniqueIdentifier"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.SmallDateTime">
            <summary>
            System.DateTime. <para>Date and time data ranging in value from January 1, 1900 0:00
            to November 30, 4451 1:19 PM an accuracy of one minute. 
            Internal storage of this data type is 4 bytes</para>
            <remarks>Corresponding to SqlDbType.SmallDateTime</remarks>
            <seealso cref="F:System.Data.SqlDbType.SmallDateTime"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Timestamp">
            <summary>
            System.Int64. <para>64-bit signed integer.</para>
            Automatically generated binary numbers, which are guaranteed to be unique within a database. This datatype
            does not store date or time information. 
            <remarks><para>Corresponding to SqlDbType.TimeStamp</para>
            <para>
            This is from the SQL Server docs: Is a data type that exposes automatically generated, unique binary 
            numbers within a database. timestamp is generally used as a mechanism for version-stamping table rows. 
            The storage size is 8 bytes. The timestamp data type is just an incrementing number and does not preserve a date or a time. 
            To record a date or time, use a DateTime data type.
            </para>
            <para>
            We use a 64 bit integer which is functionally the same as an 8 byte binary value.  8 binary bytes (8 bits each) is a 64 bit value.
            We visually show it to the user differently in the Data Builder than how Microsoft does.  The SQL Server management studio shows the TIMESTAMP as BINARY
            data, we show the actual value.  We use a single 64 bit value to make comparisons faster, rather than comparing each 8 bit value across 8 bytes.
            </para>
            </remarks>
            <seealso cref="F:System.Data.SqlDbType.Timestamp"/>
            <seealso cref="F:VistaDB.VistaDBType.DateTime"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Binary">
            <summary>
            System.Byte[]. <para>Fixed length binary data with a maximum length of 8000 bytes.
            Storage is inside the record</para>
            <remarks>Corresponding to SqlDbType.Binary</remarks>
            <seealso cref="F:System.Data.SqlDbType.Binary"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.VarBinary">
            <summary>
            System.Byte[]. <para>Varying length binary data with a maximum length of 800 bytes.
            Storage is inside the record</para>
            <remarks>Corresponding to SqlDbType.VarBinary</remarks>
            <seealso cref="F:System.Data.SqlDbType.VarBinary"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Time">
            <summary>
            System.Timespan. <para>Time of day with a precision of 100 nanoseconds.
            Stored internally as a timespan since midnight.</para>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Date">
            <summary>
            System.DateTime. <para>A date only.  From Jan 1, 0001 to Dec 31, 9999.
            Stored internally as a DateTime at midnight.</para>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.DateTime2">
            <summary>
            System.DateTime. <para>Internal storage of this data type is 8 bytes. 
            Date and time data ranging and accuracy are respective System.DateTime 
            ranging and accuracy</para>
            <remarks>Corresponding to SqlDbType.DateTime2</remarks>
            <seealso cref="F:System.Data.SqlDbType.DateTime2"/>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.DateTimeOffset">
            <summary>
            System.DateTimeOffset. <para>A DateTime and specific timezone offset.</para>
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBType.Unknown">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBDatabaseOpenMode">
            <summary>
            The database open mode
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBDatabaseOpenMode.ExclusiveReadWrite">
            <summary>
            Database file opened exclusively for read/write operations
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBDatabaseOpenMode.ExclusiveReadOnly">
            <summary>
            Database file opened exclusively for read-only operations
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBDatabaseOpenMode.NonexclusiveReadWrite">
            <summary>
            Database file opened in shared mode for read/write operations.  This mode has performance implications due to the nature of shared file I/O.  
            </summary>
            <remarks>This mode is not allowed on Compact Framework</remarks>
        </member>
        <member name="F:VistaDB.VistaDBDatabaseOpenMode.NonexclusiveReadOnly">
            <summary>
            Database file opened in shared mode for read-only operations. 
            The other clients may write to the database
            </summary>
            <remarks>This mode is not allowed on Compact Framework</remarks>
        </member>
        <member name="F:VistaDB.VistaDBDatabaseOpenMode.SharedReadOnly">
            <summary>
            Database file opened in shared mode for read-only operations by all clients. 
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBClrProcedureAttribute">
            <summary>
            Used to mark a method definition in an assembly as a CLR Proc. The
            properties on the attribute reflect the physical characteristics used when
            the type is registered with VistaDB. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBClrProcedureAttribute.#ctor">
            <summary>
            An attribute on a method definition in an assembly, used to indicate that
            the given method should be registered as a CLR Proc in database
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBClrProcedureAttribute.Kind">
            <summary>
            The sort of result created by CLR Proc. 
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBClrProcedureAttribute.FillRow">
            <summary>
            The name of the helper CLR Proc to treat row results generated with registered CLR Proc.
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBClrProcedureKind">
            <summary>
            The sort of result created by CLR Proc. 
            This value is recognized by SQL parser to treat the method respectively
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBClrProcedureKind.Default">
            <summary>
            The Clr Procedure executes standard calculation
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBClrProcedureKind.Aggregate">
            <summary>
            The Clr Procedure should be recognized as aggregate function by SQL parser
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBContext">
            <summary>
            Context of CLR Proc and triggers
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBContext.SQLChannel">
            <summary>
            SQL context of CLR Proc and triggers
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBContext.SQLChannel.IsAvailable">
            <summary>
            Shows active status of context
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBContext.SQLChannel.Pipe">
            <summary>
            IVistaDBPipe data channel
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBContext.SQLChannel.TriggerContext">
            <summary>
            Provides contextual information about the trigger that was fired.
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBContext.SQLChannel.CurrentTransaction">
            <summary>
            Provides contextual information about current transaction
            </summary>
        </member>
        <member name="F:VistaDB.VistaDBContext.SQLChannel.SQLContextData.triggerStack">
            <summary>
            The stack of tables visible by triggers as INSERTED or UPDATED 
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBContext.DDAChannel">
            <summary>
            DDA context of CLR Proc and triggers
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBContext.DDAChannel.IsAvailable">
            <summary>
            Shows active status of context
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBContext.DDAChannel.Pipe">
            <summary>
            IVistaDBPipe data channel
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBContext.DDAChannel.CurrentDatabase">
            <summary>
            Returns database instance in the CLR Proc or CLR trigger
            </summary>
        </member>
        <member name="T:VistaDB.TriggerAction">
            <summary>
            Event to fire table level trigger. Used by the VistaDB.TriggerContext
            class to indicate what action fired the trigger.
            </summary>
            <seealso cref="T:VistaDB.TriggerContext"/>
        </member>
        <member name="F:VistaDB.TriggerAction.AfterInsert">
            <summary>
            An INSERT statement was executed
            </summary>
        </member>
        <member name="F:VistaDB.TriggerAction.AfterUpdate">
            <summary>
            An UPDATE statement was executed
            </summary>
        </member>
        <member name="F:VistaDB.TriggerAction.AfterDelete">
            <summary>
            A DELETE statement was executed
            </summary>
        </member>
        <member name="T:VistaDB.TriggerContext">
            <summary>
            Provides contextual information about the trigger that was fired.
            </summary>
        </member>
        <member name="M:VistaDB.TriggerContext.IsUpdatedColumn(System.Int32)">
            <summary>
            Returns true if a column was affected by an INSERT or UPDATE statement.
            </summary>
            <param name="columnOrdinal">The zero-based ordinal of the column.</param>
            <returns>True if the column was affected by an INSERT or UPDATE operation.</returns>
        </member>
        <member name="P:VistaDB.TriggerContext.ColumnCount">
            <summary>
            Gets the number of columns contained by the data table bound to the trigger.
            </summary>
        </member>
        <member name="P:VistaDB.TriggerContext.TriggerAction">
            <summary>
            Indicates what action fired the trigger.
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBValue">
            <summary>
            The abstract class implementing IVistaDBValue interface
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBValue.Value">
            <summary>
            The internal object that represents the system object type
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBValue.HasValue">
            <summary>
            Gets a value indicating whether the current Value object has a value or is null.
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBValue.IsNull">
            <summary>
            Helper property to check if value is null reference
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBValue.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBValue.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBString">
            <summary>
            The value of string type that is wrapped into the class
            and represents NChar, Char, NVarChar, VarChar, NText and Text
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBString.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBString.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBString.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or string.Empty.
            </summary>
            <returns>string with the current value, or string.Empty if the Value is null.</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBString.GetValueOrDefault(System.String)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.
            </summary>
            <param name="defaultValue"></param>
            <returns>string with the current value, or passed in defaultValue</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBString.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBString)">
            <summary>
            Overloaded.  Returns the Value of the object, or the value of the passed in defaultValue.
            </summary>
            <param name="defaultValue"></param>
            <returns>string</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBString.Value">
            <summary>
            The string value converted to an object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBString.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBString.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBDateTime">
            <summary>
            The value of DateTime type that is wrapped into the class 
            and represents VistaDBType.DateTime2 and VistaDBType.SmallDateTime
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTime.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTime.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTime.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or DateTime.MinValue.
            </summary>
            <returns>Current Value or DateTime.MinValue</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTime.GetValueOrDefault(System.DateTime)">
            <summary>
            Overloaded. Returns the Value of the object, or a the passed in defaultValue.
            </summary>
            <returns>Current Value or passed in defaultValue.</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTime.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBDateTime)">
            <summary>
            Overloaded.  Returns the Value of the object, or the value of the passed in defaultValue.
            </summary>
            <param name="defaultValue"></param>
            <returns>VistaDBString</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDateTime.Value">
            <summary>
            The internal object that represents the DateTime
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDateTime.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDateTime.SystemType">
            <summary>
            System type (Dot Net runtime) for the Value - this is not the same as the VistaDBType
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBDateTimeOffset">
            <summary>
            The value of DateTime type that is wrapped into the class 
            and represents VistaDBType.DateTimeOffset
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.#ctor(System.DateTimeOffset)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or DateTime.MinValue.
            </summary>
            <returns>Current Value or DateTime.MinValue</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.GetValueOrDefault(System.DateTimeOffset)">
            <summary>
            Overloaded. Returns the Value of the object, or a the passed in defaultValue.
            </summary>
            <returns>Current Value or passed in defaultValue.</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBDateTimeOffset)">
            <summary>
            Overloaded.  Returns the Value of the object, or the value of the passed in defaultValue.
            </summary>
            <param name="defaultValue"></param>
            <returns>VistaDBString</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.Value">
            <summary>
            The internal object that represents the DateTime
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDateTimeOffset.SystemType">
            <summary>
            System type (Dot Net runtime) for the Value - this is not the same as the VistaDBType
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBDate">
            <summary>
            The value of Date type that is wrapped into the class 
            and represents VistaDBType.Date
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDate.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDate.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDate.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or DateTime.MinValue.
            </summary>
            <returns>Current Value or DateTime.MinValue</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDate.GetValueOrDefault(System.DateTime)">
            <summary>
            Overloaded. Returns the Value of the object, or a the passed in defaultValue.
            </summary>
            <returns>Current Value or passed in defaultValue.</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDate.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBDate)">
            <summary>
            Overloaded.  Returns the Value of the object, or the value of the passed in defaultValue.
            </summary>
            <param name="defaultValue"></param>
            <returns>VistaDBString</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDate.Value">
            <summary>
            The internal object that represents the Date
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDate.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDate.SystemType">
            <summary>
            System type (Dot Net runtime) for the Value - this is not the same as the VistaDBType
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBTime">
            <summary>
            The value of DateTime type that is wrapped into the class 
            and represents VistaDBType.Date and VistaDBType.SmallDateTime
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBTime.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBTime.#ctor(System.TimeSpan)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBTime.#ctor(System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="val">Initial Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBTime.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a TimeSpan of 0 representing midnight.
            </summary>
            <returns>Current Value or DateTime.MinValue</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBTime.GetValueOrDefault(System.TimeSpan)">
            <summary>
            Overloaded. Returns the Value of the object, or a the passed in defaultValue.
            </summary>
            <returns>Current Value or passed in defaultValue.</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBTime.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBTime)">
            <summary>
            Overloaded.  Returns the Value of the object, or the value of the passed in defaultValue.
            </summary>
            <param name="defaultValue"></param>
            <returns>VistaDBString</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBTime.Value">
            <summary>
            The internal object that represents the Time
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBTime.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBTime.SystemType">
            <summary>
            System type (Dot Net runtime) for the Value - this is not the same as the VistaDBType
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBBoolean">
            <summary>
            The value of System.Bool type that is wrapped into the class 
            and represents VistaDBType.Bit
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBoolean.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBoolean.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBoolean.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or false if the Value is null.
            </summary>
            <returns>bool</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBoolean.GetValueOrDefault(System.Boolean)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.
            </summary>
            <returns>bool</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBoolean.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBBoolean)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>bool</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBBoolean.Value">
            <summary>
            The System.Bool type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBBoolean.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBBoolean.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBByte">
            <summary>
            The value of System.Byte type that is wrapped into the class 
            and represents VistaDBType.TinyInt
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBByte.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBByte.#ctor(System.Byte)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBByte.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or Byte.MinValue.
            </summary>
            <returns>Byte</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBByte.GetValueOrDefault(System.Byte)">
            <summary>
            Overloaded. Returns the Value of the object, or the defaultValue passed.
            </summary>
            <returns>Byte</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBByte.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBByte)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>Byte</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBByte.Value">
            <summary>
            The Byte type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBByte.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBByte.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBInt16">
            <summary>
            The value of System.Int16 type that is wrapped into the class 
            and represents VistaDBType.SmallInt
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt16.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt16.#ctor(System.Int16)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt16.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or Int16.MinValue.
            </summary>
            <returns>Int16</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt16.GetValueOrDefault(System.Int16)">
            <summary>
            Overloaded. Returns the Value of the object, or a newly created VistaDBInt16(defaultValue).
            </summary>
            <returns>Int16</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt16.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBInt16)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>Int16</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt16.Value">
            <summary>
            The Int16 type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt16.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt16.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBInt32">
            <summary>
            The value of System.Int32 type that is wrapped into the class 
            and represents VistaDBType.Int
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt32.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt32.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt32.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a newly created Int32.
            </summary>
            <returns>Int32</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt32.GetValueOrDefault(System.Int32)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed defaultValue.
            </summary>
            <returns>Int32</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt32.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBInt32)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>Int32</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt32.Value">
            <summary>
            The Int32 type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt32.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt32.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBInt64">
            <summary>
            The value of System.Int64 type that is wrapped into the class 
            and represents VistaDBType.BigInt
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt64.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt64.#ctor(System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt64.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a newly created Int64.
            </summary>
            <returns>Int64</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt64.GetValueOrDefault(System.Int64)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed defaultValue.
            </summary>
            <returns>Int64</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBInt64.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBInt64)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>Int64</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt64.Value">
            <summary>
            The Int64 type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt64.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBInt64.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBDecimal">
            <summary>
            The value of System.Decimal type that is wrapped into the class and 
            represents VistaDBType.Decimal, VistaDBType.Money and 
            VistaDBType.SmallMoney
            
            Note that VistaDB (and all .Net decimals) do not match the SQL Server spec 
            for decimal.  .Net does not track both precision and scale the same way 
            that SQL Server does.
            <seealso>Data Types and Mapping from SQL Server to VistaDB</seealso>
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDecimal.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDecimal.#ctor(System.Decimal)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDecimal.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a newly created decimal.
            </summary>
            <returns>decimal</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDecimal.GetValueOrDefault(System.Decimal)">
            <summary>
            Overloaded. Returns the Value of the object, or the passsed defaultValue.
            </summary>
            <returns>decimal</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDecimal.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBDecimal)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>decimal</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDecimal.Value">
            <summary>
            The Decimal type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDecimal.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDecimal.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBBinary">
            <summary>
            The value of System.Byte[] type that is wrapped into the class 
            and represents VistaDBType.VarBinary, VistaDBType.Binary, and VistaDBType.Image
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBinary.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBinary.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBinary.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a byte[0] set to 0.
            </summary>
            <returns>byte[]</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBinary.GetValueOrDefault(System.Byte[])">
            <summary>
            Overloaded. Returns the Value of the object, or the passed defaultValue.
            </summary>
            <returns>byte[]</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBBinary.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBBinary)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>byte[]</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBBinary.Value">
            <summary>
            The VistaDBBinary type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBBinary.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBBinary.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBGuid">
            <summary>
            The value of System.Guid type that is wrapped into the class 
            and represents VistaDBType.UniqueIdentifier
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBGuid.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBGuid.#ctor(System.Guid)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBGuid.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a newly created Guid().
            </summary>
            <returns>Guid</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBGuid.GetValueOrDefault(System.Guid)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed defaultValue.
            </summary>
            <returns>Guid</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBGuid.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBGuid)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>Guid</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBGuid.Value">
            <summary>
            The VistaDBGuid type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBGuid.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBGuid.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBDouble">
            <summary>
            The value of System.Double type that is wrapped into the class 
            and represents VistaDBType.Float
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDouble.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDouble.#ctor(System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDouble.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a newly created double.
            </summary>
            <returns>double</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDouble.GetValueOrDefault(System.Double)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed defaultValue.
            </summary>
            <returns>double</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBDouble.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBDouble)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>double</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDouble.Value">
            <summary>
            The Double type converted to an object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDouble.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBDouble.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.VistaDBTypes.VistaDBSingle">
            <summary>
            The value of System.Single type that is wrapped into the class 
            and represents VistaDBType.Real
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBSingle.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBSingle.#ctor(System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="val">Predefined Value</param>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBSingle.GetValueOrDefault">
            <summary>
            Overloaded. Returns the Value of the object, or a newly created float.
            </summary>
            <returns>float</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBSingle.GetValueOrDefault(System.Single)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed defaultValue.
            </summary>
            <returns>float</returns>
        </member>
        <member name="M:VistaDB.VistaDBTypes.VistaDBSingle.GetValueOrDefault(VistaDB.VistaDBTypes.VistaDBSingle)">
            <summary>
            Overloaded. Returns the Value of the object, or the passed in defaultValue.Value.
            </summary>
            <returns>float</returns>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBSingle.Value">
            <summary>
            The Single type converted to object
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBSingle.Type">
            <summary>
            VistaDBType for the Value
            </summary>
        </member>
        <member name="P:VistaDB.VistaDBTypes.VistaDBSingle.SystemType">
            <summary>
            System type for the Value
            </summary>
        </member>
        <member name="T:VistaDB.DDA.DDAEventDelegate">
            <summary>
            Delegate method called by DDA during an event modification on tables
            </summary>
            <param name="eventDelegate">EventDelegate object</param>
            <param name="row">New row data in 'before' eventDelegates or current row data in 'after' eventDelegates</param>
            <returns>User's exception to markup proceed status. If null the modification process continues. 
            </returns>
        </member>
        <member name="T:VistaDB.DDA.DDAEventDelegateType">
            <summary>
            The event type being raised from the DDA Engine during a table operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.DDAEventDelegateType.BeforeInsert">
            <summary>
            Call event handler before insert operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.DDAEventDelegateType.AfterInsert">
            <summary>
            Call event handler after insert operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.DDAEventDelegateType.BeforeUpdate">
            <summary>
            Call event handler before update operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.DDAEventDelegateType.AfterUpdate">
            <summary>
            Call event handler after update operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.DDAEventDelegateType.BeforeDelete">
            <summary>
            Call event handler before delete operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.DDAEventDelegateType.AfterDelete">
            <summary>
            Call event handler after delete operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.DDAEventDelegateType.NewVersion">
            <summary>
            Call event handler when new table version is found
            </summary>
        </member>
        <member name="T:VistaDB.DDA.VistaDBOperationStatusTypes">
            <summary>
            Status type for operation callbacks
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.IndexOperation">
            <summary>
            Building or updating table indexes
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.DataExportOperation">
            <summary>
            Engine is currently exporting individual rows of data
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.DataImportOperation">
            <summary>
            Data Import of rows into a table
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.SchemaChangeOperation">
            <summary>
            Performing changes on schema objects
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.SyncDataOperation">
            <summary>
            Sync of data
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.SyncSchemaOperation">
            <summary>
            Sync of schema for database
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.FullTextOperation">
            <summary>
            Full text operations including index builds, updates, etc.
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.ConstraintOperation">
            <summary>
            Database constraints are being built or applied
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.BinaryOperation">
            <summary>
            Binary operations to disk, including import or export of BLOBs
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.EncryptOperation">
            <summary>
            Encryption of data 
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.TransactionOperation">
            <summary>
            Transactional changes, including log truncation, rollback, commit, cleanup
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.SqlProcOperation">
            <summary>
            Long running SQL Proc operations
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.ClrProcOperation">
            <summary>
            Operation requiring extended calls to CLR Procs
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.BackupOperation">
            <summary>
            Database backup operation
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.RowOperation">
            <summary>
            Operations that require long running Row changes (defaults, constraint application, referential integrity tests, etc)
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.ViewOperation">
            <summary>
            Building or updating views in database
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBOperationStatusTypes.FreeSpaceOperation">
            <summary>
            Building or reclaiming free space within the database
            </summary>
        </member>
        <member name="T:VistaDB.DDA.OperationCallbackDelegate">
            <summary>
            Delegate method to pass progress status and other information by DDA 
            in time consuming operations
            </summary>
        </member>
        <member name="T:VistaDB.DDA.VistaDBReferentialIntegrity">
            <summary>
            The referential integrity mode types
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBReferentialIntegrity.None">
            <summary>
            No action taken on related rows.
            The core engine raises exception 
            when trying to delete or update the primary 
            key with a value that is not referenced by 
            foreign key
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBReferentialIntegrity.Cascade">
            <summary>
            When set, the engine deletes or updates 
            related foreign keys
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBReferentialIntegrity.SetNull">
            <summary>
            When set, the engine sets the values of
            related foreign keys to the nulls
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBReferentialIntegrity.SetDefault">
            <summary>
            When set, the engine tries to set the values of
            related foreign keys to the respective default values. 
            Afterward it checks the primary reference in according 
            with NoAction
            </summary>
        </member>
        <member name="T:VistaDB.DDA.IVistaDBPipe">
            <summary>
            The user-defined data channel to accept data issued by CLR Proc or CLR Trigger working with DDA
            </summary>
        </member>
        <member name="M:VistaDB.DDA.IVistaDBPipe.Send(System.Object)">
            <summary>
            May be called by CLR Proc or CLR Trigger to send data reader to the caller
            </summary>
            <param name="usersObject">The object to treat by caller</param>
        </member>
        <member name="T:VistaDB.DDA.VistaDBXmlReadMode">
            <summary>
            XML read mode
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBXmlReadMode.All">
            <summary>
            Reads XML schema and data
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBXmlReadMode.DataOnly">
            <summary>
            Reads XML data only respecting current database schema
            </summary>
        </member>
        <member name="T:VistaDB.DDA.VistaDBXmlWriteMode">
            <summary>
            XML write mode
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBXmlWriteMode.All">
            <summary>
            Writes XML schema and data
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBXmlWriteMode.SchemaOnly">
            <summary>
            Writes XML schema only
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBXmlWriteMode.DataOnly">
            <summary>
            Writes XML data only
            </summary>
        </member>
        <member name="T:VistaDB.DDA.VistaDBEngine">
            <summary>
            Core VistaDB engine class. Manages DDA connections.
            </summary>
            <example>
            This sample shows how to work with DDA.
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            using System;
            using VistaDB.DDA;
            using VistaDB.Diagnostic;
                  public class MyClass
                       {
                       	internal static readonly IVistaDBDDA DDAObj =
                                            VistaDBEngine.Connections.OpenDDA();
            
                       	private string vdbException = &quot;VistaDB Exception:&quot; + 
            &quot;\n&quot;;
                       	private string netException = &quot;.NET Exception:&quot; + 
            &quot;\n&quot;;
            
                       	public void DoWork(string databaseName)
                       	{
                       		try
                       		{
                       			IVistaDBDatabase db = DDAObj.OpenDatabase
                                  (databaseName, 
            VistaDBDatabaseOpenMode.NonExclusiveReadWrite, null);
            
                       			try
                       			{
                       				// do some work here
                       			}
                       			finally
                       			{
                       				db.Dispose();
                       			}
                       		}
                       		catch(VistaDBException ex)
                       		{
                       			MessageBox.Show(vdbException + ex.Message);
                       		}
                       		catch(Exception ex)
                       		{
                       			MessageBox.Show(netException + ex.Message);
                       		}
                       	}
                       }
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="F:VistaDB.DDA.VistaDBEngine.Connections">
            <summary>
            Collection of opened DDA connections.
            </summary>
        </member>
        <member name="F:VistaDB.DDA.VistaDBEngine.nextEngineId">
            <summary>
            Unique connection identification
            </summary>
        </member>
        <member name="M:VistaDB.DDA.VistaDBEngine.OpenDDA">
            <summary>
            Open a new DDA connection.  You may wish to instantiate one DDA object 
            globally in your namespace and share it.
            <seealso>Class VistaDBEngine                                                             </seealso>
            </summary>
            <returns>IVistaDBDDAConnection instance</returns>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            using System;
            using VistaDB.DDA;
            using VistaDB.Diagnostic;
                  public class MyClass
                       {
                       	internal static readonly IVistaDBDDA DDAObj =
                                            VistaDBEngine.Connections.OpenDDA();
            
                       	private string vdbException = &quot;VistaDB Exception:&quot; + 
            &quot;\n&quot;;
                       	private string netException = &quot;.NET Exception:&quot; + 
            &quot;\n&quot;;
            
                       	public void DoWork(string databaseName)
                       	{
                       		try
                       		{
                       			IVistaDBDatabase db = DDAObj.OpenDatabase
                                  (databaseName, 
            VistaDBDatabaseOpenMode.NonExclusiveReadWrite, null);
            
                       			try
                       			{
                       				// do some work here
                       			}
                       			finally
                       			{
                       				db.Dispose();
                       			}
                       		}
                       		catch(VistaDBException ex)
                       		{
                       			MessageBox.Show(vdbException + ex.Message);
                       		}
                       		catch(Exception ex)
                       		{
                       			MessageBox.Show(netException + ex.Message);
                       		}
                       	}
                       }
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.DDA.VistaDBEngine.OpenSQLConnection(VistaDB.Provider.VistaDBConnection,VistaDB.Engine.Internal.IDatabase)">
            <summary>
            Instantiates a local SQL connection
            </summary>
        </member>
        <member name="M:VistaDB.DDA.VistaDBEngine.Clear">
            <summary>
            Dispose collected DDA connections and remove them from engine collection
            </summary>
        </member>
        <member name="P:VistaDB.DDA.VistaDBEngine.Item(System.Int64)">
            <summary>
            Get existing DDA connection by connection id
            </summary>
        </member>
        <member name="P:VistaDB.DDA.VistaDBEngine.Count">
            <summary>
            Gets the number of live DDA connections.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBCommand">
            <summary>
            Represents a SQL statement to execute against a VistaDB database.  This class cannot be inherited.
            </summary>
            <example>
            The following example creates a new command object and associates it with a given VistaDBConnection object
            <code>
            public VistaDBCommand CreateCommand(VistaDBConnection connection)
            {
            	VistaDBCommand command = new VistaDBCommand();
            	command.Connection = connection;
            	command.CommandText = "select * from customers";
            	return command;
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.#ctor">
            <summary>
            Initializes a new instance of the VistaDBCommand class.
            </summary>
            <example>
            The following example creates a new command object and associates it with a given VistaDBConnection object
            <code>
            public VistaDBCommand CreateCommand(VistaDBConnection connection)
            {
            	VistaDBCommand command = new VistaDBCommand();
            	command.Connection = connection;
            	command.CommandText = "select * from customers";
            	return command;
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.#ctor(System.String)">
            <summary>
            Initializes a new instance of the VistaDBCommand class with the text of the query.
            </summary>
            <param name="commandText">The text of the query.</param>
            <example>
            The following example creates a new command object and associates it with a given VistaDBConnection object
            <code>
            public VistaDBCommand CreateCommand(VistaDBConnection connection)
            {
            	return new VistaDBCommand("select * from customers", connection);
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.#ctor(System.String,VistaDB.Provider.VistaDBConnection)">
            <summary>
            Initializes a new instance of the VistaDBCommand class with the text of the query and a VistaDBConnection.
            </summary>
            <param name="commandText">The text of the query.</param>
            <param name="connection">A VistaDBConnection that represents the connection to an instance of VistaDB Database. </param>
            <example>
            The following example creates a SqlCommand and associated it with VistaDBConnection object
            <code>
            public VistaDBCommand CreateCommand(VistaDBConnection connection)
            {
            	return new VistaDBCommand("select * from customers", connection);
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.ResetCommandTimeout">
            <summary>
            Resets the CommandTimeout to its default value.
            </summary>
            <remarks>
            The current default value is 0 which means to wait indefinitely for a command to execute.
            </remarks>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.Cancel">
            <summary>
            Attempts to cancel the execution of a query, if no query is running this call does nothing.
            Cancel will also cause the VistaDBDataReader object to discard any unread rows.
            </summary>
            <seealso>VistaDBDataReader</seealso>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.CreateParameter">
            <summary>
            Creates a new instance of a VistaDBParameter object.
            </summary>
            <returns>A VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.ExecuteReader">
            <summary>
            Executes the CommandText against the Connection, and returns an VistaDBDataReader. 
            </summary>
            <returns>A VistaDBDataReader object.</returns>
            <example>
            The following example creates a VistaDBCommand, and then executes it.
            <code>
            public void Execute(VistaDBCommand command)
            {
            	try
            	{
            		command.Connection.Open();
            		using(VistaDBDataReader reader = command.ExecuteReader())
            		{
            			while(reader.Read())
            			{
            				Console.WriteLine("{0}", reader[0]);
            			}
            		}
            	}
            	finally
            	{
            		command.Connection.Close();
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.ExecuteReader(System.Data.CommandBehavior)">
            <summary>
            Executes the CommandText against the Connection, and returns an VistaDBDataReader using one of the CommandBehavior values.
            </summary>
            <param name="behavior">One of the CommandBehavior values.</param>
            <returns>A VistaDBDataReader object.</returns>
            <example>
            The following example creates a VistaDBCommand, and then executes it.
            <code>
            public void Execute(VistaDBCommand command)
            {
            	command.Connection.Open();
            
            	using(VistaDBDataReader reader = command.ExecuteReader(CommandBehavior.CloseConnection))
            	{
            		while(reader.Read())
            		{
            			Console.WriteLine("{0}", reader[0]);
            		}
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.ExecuteNonQuery">
            <summary>
            Executes a SQL statement against a connection object.
            </summary>
            <returns>The number of rows affected.</returns>
            <example>
            The following example insert new row with using parameters
            <code>
            public void InsertRow(VistaDBConnection connection, long id_Customer)
            {
            	VistaDBCommand command = new VistaDBCommand();
            	command.Connection = connection;
            	command.CommandText = "INSERT INTO Orders (ID_Customer) VALUES (@ID_Customer)";
            	command.Parameters.Add("@ID_Customer", id_Customer);
            	command.ExecuteNonQuery();
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.ExecuteScalar">
            <summary>
            Executes the query and returns the first column of the first row in the result set returned by the query. All other columns and rows are ignored.
            </summary>
            <returns>The first column of the first row in the result set as an object.</returns>
            <example>
            The following example return row count for table Orders.
            <code>
            public int GetOrdersRowCount(VistaDBConnection connection)
            {
            	VistaDBCommand command = new VistaDBCommand("SELECT COUNT(*) FROM Orders", connection);
            	object result = command.ExecuteScalar();
            	// Test if the result came back as null
            	if( result != null )
            		return( (int) result);
            	
            	return( -1 );
            }
            </code>
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.Prepare">
            <summary>
            Creates a prepared version of the command on the data source.
            </summary>
            <seealso cref="T:VistaDB.Provider.VistaDBCommand"/>
            <notes>This is actually not very effective for most VistaDB commands at this time.  You should measure the impact on your code
            and decide if you want to do this or not.</notes>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.CreateDbParameter">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.Dispose(System.Boolean)">
            <summary>
            Dispose the object - then call the base object to tell it to release as well
            </summary>
            <param name="disposing">Are we within a disposing statement?</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.ExecuteDbDataReader(System.Data.CommandBehavior)">
            <summary>
            
            </summary>
            <param name="behavior"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.CompactifyQueryText(System.String,System.Int32)">
            <summary>
            Compacts the text of a SQL command by trimming start and end whitespace (and single-line comments) of lines
            and joining them into a single line (with optional truncationLength limit).
            </summary>
            <param name="queryText">The formatted SQL text to compactify.</param>
            <param name="truncateLength">The length at which to truncate the result (appending "(...)" if needed).
            Use 0 to disable truncation.</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommand.FormatDbValue(System.Object)">
            <summary>
            Create an optimal string form of the provided DB parameter value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.CommandText">
            <summary>
            Gets or sets the text command to run against the data source.
            </summary>
            <example>
            The following example creates a new command object and associates it with a given VistaDBConnection object
            <code>
            public VistaDBCommand CreateCommand(VistaDBConnection connection)
            {
            	VistaDBCommand command = new VistaDBCommand();
            	command.Connection = connection;
            	command.CommandText = "select * from customers";
            	return command;
            }
            </code>
            </example>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.CommandTimeout">
            <summary>
            Gets or sets the time to wait in seconds before stopping a command execution.  
            This is not used in the current engine, but will be used in a future version.
            </summary>
            <remarks>
            CommandTimeout is ignored when the command is executed asynchronously.
            The default value of 0 means to wait indefinitely for the command to complete and is the current behavior.
            </remarks>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.CommandType">
            <summary>
            Indicates or specifies how the CommandText property is interpreted.
            VistaDB supports only Text and StoredProcedures command types.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.Connection">
            <summary>
            Gets or sets the VistaDBConnection used by this VistaDBCommand. 
            </summary>
            <example>
            The following example creates a new command object and associates it with a given VistaDBConnection object
            <code>
            public VistaDBCommand CreateCommand(VistaDBConnection connection)
            {
            	VistaDBCommand command = new VistaDBCommand();
            	command.Connection = connection;
            	command.CommandText = "select * from customers";
            	return command;
            }
            </code>
            </example>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.DesignTimeVisible">
            <summary>
            This property is not intended to be used in your code. It is used internally to support the designers.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.HasDDLCommands">
            <summary>
            True if command has DDL commands
            </summary>
            <example>
            The following example will write information about whether the database structure will be changed by executing this query.
            <code>
            public void CheckDDL(VistaDBConnection connection)
            {
            	VistaDBCommand command = new VistaDBCommand(string.Empty, connection);
            
            	//Check first query
            	command.CommandText = "CREATE TABLE Orders (ID_Order Integer NOT NULL IDENTITY(1, 1) PRIMARY KEY, ID_Customer Integer)";
            	if(command.HasDDLCommands)
            		Console.WriteLine("Query has DDL commands");
            	else
            		Console.WriteLine("Query does not have DDL commands");
            }
            </code>
            Output:
            <para>Query has DDL commands</para>
            </example>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.Parameters">
            <summary>
            Gets the collection of VistaDBParameter objects. 
            </summary>
            <example>
            The following example insert new row with using parameters
            <code>
            public void InsertRow(VistaDBConnection connection, long id_Customer)
            {
            	VistaDBCommand command = new VistaDBCommand();
            	command.Connection = connection;
            	command.CommandText = "INSERT INTO Orders (ID_Customer) VALUES (@ID_Customer)";
            	command.Parameters.Add("@ID_Customer", id_Customer);
            	command.ExecuteNonQuery();
            }
            </code>
            </example>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.Transaction">
            <summary>
            Gets or sets the VistaDBTransaction within which this VistaDBCommand object executes.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.UpdatedRowSource">
            <summary>
            Gets or sets how command results are applied to the DataRow when used by the Update method of a VistaDBDataAdapter.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.DbConnection">
            <summary>
            
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.DbParameterCollection">
            <summary>
            
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommand.DbTransaction">
            <summary>
            
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBCommandBuilder">
            <summary>
            Automatically generates single-table commands that are used to reconcile 
            changes made to a DataSet with the associated VistaDB database. This class 
            cannot be inherited.
            </summary>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;Private Sub Example(ByVal 
            SelectString As String, ByVal ConString As String)
            	Me.mAdapter = New VistaDB.Provider.VistaDBDataAdapter
            	Me.mAdapter.SelectCommand = New 
            VistaDB.Provider.VistaDBCommand(SelectString, New 
            VistaDBConnection(ConString))
            	Dim cmdBuilder As VistaDB.Provider.VistaDBCommandBuilder = New 
            VistaDB.Provider.VistaDBCommandBuilder(Me.mAdapter)
            	Me.mAdapter.InsertCommand = cmdBuilder.GetInsertCommand
            	Me.mAdapter.UpdateCommand = cmdBuilder.GetUpdateCommand
            	Me.mAdapter.DeleteCommand = cmdBuilder.GetDeleteCommand
            	Me.mAdapter.MissingSchemaAction = MissingSchemaAction.AddWithKey
            
            	' ORDER IS VERY IMPORTANT HERE STEP THEN SEED
            	mData = New DataSet
            	mAdapter.Fill(mData)
            	mData.Tables!Table.Columns!ID.AutoIncrement = True
            	mData.Tables!Table.Columns!ID.AutoIncrementStep = -1
            	mData.Tables!Table.Columns!ID.AutoIncrementSeed = -1
            	mData.Tables!Table.Columns!ID.ReadOnly = False
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            static void Example( string SelectString, string ConnString )
            {
            	VistaDBDataAdapter mAdapter = new VistaDBDataAdapter();
            	mAdapter.SelectCommand = new VistaDBCommand(SelectString, new 
            VistaDBConnection(ConnString));
            	VistaDBCommandBuilder cmdBuilder = new VistaDBCommandBuilder(mAdapter);
            
            	mAdapter.InsertCommand = cmdBuilder.GetInsertCommand();
            	mAdapter.UpdateCommand = cmdBuilder.GetUpdateCommand();
            	mAdapter.DeleteCommand = cmdBuilder.GetDeleteCommand();
            	mAdapter.MissingSchemaAction = System.Data.MissingSchemaAction.AddWithKey;
            
            	DataSet mData = new DataSet();
            	mAdapter.Fill(mData);
            	// NOTE: The order of these two is IMPORTANT
            	// STEP MUST come before SEED
            	mData.Tables[0].Columns[0].AutoIncrementStep = -1;
            	mData.Tables[0].Columns[0].AutoIncrementSeed = -1;
            	mData.Tables[0].Columns[0].ReadOnly = false;
            }
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
            If you use a DataSet and are setting AutoIncrementStep and 
            AutoIncrementSeed values you MUST set them in the right order as noted 
            here:
            
            &lt;&lt;a 
            href=&quot;http://msdn2.microsoft.com/en-us/library/system.data.datacolumn.
            autoincrementseed.aspx&quot; 
            target=&quot;top&quot;&gt;&gt;http://msdn2.microsoft.com/en-us/library/syst
            em.data.datacolumn.autoincrementseed.aspx&lt;&lt;/a&gt;&gt;
            
            When modifying the AutoIncrement properties of a column after the table has
             been filled, it is important to set the AutoIncrementStep first, before 
            the AutoIncrementSeed. This is because the effect of setting the 
            AutoIncrementSeed changes based on the value of AutoIncrementStep.
            
            For example, a common pattern is to set AutoIncrementSeed and 
            AutoIncrementStep to -1, so that there is no chance of new rows conflicting
             with existing rows. However, if you set the AutoIncrementSeed first, and 
            then the AutoIncrementStep, the value of AutoIncrementSeed is ignored.
            
            This is the progression that illustrates the problem:
            
            &lt;&lt;ul&gt;&gt;
            &lt;&lt;li&gt;&gt; The table is created during a call to DbAdapter.Fill. At
             this point, the AutoIncrementSeed is 0 and the AutoIncrementStep is 1.
            &lt;&lt;li&gt;&gt; As rows are added to the table during the fill, the 
            value of an internal variable called autoIncrementCurrent is incremented so
             that it is always at least 1 greater than the greatest existing value in 
            the column.
            &lt;&lt;li&gt;&gt; AutoIncrementSeed is set to -1. At this point, the 
            column compares the new value of AutoIncrementSeed to the value of 
            autoIncrementCurrent. Since autoIncrementCurrent is greater than 
            AutoIncrementSeed, AND AutoIncrementStep is greater than 0, the column 
            assumes that the generated values have already passed the seed value, and 
            so it does NOT reset autoIncrementCurrent.
            &lt;&lt;li&gt;&gt; AutoIncrementStep is set to -1.
            &lt;&lt;li&gt;&gt; A new row is inserted. The value of the identity column 
            is set to autoIncrementCurrent + AutoIncrementStep, which will be equal to 
            the greatest value currently in the table, causing a constraint violation.
            &lt;&lt;li&gt;&gt; By setting the AutoIncrementStep to -1 first, when the 
            AutoIncrementSeed is set, the column sees that the new seed value is 
            &quot;farther along&quot; (i.e. more negative) than autoIncrementCurrent, 
            and so it resets autoIncrementCurrent to the new value of 
            AutoIncrementSeed.
            &lt;&lt;/ul&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.#ctor">
            <summary>
            Initializes a new instance of the VistaDBCommandBuilder class.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.#ctor(VistaDB.Provider.VistaDBDataAdapter)">
            <summary>
            Initializes a new instance of the VistaDBCommandBuilder class with the associated VistaDBDataAdapter object.
            </summary>
            <param name="dataAdapter">VistaDBDataAdapter object.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetDeleteCommand">
            <summary>
            Gets the automatically generated VistaDBCommand object required to perform deletions at the data source.
            </summary>
            <returns>The automatically generated VistaDBCommand object required to perform deletions.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetDeleteCommand(System.Boolean)">
            <summary>
            Gets the automatically generated VistaDBCommand object required to perform deletions at the data source, optionally using columns for parameter names.
            </summary>
            <param name="useColumnsForParameterNames">If true, generate parameter names matching column names, if possible. If false, generate @p1, @p2, and so on.</param>
            <returns>The automatically generated VistaDBCommand object required to perform deletions.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetInsertCommand">
            <summary>
            Gets the automatically generated VistaDBCommand object required to perform insertions at the data source.
            </summary>
            <returns>The automatically generated VistaDBCommand object required to perform insertions.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetInsertCommand(System.Boolean)">
            <summary>
            Gets the automatically generated VistaDBCommand object required to perform insertions at the data source, optionally using columns for parameter names.
            </summary>
            <param name="useColumnsForParameterNames">If true, generate parameter names matching column names, if possible. If false, generate @p1, @p2, and so on.</param>
            <returns>The automatically generated VistaDBCommand object required to perform insertions.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetUpdateCommand">
            <summary>
            Gets the automatically generated VistaDBCommand object required to perform updates at the data source.
            </summary>
            <returns>The automatically generated VistaDBCommand object required to perform updates.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetUpdateCommand(System.Boolean)">
            <summary>
            Gets the automatically generated VistaDBCommand object required to perform updates at the data source, optionally using columns for parameter names.
            </summary>
            <param name="useColumnsForParameterNames">If true, generate parameter names matching column names, if possible. If false, generate @p1, @p2, and so on.</param>
            <returns>The automatically generated VistaDBCommand object required to perform updates.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.QuoteIdentifier(System.String)">
            <summary>
            Given an unquoted identifier in the correct catalog case, returns the correct quoted form of that identifier, including properly escaping any embedded quotes in the identifier.
            </summary>
            <param name="unquotedIdentifier">The original unquoted identifier.</param>
            <returns>The quoted version of the identifier. Embedded quotes within the identifier are properly escaped.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.UnquoteIdentifier(System.String)">
            <summary>
            Given a quoted identifier, returns the correct unquoted form of that identifier, including properly un-escaping any embedded quotes in the identifier.
            </summary>
            <param name="quotedIdentifier">The identifier that will have its embedded quotes removed.</param>
            <returns>The unquoted identifier, with embedded quotes properly un-escaped.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.ApplyParameterInfo(System.Data.Common.DbParameter,System.Data.DataRow,System.Data.StatementType,System.Boolean)">
            <summary>
            
            </summary>
            <param name="parameter"></param>
            <param name="row"></param>
            <param name="statementType"></param>
            <param name="whereClause"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetParameterName(System.Int32)">
            <summary>
            
            </summary>
            <param name="parameterOrdinal"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetParameterName(System.String)">
            <summary>
            
            </summary>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.GetParameterPlaceholder(System.Int32)">
            <summary>
            
            </summary>
            <param name="parameterOrdinal"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.SetRowUpdatingHandler(System.Data.Common.DbDataAdapter)">
            <summary>
            
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBCommandBuilder.DeriveParameters(VistaDB.Provider.VistaDBCommand)">
            <summary>
            Given a VistaDBCommand object derive the parameters from the object.  
            This is used by some of the GUI designers and other tools to determine the list of parameters in stored procedures.
            </summary>
            <param name="command">VistaDBCommand object to pull the parameters from.</param>
            <seealso cref="T:VistaDB.Provider.VistaDBCommand"/>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommandBuilder.DataAdapter">
            <summary>
            Gets or sets a VistaDBDataAdapter object for which SQL statements are automatically generated.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommandBuilder.SchemaSeparator">
            <summary>
            The default Schema Separator is a period (.). The only acceptable value for this property is a period (.).
            This is the character that should be used as a separator between schema identifiers and other objects.
            tablename.columname is an example of the usage.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommandBuilder.QuotePrefix">
            <summary>
            Gets or sets the beginning character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.
            VistaDB supports only "[" as quote prefix
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBCommandBuilder.QuoteSuffix">
            <summary>
            Gets or sets the beginning character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.
            VistaDB supports only "]" as quote suffix
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBConnection">
            <summary>
            Represents an open connection to a VistaDB database. This class cannot be 
            inherited.  By default connection pools will be utilized to speed up 
            connection open timings.
            
            It is considered a best practice to close the connection as soon as you are
             finished with it.  Do NOT place the .Close()  call in a Finalizer or 
            object destructor.  Both of those are non-deterministic (you cannot predict
             when or if they will be called).   This leads to connection handle leaks 
            over the lifetime of an application.
            
            Best practice is to place all Connections within a using() block to ensure 
            they are cleaned up in a timely manner.
            </summary>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            using( VistaDB.Provider.VistaDBConnection connection =
              new VistaDB.Provider.VistaDBConnection(&quot;Data Source=&quot; + dbName)
             )
            {
            	connection.Open();
                // Do some work...
            }
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
            DO NOT place the Dispose() or Close() calls in a Finalizer or object destructor.  Both 
            of those are non-deterministic (you cannot predict when or if they will be 
            called). This leads to connection handle leaks over the lifetime of an 
            application, and possibly pinning the connection object in memory.
            
            Dispose calls effectively also Closes the connection.
            </remarks>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SystemSchema">
            <summary>
            System table name
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SystemTableType">
            <summary>
            System table type name
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.UserTableType">
            <summary>
            User table type name
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.PackDatabase(System.String,System.String,System.Boolean,VistaDB.DDA.OperationCallbackDelegate)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <param name="encryptionKeyString">
            String used as base for generating encryption crypto key. Null or Nothing 
            for non encrypted database.
            </param>
            <param name="backup">
            True to create a backup copy before packing.  The backup file will be named
                          the same as the original database, but with a .backupCopy 
            appended to the
                         end of the filename.  If the file exists it will be 
            overwritten.
            </param>
            <param name="operationCallbackDelegate">
            Operation Information delegate method giving feedback during long running 
            operations.
                         You may pass null or Nothing meaning there is no delegate to 
            callback.
            </param>
            <returns>void</returns>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            ' VB.NET Code
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
               DDAObj.PackDatabase(&quot;C:\dest.vdb3&quot;, Nothing, False, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            // C# Code
            public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, null, false, new 
            OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            }
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
             VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.PackDatabase(System.String,System.String,System.String,System.Int32,System.Int32,System.Boolean,System.Boolean,VistaDB.DDA.OperationCallbackDelegate)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the new 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <param name="encryptionKeyString">
            Current encryptionKey
            </param>
            <param name="newencryptionKeyString"></param>
            <param name="newPageSize">
            New page size.
                         Pass a 0 here to leave the page size at the current setting.
            </param>
            <param name="newLCID">
            New locale LocaleID.
                         Pass a value of 0 to leave the LocaleID with it's current 
            setting.
            </param>
            <param name="newCaseSensitive">
            New case sensitivity setting.  This cannot be null, so if you want to
                         preserve your case sensitivity you must pass the same value as
             the database
                          was created with initially.
            </param>
            <param name="backup">
            True to create a backup copy before packing.  The backup file will be named
                          the same as the original database, but with a .backupCopy 
            appended to the
                         end of the filename.  If the file exists it will be 
            overwritten.
            </param>
            <param name="operationCallbackDelegate">
            Operation Information delegate method for feedback from pack progress.
                         You may pass null or Nothing meaning there is no delegate.
            </param>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                Dim OldPassword As String
                Dim NewPassword As String
                ' In this example we are modifying a database that had no encryptionKey
             to now have one
                ' Reverse to remove a encryptionKey
                OldCryptoPhrase = Nothing
                NewPhrase = &quot;pass.word&quot;
                DDAObj.PackDatabase(&quot;C:\test.vdb3&quot;, OldCryptoPhrase, 
            NewPhrase, 0, 0, True, True, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               string OldPhrase = null;
               string NewPhrase = &quot;pass.word&quot;;
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, OldPhrase, NewPhrase, pageSize, LCID, 
            caseSensitive, false, new OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            
            }
            
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
             VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.PackDatabase(System.String,VistaDB.DDA.OperationCallbackDelegate)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the new 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <param name="encryptionKeyString">
            Current encryptionKey
            </param>
            <param name="newencryptionKeyString"></param>
            <param name="newPageSize">
            New page size.
                         Pass a 0 here to leave the page size at the current setting.
            </param>
            <param name="newLCID">
            New locale LocaleID.
                         Pass a value of 0 to leave the LocaleID with it's current 
            setting.
            </param>
            <param name="newCaseSensitive">
            New case sensitivity setting.  This cannot be null, so if you want to
                         preserve your case sensitivity you must pass the same value as
             the database
                          was created with initially.
            </param>
            <param name="backup">
            True to create a backup copy before packing.  The backup file will be named
                          the same as the original database, but with a .backupCopy 
            appended to the
                         end of the filename.  If the file exists it will be 
            overwritten.
            </param>
            <param name="operationCallbackDelegate">
            Operation Information delegate method for feedback from pack progress.
                         You may pass null or Nothing meaning there is no delegate.
            </param>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                Dim OldPassword As String
                Dim NewPassword As String
                ' In this example we are modifying a database that had no encryptionKey
             to now have one
                ' Reverse to remove a encryptionKey
                OldCryptoPhrase = Nothing
                NewPhrase = &quot;pass.word&quot;
                DDAObj.PackDatabase(&quot;C:\test.vdb3&quot;, OldCryptoPhrase, 
            NewPhrase, 0, 0, True, True, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               string OldPhrase = null;
               string NewPhrase = &quot;pass.word&quot;;
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, OldPhrase, NewPhrase, pageSize, LCID, 
            caseSensitive, false, new OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            
            }
            
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
             VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.PackDatabase(System.String)">
            <summary>
            Pack database to compress free space in the database and reorganize the 
            internal layout of the database on disk.  This overload uses the new 
            OperationCallbackDelegate callback to give more information about the 
            packing progress.
            You may be prompted to pack the database if the file format has changed.
            <seealso>Interface IVistaDBDDA</seealso>
            </summary>
            <param name="fileName">
            Full database file name including path unless the database is in the local
                         directory.
            </param>
            <param name="encryptionKeyString">
            Current encryptionKey
            </param>
            <param name="newencryptionKeyString"></param>
            <param name="newPageSize">
            New page size.
                         Pass a 0 here to leave the page size at the current setting.
            </param>
            <param name="newLCID">
            New locale LocaleID.
                         Pass a value of 0 to leave the LocaleID with it's current 
            setting.
            </param>
            <param name="newCaseSensitive">
            New case sensitivity setting.  This cannot be null, so if you want to
                         preserve your case sensitivity you must pass the same value as
             the database
                          was created with initially.
            </param>
            <param name="backup">
            True to create a backup copy before packing.  The backup file will be named
                          the same as the original database, but with a .backupCopy 
            appended to the
                         end of the filename.  If the file exists it will be 
            overwritten.
            </param>
            <param name="operationCallbackDelegate">
            Operation Information delegate method for feedback from pack progress.
                         You may pass null or Nothing meaning there is no delegate.
            </param>
            <example>
            &lt;&lt;code lang=&quot;VB.NET&quot;&gt;&gt;
            Sub Main()
               Dim DDAObj As VistaDB.DDA.IVistaDBDDA
               DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA()
                Dim OldPassword As String
                Dim NewPassword As String
                ' In this example we are modifying a database that had no encryptionKey
             to now have one
                ' Reverse to remove a encryptionKey
                OldCryptoPhrase = Nothing
                NewPhrase = &quot;pass.word&quot;
                DDAObj.PackDatabase(&quot;C:\test.vdb3&quot;, OldCryptoPhrase, 
            NewPhrase, 0, 0, True, True, Nothing)
               ' You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(&quot;test.vdb3&quot;, Nothing, False, Nothing)
            End Sub
            &lt;&lt;/code&gt;&gt;
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public void PackingFunction
            {
               IVistaDBDDA DDAObj = VistaDB.DDA.VistaDBEngine.Connections.OpenDDA();
               string OldPhrase = null;
               string NewPhrase = &quot;pass.word&quot;;
               // You do not have to provide a path - Dot Net looks in the current 
            working directory by default.
               DDAObj.PackDatabase(fileName, OldPhrase, NewPhrase, pageSize, LCID, 
            caseSensitive, false, new OperationCallbackDelegate(this.OnPackInfo));
            }
            
            public void OnPackInfo( VistaDB.DDA.IVistaDBOperationCallbackInfo 
            operationDelegate )
            {
               if( operationDelegate.Progress &lt; 0 )
                  return;
            
               int ProgressPercent =  = operationDelegate.Progress;
            
               string ProgressText = String.Concat(&quot;Performing 
            &quot;,operationDelegate.Operation.ToString(),&quot; on 
            &quot;,operationDelegate.ObjectName.ToString(),&quot;:&quot;);
            
            }
            
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
             VB.NET does not have a NULL primitive.  You should always use Nothing in 
            place of NULL for VB.NET. To call these functions in C# you must include 
            the full namespace, or using  statements: &lt;&lt;pre&gt;&gt;
            using VistaDB;
            using VistaDB.DDA;
            &lt;&lt;/pre&gt;&gt;
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VistaDB.Provider.VistaDBConnection.RepairDatabase(System.String,System.String,VistaDB.DDA.OperationCallbackDelegate)" -->
        <!-- Badly formed XML comment ignored for member "M:VistaDB.Provider.VistaDBConnection.RepairDatabase(System.String,VistaDB.DDA.OperationCallbackDelegate)" -->
        <!-- Badly formed XML comment ignored for member "M:VistaDB.Provider.VistaDBConnection.RepairDatabase(System.String)" -->
        <member name="M:VistaDB.Provider.VistaDBConnection.ClearAllPools">
            <summary>
            Empties all of the connection pools associated with the current connection.
             This operation will Dispose of each of the pooled objects.
            
            This function should be called when you want to ensure ALL connections are 
            closed.  A good example is when your app needs to switch to a maintenance 
            mode and gain exclusive access to the database.  You would CloseAllPools(),
             close the connection, and then reopen with no pooling and exclusive mode 
            access.
            <seealso>Class VistaDBConnection                                                         </seealso>
            </summary>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            // Clear all pools must be done last or you are just adding to the pool by 
            closing the connection
            VistaDBConnection.ClearAllPools();
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.ClearPool(VistaDB.Provider.VistaDBConnection)">
            <summary>
            Empties a single connection pool associated with the specified connection.
            
            This may be useful if you are wanting to release a single connection string
             but keep other connections active in your application.
            <seealso>Class VistaDBConnection                                                         </seealso>
            </summary>
            <param name="connection">
            The VistaDBConnection to be cleared from the pool.
            </param>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            			using( VistaDBConnection conn = new VistaDBConnection(@&quot;Open 
            Mode=ExclusiveReadWrite;Min Pool Size=5;Data Source=&quot; + dbname) )
            			{
            
            				Assert.IsNotNull(conn);
            
            				conn.Open();
            
            				Assert.IsTrue(conn.State == ConnectionState.Open);
            
            				conn.Close();
            
            				VistaDBConnection.ClearPool(conn);
            			}
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.#ctor">
            <summary>
            Represents an open connection to a VistaDB database. This class cannot be 
            inherited.
            
            It is considered a best practice to close the connection as soon as you are
             finished with it.  Do NOT place the .Close() call in a Finalizer or object
             destructor.  Both of those are non-deterministic (you cannot predict when 
            or if they will be called). This leads to connection handle leaks over the 
            lifetime of an application.
            <seealso>Class VistaDBConnection</seealso>
            <seealso>VistaDBConnection.ClearAllPools</seealso>
            <seealso>VistaDBConnection.ClearPool</seealso>
            </summary>
            <example>
            The following example creates and opens a VistaDBConnection.
            
            &lt;&lt;pre&gt;&gt;
            public VistaDBConnection OpenConnection(string connectionString)
            {
            	VistaDBConnection connection = new VistaDBConnection(connectionString);
            	connection.Open();
            	return connection;
            }
            &lt;&lt;/pre&gt;&gt;
            </example>
            <remarks>
            If you have a connection with connection pooling enabled and you wish to 
            close all of them call the static function 
            VistaDBConnection.ClearAllPools();
            
            To clear a single pool instance you call the static function 
            VistaDBConnection.ClearPool( myConnection );  Where myConnection is a 
            properly initialized VistaDBConnection object.
            </remarks>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.#ctor(System.String)">
            <summary>
            Initializes a new instance of the VistaDBConnection class when given a string that contains the connection string.
            <para>It is considered a best practice to close the connection as soon as you are finished with it.  Do NOT place the .Close() 
            call in a Finalizer or object destructor.  Both of those are non-deterministic (you cannot predict when or if they will be called).  
            This leads to connection handle leaks over the lifetime of an application.</para>
            </summary>
            <param name="connectionString">The connection used to open the VistaDB database.</param>
            <example>
            The following example creates and opens a VistaDBConnection.
            <code>
            public VistaDBConnection OpenConnection(string connectionString)
            {
            	VistaDBConnection connection = new VistaDBConnection(connectionString);
            	connection.Open();
            	return connection;
            }
            </code>
            <remarks>
            <para>If you have a connection with connection pooling enabled and you wish to close all of them call the static function VistaDBConnection.ClearAllPools();</para>
            <para>To clear a single pool instance you call the static function VistaDBConnection.ClearPool( myConnection );  Where myConnection is a properly initialized VistaDBConnection object.</para>
            </remarks>
            </example>
            <seealso cref="M:VistaDB.Provider.VistaDBConnection.ClearAllPools"/>
            <seealso cref="M:VistaDB.Provider.VistaDBConnection.ClearPool(VistaDB.Provider.VistaDBConnection)"/>
            <seealso cref="P:VistaDB.Provider.VistaDBConnection.ConnectionString"/>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.#ctor(VistaDB.DDA.IVistaDBDatabase)">
            <summary>
            Initializes a new instance of VistaDBConnection class with given IVistaDBDatabase instance.
            When connection is closed, database stays opened. In order to close the database you 
            have to call Close method of respective IVistaDBDatabase instance.
            </summary>
            <param name="database">IVistaDBDatabase instance used for this connection.</param>
            <seealso cref="M:VistaDB.Provider.VistaDBConnection.ClearAllPools"/>
            <seealso cref="M:VistaDB.Provider.VistaDBConnection.ClearPool(VistaDB.Provider.VistaDBConnection)"/>
            <seealso cref="T:VistaDB.DDA.IVistaDBDatabase"/>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.SetOptimizationLevel(System.String)">
            <summary>
            (BETA ONLY) Change the current optimization setting of this (open) VistaDBConnection.
            This setting can also be changed by executing the "SET OPTIMIZATION {0}" SQL command with the desired option.
            </summary>
            <param name="optimizationLevel">The desired optimization level as a string.  Currently supported values
            (case-insensitive): "Off", "Original"/"Orig", "Old", "On"/"New".</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.BeginTransaction">
            <summary>
            Starts a database transaction on the current connection.
            
            Because BeginTransaction creates a new transaction and associates it with 
            the current connection that created it, you can simplify your code by using
             this method rather than allocating a new transaction and then assigning it
             manually.
            <seealso>Class VistaDBConnection</seealso>
            </summary>
            <returns>An object representing the new transaction.</returns>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            VistaDBTransaction trans = conn.BeginTransaction();
            &lt;&lt;/code&gt;&gt;
            Is the same as:
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            VistaDBTransaction trans = new VistaDBTranscation();
            trans.Connection = conn;
            trans.Begin();
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Starts a database transaction.
            </summary>
            <param name="isolationLevel">Specifies the isolation level for the transaction.
            VistaDB supports only ReadCommited isolation level. Any other isolation level will result in a VistaDBSQLException.</param>
            <returns>An object representing the new transaction.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.ChangeDatabase(System.String)">
            <summary>
            This method is not supported and should not be called.
            </summary>
            <param name="databaseName"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.Close">
            <summary>
            Closes the connection to the database.
            
            It is considered a best practice to close the database connection as soon 
            as you are finished with it. Putting the VistaDBConnection within a using()
             statement is the easiest way to ensure it is actively cleaned up fast.
            
            Do NOT place this call in an object destructor or Finalize call.  That will
             lead to non-deterministic release of object handles and potential 
            connection leaks.
            <seealso>Class VistaDBConnection</seealso>
            </summary>
            <example>
            The following example closes a VistaDBConnection.
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public void 
            CloseConnection(VistaDBConnection connection)
            {
            	connection.Close();
            }
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.CreateCommand">
            <summary>
            Creates and returns a new VistaDBCommand object associated with the current connection.
            </summary>
            <returns>A VistaDBCommand object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.GetTableSchema(System.String)">
            <summary>
            Gets the schema for a given table from the current open connection.
            </summary>
            <param name="tableName">Name of table to query, must already exist.</param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.GetSchema">
            <summary>
            Returns schema information for the data source of this VistaDBConnection.
            See the MSDN Topic "Understanding the Common Schema Collections" for in depth information about Schema collections.
            <seealso>Class VistaDBConnection</seealso>
            </summary>
            <returns>A DataTable that contains schema collection information</returns>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            	using( VistaDB.Provider.VistaDBConnection connection =
                   new VistaDB.Provider.VistaDBConnection(&quot;Data Source=&quot; + 
            dbName) )
            	{
            		connection.Open();
            		// Get the list of Schema collections and their restrictions from the connection
            		DataTable schema = connection.GetSchema();
                    Assert.IsNotEmpty(schema.Rows);
            
                    foreach (DataRow myField in schema.Rows)
                    {
                        foreach (DataColumn myProperty in schema.Columns)
                        {
                            Console.WriteLine(myProperty.ColumnName +
                                 &quot; = &quot; + myField[myProperty].ToString());
                        }
                    }
            	}
            &lt;&lt;/code&gt;&gt;
            
            The above will output a console list like this listed below:
            
            CollectionName = ForeignKeys
            NumberOfRestrictions = 4
            NumberOfIdentifierParts = 3
            
            CollectionName = ForeignKeyColumns
            NumberOfRestrictions = 5
            NumberOfIdentifierParts = 4
            
            CollectionName = ReservedWords
            NumberOfRestrictions = 0
            NumberOfIdentifierParts = 0
            
            CollectionName = Views
            NumberOfRestrictions = 3
            NumberOfIdentifierParts = 3
            
            CollectionName = ViewColumns
            NumberOfRestrictions = 4
            NumberOfIdentifierParts = 4
            
            CollectionName = Restrictions
            NumberOfRestrictions = 0
            NumberOfIdentifierParts = 0
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.GetSchema(System.String)">
            <summary>
            Returns schema information for the data source of this VistaDBConnection 
            using the specified string for the schema name and the specified string 
            array for the restriction values.
            
            Examples schema that may be requested are:
            
            RESERVEDWORDS - list of words reserved for usage by the engine
            COLUMNS - List of columns
            DATATYPES - Types in usage by the current engine
            VIEWS - Views in the current database
            FOREIGNKEYS - Lists of foreign keys in database
            <seealso>Class VistaDBConnection</seealso>
            </summary>
            <param name="collectionName">
            Specifies the name of the schema to return.
            </param>
            <returns>A DataTable that contains schema information.</returns>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
                using (VistaDBConnection cn =
                         new VistaDBConnection(&quot;Data 
            Source=|DataDirectory|Database1.vdb5;&quot;))
                {
                    cn.Open();
            
            		DataTable schema = cn.GetSchema(&quot;FOREIGNKEYS&quot;);
                    foreach (DataRow dr in schema.Rows)
                    {
                        foreach (DataColumn dc in schema.Columns)
                        {
                            Console.WriteLine(dc.ColumnName + &quot; = &quot; + 
            dr[dc].ToString());
                        }
                    }
                 }
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.GetSchema(System.String,System.String[])">
            <summary>
            Returns schema information for the data source of this VistaDBConnection 
            using the specified string for the schema name and the specified string 
            array for the restriction values.
            
            Examples schema that may be requested are:
            
            RESERVEDWORDS - list of words reserved for usage by the engine
            COLUMNS - List of columns
            DATATYPES - Types in usage by the current engine
            VIEWS - Views in the current database
            FOREIGNKEYS - Lists of foreign keys in database
            <seealso>Class VistaDBConnection</seealso>
            </summary>
            <param name="collectionName">
            Specifies the name of the schema to return.
            </param>
            <param name="restrictionValues">
            Values to restrict for this lookup.  See MSDN docs for more help on restricting collections.
            </param>
            <returns>A DataTable that contains schema information.</returns>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
                using (VistaDBConnection cn =
                         new VistaDBConnection(&quot;Data 
            Source=|DataDirectory|Database1.vdb5;&quot;))
                {
                    cn.Open();
            
            		DataTable schema = cn.GetSchema(&quot;FOREIGNKEYS&quot;);
                    foreach (DataRow dr in schema.Rows)
                    {
                        foreach (DataColumn dc in schema.Columns)
                        {
                            Console.WriteLine(dc.ColumnName + &quot; = &quot; + 
            dr[dc].ToString());
                        }
                    }
                 }
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.IsSyntaxCorrect(System.String,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Check SQL command correctness.  This does not actually execute the command or validate the structures on disk.
            It only parsers the command and attempts to verify that the parser can split the tokens or not.
            </summary>
            <param name="text">SQL Command Text</param>
            <param name="lineNo">Line number in the text, where mistake occurred</param>
            <param name="symbolNo">Symbol number in the text, where mistake occurred</param>
            <param name="errorMessage">Error message</param>
            <returns>Returns true if syntax is correct otherwise returns false</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.IsViewSyntaxCorrect(System.String,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Check SQL command correctness of CREATE VIEW statement
            </summary>
            <param name="text">SQL Command Text</param>
            <param name="lineNo">Line number in the text, where mistake occurred</param>
            <param name="symbolNo">Symbol number in the text, where mistake occurred</param>
            <param name="errorMessage">Error message</param>
            <returns>Returns true if syntax is correct otherwise returns false</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.IsConstraintSyntaxCorrect(System.String,System.Int32@,System.Int32@,System.String@)">
            <summary>
            Check SQL command of the constraint to validate it is correct.
            </summary>
            <param name="text">SQL Command Text</param>
            <param name="lineNo">Line number in the text, where mistake occurred</param>
            <param name="symbolNo">Symbol number in the text, where mistake occurred</param>
            <param name="errorMessage">Error message</param>
            <returns>Returns true if syntax is correct otherwise returns false</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.Open">
            <summary>
            Opens a database connection with the settings specified by the ConnectionString. By default the provider will attempt to open
            a connection from a connection pool object if one exists.  This caching of connections can lead to increased performance, 
            but may not be used with Exclusive Mode Connections.
            </summary>
            <example>
            The following example creates and opens a VistaDBConnection.
            <code>
            public VistaDBConnection OpenConnection(string connectionString)
            {
            	VistaDBConnection connection = new VistaDBConnection(connectionString);
            	connection.Open();
            	return connection;
            }
            </code>
            </example>
            <seealso cref="T:VistaDB.Provider.VistaDBConnection"/>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.OnPrintMessage(System.String)">
            <summary>
            Internal call to notify users if a SQL PRINT statement has been executed.
            </summary>
            <param name="message">Message to transmit to the callback</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.BeginDbTransaction(System.Data.IsolationLevel)">
            <summary>
            Starts a database transaction.
            </summary>
            <param name="isolationLevel"></param>
            <returns>DbTransaction handle</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.CreateDbCommand">
            <summary>
            Create a new DbCommand object from the current VistaDBConnection.
            </summary>
            <returns>DbCommand</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.Dispose(System.Boolean)">
            <summary>
            Dispose the object and release all resources.  A best practice for performing this automatically is to put all
            your VistaDBConnection objects within Using() statements to ensure they are cleaned up in a timely manner.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.GetSchemaReservedWords">
            <summary>
            This function is called when a Connection requested the schema for reserved words like this:
            connection.GetSchema("RESERVEDWORDS");
            </summary>
            <returns>DataTable with list of ReservedWords in use by VistaDB engine</returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.ConnectionString">
            <summary>
            Gets or sets the string used to open the connection.
            <seealso>Class VistaDBConnection</seealso>
            <seealso>Class VistaDBConnectionStringBuilder</seealso>
            </summary>
            <example>
            The following example creates a VistaDBConnection and sets the 
            ConnectionString property before opening the connection.
            
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;public VistaDBConnection 
            OpenConnection()
            {
            	string connectionString = @&quot;Data Source = C:\VistaDB.vdb3; Open Mode 
            = ExclusiveReadWrite&quot;;
            	VistaDBConnection connection = new VistaDBConnection(connectionString);
            	connection.Open();
            	return connection;
            }
            
            &lt;&lt;/code&gt;&gt;
            </example>
            <remarks>
            The following list shows the valid names for keyword values within the 
            ConnectionString. &lt;RAWHTML&gt;
            &lt;table border=&quot;1&quot; cellpadding=&quot;3&quot; 
            width=&quot;400&quot;&gt;
            &lt;tr&gt;&lt;td&gt;Data Source&lt;/td&gt;&lt;td&gt;Database file name. You
             may also use the |DataDirectory| tag (see below)&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Open Mode&lt;/td&gt;&lt;td&gt;Database open mode. Can 
            be one of the following values: ExclusiveReadWrite, ExclusiveReadOnly, 
            NonexclusiveReadWrite, NonexclusiveReadOnly and 
            SharedReadOnly.&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Password&lt;/td&gt;&lt;td&gt;String used to build encryption key for 
            encrypt\decrypt database content.&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Min Pool Size&lt;/td&gt;&lt;td&gt;The minimum number of
             connections allowed in the pool. Default value is 1.&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Pooling&lt;/td&gt;&lt;td&gt;Connection Pooling support 
            enabled status.  Default is disabled.&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Context Connection&lt;/td&gt;&lt;td&gt;May be assigned 
            only for CLR stored procedures. If set to true the context connection is 
            used.&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Isolated Storage&lt;/td&gt;&lt;td&gt;If it is set to 
            true the database placed in isolated storage.&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Transaction Mode&lt;/td&gt;&lt;td&gt;On, Off, or ignore
             for how the connection should treat transactions.&lt;/td&gt;&lt;/tr&gt;
            &lt;tr&gt;&lt;td&gt;Compatibility Mode&lt;/td&gt;&lt;td&gt;Legacy, Normal, or Strict
             for how the connection should handle syntax compatibility.&lt;/td&gt;&lt;/tr&gt;
            &lt;/table&gt;
            &lt;/RAWHTML&gt;
            
            
             The VistaDBConnectionStringBuilder class provides functionality for 
            creating and managing the contents of connection strings.
             Also look at this document from MSDN. &lt;&lt;%=TopicLink(&quot;Smart 
            Client Data&quot;,&quot;sig:Smart Client Data&quot;) %&gt;&gt;
            
             Basically what this document explains (and VistaDB supports) is the usage 
            of the |DataDirectory| variable.
            
            By default, the |DataDirectory| variable will be expanded as follow:
            
            &lt;&lt;ul&gt;&gt;
            &lt;&lt;li&gt;&gt; For applications placed in a directory on the user 
            machine, this will be the app's (.exe) folder.
            &lt;&lt;li&gt;&gt; For apps running under ClickOnce, this will be a special
             data folder created by ClickOnce
            &lt;&lt;li&gt;&gt; For Web apps, this will be the App_Data 
            folder&lt;/li&gt; Under the hood, the value for |DataDirectory| simply 
            comes from a property on the app domain.
            &lt;&lt;/ul&gt;&gt;
            It is possible to change that value and override the default behavior by 
            doing this:
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            AppDomain.CurrentDomain.SetData(&quot;DataDirectory&quot;, newpath)
            &lt;&lt;/code&gt;&gt;
            </remarks>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.ContextConnection">
            <summary>
            Used only inside CLR stored procedures.
            If it is set to true the context connection is used.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.Database">
            <summary>
            Get the name of the database.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.DataSource">
            <summary>
            Get the name of the database.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.IsolatedStorage">
            <summary>
            If it is set to true the database placed in isolated storage.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.TransactionMode">
            <summary>
            Gets the current TransactionMode for this connection.  
            Read only, may not be changed after opening the connection.
            <seealso>Class VistaDBConnection</seealso>
            <seealso>Class VistaDBConnectionStringBuilder</seealso>
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.OpenMode">
            <summary>
            Gets a value that indicates connection open mode.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.CompatibilityModeSetting">
            <summary>
            Gets the <see CREF="VistaDB.Provider.VistaDBConnection.CompatibilityMode">CompatibilityMode</see> setting
            from the connection string for this connection.
            Read only, may not be changed after opening the connection.
            <seealso>Class VistaDBConnection</seealso>
            <seealso>Class VistaDBConnectionStringBuilder</seealso>
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.Password">
            <summary>
            Get the string used for the base of the encryption key.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.ServerVersion">
            <summary>
            VistaDB version for connection information (We only really need major / minor here for client compatibility)
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.LockTimeout">
            <summary>
            An integer value that represents the time in seconds as the maximum time a transaction is locked.  
            10 seconds is the default, negative values reset to default. Maximum time is one hour.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.PersistentLockFiles">
            <summary>
            Control lifetime of .lck files on hard drive. 
            If it is set to true this connection will not try to delete these files upon table closing. 
            It may give some performance boosting in multi-user environment.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.State">
            <summary>
            Gets a value that describes the state of the connection.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.OptimizationLevel">
            <summary>
            (BETA ONLY) Get the current optimization setting of this (open) VistaDBConnection as a string.
            This string value will be an option which can be used with the "SET OPTIMIZATION {0}" command.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.OptimizationVersionLevel">
            <summary>
            (BETA ONLY) Get the current optimization setting of this (open) VistaDBConnection as a version string (or "Off").
            This string value will be the approximate version equivalent of the current optimization setting.
            </summary>
        </member>
        <member name="E:VistaDB.Provider.VistaDBConnection.InfoMessage">
            <summary>
            Callback event for SQL PRINT Statements
            <seealso>Class VistaDBConnection</seealso>
            <seealso>Class VistaDBInfoMessageEvent</seealso>
            <seealso>VistaDBInfoMessageEventEventArgs.Message</seealso>
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.DbProviderFactory">
            <summary>
            DB Provider Factory object
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.IsLegacyMode">
            <summary>
            Gets whether the connection was opened with CompatibilityMode="Legacy".
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnection.IsStrictMode">
            <summary>
            Gets whether the connection was opened with CompatibilityMode="Strict".
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBConnection.SchemaConstants">
            <summary>
            Constant definitions for collections that may be queried from the GetSchema call on a connection.
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_METADATACOLLECTIONS">
            <summary>
            Metadata collections
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_DATASOURCEINFORMATION">
            <summary>
            Datasource information
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_DATATYPES">
            <summary>
            Datatypes
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_COLUMNS">
            <summary>
            Columns
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_INDEXES">
            <summary>
            Indexes
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_INDEXCOLUMNS">
            <summary>
            Index columns
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_TABLES">
            <summary>
            Tables
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_FOREIGNKEYS">
            <summary>
            Foreign keys
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_FOREIGNKEYCOLUMNS">
            <summary>
            Foreign key columns
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_RESERVEDWORDS">
            <summary>
            Reserved words
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_VIEWS">
            <summary>
            Views
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_VIEWCOLUMNS">
            <summary>
            View columns
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_STOREDPROCEDURES">
            <summary>
            Procedures (stored procs)
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_SPPARAMETERS">
            <summary>
            Schema information collection about Stored procedure parameters
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.SchemaConstants.SCHEMA_RESTRICTIONS">
            <summary>
            Restrictions
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBConnection.CompatibilityMode">
            <summary>
            Enum for the CompatibilityMode setting which applies for the life of a specific connection and may affect
            the handling of SQL code including sprocs and UDFs already previously stored in the database.
            </summary>
            <remarks>
            <para>An application will generally want to pick a particular CompatibilityMode and stay with it since
            changing to a different mode could break sprocs, UDFs, and other SQL code used by the application.</para>
            <para>Most applications using VistaDB can simply use the default (Normal) mode which will expose fixes for
            faulty behavior and expose new syntax features <em>provided</em> usage which works correctly will
            not be broken by the changes.  Usage with behavior or results which are clearly faulty may be corrected
            to match the standard (SQL Server) in any new release--with mention in the Release Notes.</para>
            <para>Applications which target cross-compatibility with SQL Server may wish to use Strict mode which
            will make corrections for incompatible syntax or behavior available in interim-version releases
            rather than waiting for the next major version.  Usage which is incompatible with SQL Server or which
            has behavior or results which are inconsistent with SQL Server can be corrected to match SQL Server
            in any new release--with mention in the Release Notes.  Some compatibility corrections may still have
            to wait for a new major version.</para>
            <para>Applications which rely on past VistaDB syntax features that have been deprecated as incompatible
            with standard T-SQL (as provided in SQL Server) may be able to preserve access to those features a bit
            longer with Legacy mode.  Usage with behavior or results which are clearly faulty may still be corrected
            to better match the standard (SQL Server) in any new release, but syntax and behavior which are arguably
            useful and correct (by legacy design) should not be broken at least until a new major version--with mention
            in the Release Notes.  However, such legacy syntax features might not be preserved past major version
            boundaries when standard-syntax alternatives are available or if maintenance becomes onerous.</para>
            <para>Applications which want to preserve cross-compatibility options but which do not currently rely
            on cross-compatibility may wish to use Normal mode (the default) for releases and normal operation
            but then also test and develop in Strict mode to help identify areas of incompatibility in their usage
            which would fail to work as-is against SQL Server.  This approach could allow a gradual migration towards
            cross-compatible usage as new features and missing cross-compatible syntax are added to VistaDB without
            requiring sudden reengineering just to incorporate an updated version of VistaDB.</para>
            <para>Periodically checking the progress of changes in Strict mode is also advisable for most other
            Applications since changes made available in Strict mode may tend to be incorporated into Normal mode
            in the next major version.</para>
            </remarks>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.CompatibilityMode.Normal">
            <summary>
            (The default setting) Non-breaking corrections and enhancements are incorporated in minor versions,
            but breaking changes wait for new major versions.
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.CompatibilityMode.Strict">
            <summary>
            Client prefers strict SQL Server syntax.  BREAKING CHANGES to correct syntax incompatibilities
            may be added IN ANY NEW RELEASE.
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBConnection.CompatibilityMode.Legacy">
            <summary>
            Client relies on deprecated syntax features of VistaDB.  Deprecated quirks may eventually be removed
            in a new major version.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBConnection.ConnectionPoolCollection">
            <summary>
            Collection of ConnectionPool Objects used to maintain VistaDBConnections per unique connection string
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.ConnectionPoolCollection.#ctor">
            <summary>
            Public constructor - we need to implement to correctly make the base dictionary case insensitive
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.ConnectionPoolCollection.Clear">
            <summary>
            Empties the connection pool.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.ConnectionPoolCollection.ClearPool(VistaDB.Provider.VistaDBConnection)">
            <summary>
            Empties the connection pool associated with the specified connection. Note that this connection string must match
            exactly or it is considered a different connection.  If you opened two connections to the same database, but one is
            readonly and one is read write they will not be considered to be in the same pool.
            </summary>
            <param name="connection">The VistaDBConnection to be cleared from the pool.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.ConnectionPoolCollection.PutConnectionOnHold(VistaDB.Engine.Internal.ILocalSQLConnection,System.String,System.Int32,System.Int32)">
            <summary>
            Put an existing connection on hold by placing it in the Connection Pool if appropriate.
            </summary>
            <param name="connection"></param>
            <param name="connectionString"></param>
            <param name="minPoolSize"></param>
            <param name="maxPoolSize"></param>
            <returns>connection needs to be closed and disposed</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnection.ConnectionPoolCollection.GetConnection(System.String)">
            <summary>
            Attempt to get an existing connection that matches the input connection string
            </summary>
            <param name="connectionString">The user connection parameters used to build our pool keys</param>
            <returns></returns>
        </member>
        <member name="T:VistaDB.Provider.VistaDBInfoMessageEventHandler">
            <summary>
            Represents the method that will handle the InfoMessage event of a VistaDBConnection.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:VistaDB.Provider.VistaDBInfoMessageEventArgs">
            <summary>
            Provides data for the InfoMessage event.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBInfoMessageEventArgs.Message">
            <summary>
            Gets the full text of the error sent from the database.
            Return Value
            The full text of the error.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBInfoMessageEventArgs.Source">
            <summary>
            Gets the name of the object that generated the error.
            Return Value
            The name of the object that generated the error.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBConnectionStringBuilder">
            <summary>
            Provides a simple way to create and manage the contents of connection strings used by the VistaDBConnection class.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnectionStringBuilder.#ctor">
            <summary>
            Initializes a new instance of the VistaDBConnectionStringBuilder class.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnectionStringBuilder.#ctor(System.String)">
            <summary>
            Initializes a new instance of the VistaDBConnectionStringBuilder class. The provided connection string provides the data for the instance's internal connection information.
            </summary>
            <param name="connectionString">The basis for the object's internal connection information. Parsed into name/value pairs.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnectionStringBuilder.Clear">
            <summary>
            Clears the contents of the VistaDBConnectionStringBuilder instance.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnectionStringBuilder.ContainsKey(System.String)">
            <summary>
            Determines whether the VistaDBConnectionStringBuilder contains a specific key.
            </summary>
            <param name="keyword">The key to locate in the VistaDBConnectionStringBuilder.</param>
            <returns>true if the VistaDBConnectionStringBuilder contains an entry with the specified key; otherwise false.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnectionStringBuilder.Remove(System.String)">
            <summary>
            Removes the entry with the specified key from the VistaDBConnectionStringBuilder instance.
            </summary>
            <param name="keyword">The key of the key/value pair to be removed from the connection string in this VistaDBConnectionStringBuilder.</param>
            <returns>true if the key existed within the connection string and was removed; false if the key did not exist.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnectionStringBuilder.ShouldSerialize(System.String)">
            <summary>
            Indicates whether the specified key exists in this VistaDBConnectionStringBuilder instance.
            </summary>
            <param name="keyword">The key to locate in the VistaDBConnectionStringBuilder.</param>
            <returns>true if the VistaDBConnectionStringBuilder contains an entry with the specified key; otherwise, false.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBConnectionStringBuilder.TryGetValue(System.String,System.Object@)">
            <summary>
            Retrieves a value corresponding to the supplied key from this VistaDBConnectionStringBuilder.
            </summary>
            <param name="keyword">The key of the item to retrieve.</param>
            <param name="value">The value corresponding to the key.</param>
            <returns>true if keyword was found within the connection string, false otherwise.</returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.ContextConnection">
            <summary>
            Only assigned for CLR stored procedures.
            If set to true the context connection is used.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.Database">
            <summary>
            Database to access within the Data Source.  VistaDB supports only one database per data source (file) and
            ignores this property.  Instead use Data Source to set the filename (partial or full path).
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.DataSource">
            <summary>
            The name and file location of the database to open.  May include the |DataDirectory| macro to indicate local working path.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.IsFixedSize">
            <summary>
            Gets a value that indicates whether the VistaDBConnectionStringBuilder has a fixed size.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.IsolatedStorage">
            <summary>
            If it is set to true value the database resides in isolated storage.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.Item(System.String)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="keyword">The key of the item to get or set.</param>
            <returns>The value associated with the specified key.</returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.Keys">
            <summary>
            Gets an ICollection that contains the keys in the VistaDBConnectionStringBuilder.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.TransactionMode">
            <summary>
            TransactionMode current setting for supporting or ignoring transactions on this connection.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.CompatibilityMode">
            <summary>
            The CompatibilityMode setting for the life of a specific connection.  A different setting value may alter
            the handling of SQL code including sprocs and UDFs already previously stored in the database.
            </summary>
            <remarks>
            <para>An application will generally want to pick a particular CompatibilityMode and stay with it since
            changing to a different mode could break sprocs, UDFs, and other SQL code used by the application.</para>
            <para>Most applications using VistaDB can simply use the default (Normal) mode which will expose fixes for
            faulty behavior and expose new syntax features <em>provided</em> usage which works correctly will
            not be broken by the changes.  Usage with behavior or results which are clearly faulty may be corrected
            to match the standard (SQL Server) in any new release--with mention in the Release Notes.</para>
            <para>Applications which target cross-compatibility with SQL Server may wish to use Strict mode which
            will make corrections for incompatible syntax or behavior available in interim-version releases
            rather than waiting for the next major version.  Usage which is incompatible with SQL Server or which
            has behavior or results which are inconsistent with SQL Server can be corrected to match SQL Server
            in any new release--with mention in the Release Notes.  Some compatibility corrections may still have
            to wait for a new major version.</para>
            <para>Applications which rely on past VistaDB syntax features that have been deprecated as incompatible
            with standard T-SQL (as provided in SQL Server) may be able to preserve access to those features a bit
            longer with Legacy mode.  Usage with behavior or results which are clearly faulty may still be corrected
            to better match the standard (SQL Server) in any new release, but syntax and behavior which are arguably
            useful and correct (by legacy design) should not be broken at least until a new major version--with mention
            in the Release Notes.  However, such legacy syntax features might not be preserved past major version
            boundaries when standard-syntax alternatives are available or if maintenance becomes onerous.</para>
            <para>Applications which want to preserve cross-compatibility options but which do not currently rely
            on cross-compatibility may wish to use Normal mode (the default) for releases and normal operation
            but then also test and develop in Strict mode to help identify areas of incompatibility in their usage
            which would fail to work as-is against SQL Server.  This approach could allow a gradual migration towards
            cross-compatible usage as new features and missing cross-compatible syntax are added to VistaDB without
            requiring sudden reengineering just to incorporate an updated version of VistaDB.</para>
            <para>Periodically checking the progress of changes in Strict mode is also advisable for most other
            Applications since changes made available in Strict mode may tend to be incorporated into Normal mode
            in the next major version.</para>
            </remarks>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.Pooling">
            <summary>
            Whether we should pull the connection from the Connection Pool or create a new one each time
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.MinPoolSize">
            <summary>
            The minimum number of connections allowed in the pool. Default value is 1.  Use Pooling=false if you wish to turn off connection pooling. Setting this value to 0 is not the way to turn off connection pooling.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.MaxPoolSize">
            <summary>
            The maximum number of connections allowed in the pool.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.ConnectTimeout">
            <summary>
            The maximum time in seconds to wait for a valid connection.
            By default we do not wait at all.  If there are no open connection pool slots available we return immediately with failure.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.OpenMode">
            <summary>
            Connection open mode
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.Password">
            <summary>
            Database encryptionKey
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.EncryptDatabase">
            <summary>
            Database Encrypted flag to show if a valid encryption phrase has been set on this database
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBConnectionStringBuilder.Values">
            <summary>
            Gets an ICollection that contains the values in the VistaDBConnectionStringBuilder.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBDataAdapter">
            <summary>
            Represents a set of data commands and a database connection that are used to fill the DataSet and update a VistaDB database. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.#ctor">
            <summary>
            Initializes a new instance of the VistaDBDataAdapter class.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.#ctor(VistaDB.Provider.VistaDBCommand)">
            <summary>
            Initializes a new instance of the VistaDBDataAdapter class with the specified VistaDBCommand as the SelectCommand property.
            </summary>
            <param name="selectCommand">A VistaDBCommand that is a SQL SELECT statement and is set as the SelectCommand property of the VistaDBDataAdapter.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.#ctor(System.String,VistaDB.Provider.VistaDBConnection)">
            <summary>
            Initializes a new instance of the VistaDBDataAdapter class with a SelectCommand and a VistaDBConnection object.
            </summary>
            <param name="selectCommandText">A String that is a SELECT statement to be used by the SelectCommand property of the VistaDBDataAdapter. </param>
            <param name="conn">A VistaDBConnection that represents the connection.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the VistaDBDataAdapter class with a SelectCommand and a connection string.
            </summary>
            <param name="selectCommandText">A String that is a SELECT statement to be used by the SelectCommand property of the VistaDBDataAdapter. </param>
            <param name="connectionString">The connection string.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            
            </summary>
            <param name="dataRow"></param>
            <param name="command"></param>
            <param name="statementType"></param>
            <param name="tableMapping"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            
            </summary>
            <param name="dataRow"></param>
            <param name="command"></param>
            <param name="statementType"></param>
            <param name="tableMapping"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataAdapter.DeleteCommand">
            <summary>
            Gets or sets a command for deleting records from the data set.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataAdapter.InsertCommand">
            <summary>
            Gets or sets a command used to insert new records into the data source. 
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataAdapter.SelectCommand">
            <summary>
            Gets or sets a command used to select records in the data source.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataAdapter.UpdateCommand">
            <summary>
            Gets or sets a command used to update records in the data source.
            </summary>
        </member>
        <member name="E:VistaDB.Provider.VistaDBDataAdapter.RowUpdating">
            <summary>
            Occurs during Update before a command is executed against the data source. 
            The attempt to update is made, so the event fires.
            </summary>
        </member>
        <member name="E:VistaDB.Provider.VistaDBDataAdapter.RowUpdated">
            <summary>
            Occurs during Update after a command is executed against the data source. 
            The attempt to update is made, so the event fires.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBRowUpdatedEventArgs">
            <summary>
            Provides data for the RowUpdated event of a VistaDB data provider.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBRowUpdatedEventArgs.#ctor(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            Initializes a new instance of the VistaDBRowUpdatedEventArgs class.
            </summary>
            <param name="row">The DataRow sent through an Update.</param>
            <param name="command">The IDbCommand to execute when Update is called.</param>
            <param name="statementType">The type of SQL statement to execute.</param>
            <param name="tableMapping">The DataTableMapping to send through an Update.</param>
        </member>
        <member name="P:VistaDB.Provider.VistaDBRowUpdatedEventArgs.Command">
            <summary>
            Gets or sets a new instance of the VistaDBCommand class.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBRowUpdatingEventArgs">
            <summary>
            Provides the data for the RowUpdating event of a VistaDB data provider. 
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBRowUpdatingEventArgs.#ctor(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)">
            <summary>
            Initializes a new instance of the VistaDBRowUpdatingEventArgs class.
            </summary>
            <param name="row">The DataRow to Update.</param>
            <param name="command">The IDbCommand to execute when Update is called.</param>
            <param name="statementType">The type of SQL statement to execute.</param>
            <param name="tableMapping">The DataTableMapping to send through an Update.</param>
        </member>
        <member name="P:VistaDB.Provider.VistaDBRowUpdatingEventArgs.BaseCommand">
            <summary>
            
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBRowUpdatingEventArgs.Command">
            <summary>
            Gets or sets a new instance of the VistaDBCommand class.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBRowUpdatingEventHandler">
            <summary>
            Represents the method that will handle the RowUpdating event of a VistaDBDataAdapter.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBRowUpdatedEventHandler">
            <summary>
            Represents the method that will handle the RowUpdated event of a VistaDBDataAdapter.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBDataPermission">
            <summary>
            
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataPermission.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBDataReader">
            <summary>
            Provides a way of reading a forward-only stream of rows from a VistaDB 3 
            database. This class cannot be inherited.
            
            This is considered an online operation, any rows or fks locked as a result of this operation will be held until this reader is destroyed.  
            Each row of the result is only built up at the time of the read.  After each row is used and the current 
            pointer is moved forward the previous row is destroyed and unloaded from memory.
            <seealso>ADO.NET Overview</seealso>
            </summary>
            <example>
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
            public void Simple()
            {
            	using( VistaDBConnection conn = new VistaDBConnection(@&quot;Open 
            Mode=NonExclusiveReadWrite;Data Source=simple.vdb3&quot;) )
            	{
            		Assert.IsNotNull(conn);
            		// Open the connection and verify the state is set correctly
            		conn.Open();
            		Assert.IsTrue(conn.State == ConnectionState.Open);
            
            		// This should return one column AMOUNT = 20
            		using( VistaDBCommand cmd = new VistaDBCommand(&quot;select sum(10+10) as
             amount&quot;, conn) )
            		{
            			VistaDBDataReader reader = cmd.ExecuteReader();
            			Assert.IsNotNull(reader);
            			Assert.IsNotNull(reader[0]);
            			Assert.IsTrue(reader.HasRows);
            			// SELECT commands should generate a -1 for RecordsAffected
            			Assert.AreEqual(reader.RecordsAffected, -1);
            			Assert.IsTrue(reader[&quot;amount&quot;].Equals(&quot;20&quot;));
            		}
            	}
            }
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader.queryStatements">
            <summary>
            The set of queries created by sql parser from command text by VistaDBCommand
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader.vdbConnection">
            <summary>
            This reference is only initialized when data reader created with flag CommandBehavior.CloseConnection
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader.closeConnection">
            <summary>
            Flag is true only when data reader created with flag CommandBehavior.CloseConnection
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader._queryResult">
            <summary>
            Current result set. It's created for SELECT statements only
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader.queryResultSchema">
            <summary>
            Schema for current result set
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader.schemaOnly">
            <summary>
            Reader is requested to return only recordset schema
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader.singleResult">
            <summary>
            Reader is requested to return only first column in the first row
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBDataReader.singleRow">
            <summary>
            Reader is requested to return only first row
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.Close">
            <summary>
            Closes the VistaDBDataReader object.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetBoolean(System.Int32)">
            <summary>
            Gets the value of the specified column as a Boolean.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetByte(System.Int32)">
            <summary>
            Gets the value of the specified column as a byte.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a stream of bytes from the specified column, starting at location indicated by dataIndex, into the buffer, starting at the location indicated by bufferIndex.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <param name="dataOffset">The index within the row from which to begin the read operation.</param>
            <param name="buffer">The buffer into which to copy the data.</param>
            <param name="bufferOffset">The index with the buffer to which the data will be copied.</param>
            <param name="length">The maximum number of characters to read.</param>
            <returns>The actual number of bytes read.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetChar(System.Int32)">
            <summary>
            Gets the value of the specified column as a single character.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a stream of characters from the specified column, starting at location indicated by dataIndex, into the buffer, starting at the location indicated by bufferIndex.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <param name="dataOffset">The index within the row from which to begin the read operation.</param>
            <param name="buffer">The buffer into which to copy the data.</param>
            <param name="bufferOffset">The index with the buffer to which the data will be copied.</param>
            <param name="length">The maximum number of characters to read.</param>
            <returns>The actual number of characters read.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetDataTypeName(System.Int32)">
            <summary>
            Gets name of the data type of the specified column.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>A string representing the name of the data type.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetDateTime(System.Int32)">
            <summary>
            Gets the value of the specified column as a DateTime object.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetDecimal(System.Int32)">
            <summary>
            Gets the value of the specified column as a Decimal object.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetDouble(System.Int32)">
            <summary>
            Gets the value of the specified column as a double-precision floating point number.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetEnumerator">
            <summary>
            Returns an IEnumerator that can be used to iterate through the rows in the data reader.
            </summary>
            <returns>An IEnumerator that can be used to iterate through the rows in the data reader.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetFieldType(System.Int32)">
            <summary>
            Gets the data type of the specified column.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The data type of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetFieldVistaDBType(System.Int32)">
            <summary>
            Gets the VistaDBType of the specified column.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The VistaDBType of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetFloat(System.Int32)">
            <summary>
            Gets the value of the specified column as a single-precision floating point number.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetGuid(System.Int32)">
            <summary>
            Gets the value of the specified column as a globally-unique identifier (GUID).
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetInt16(System.Int32)">
            <summary>
            Gets the value of the specified column as a 16-bit signed integer.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetInt32(System.Int32)">
            <summary>
            Gets the value of the specified column as a 32-bit signed integer.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetInt64(System.Int32)">
            <summary>
            Gets the value of the specified column as a 64-bit signed integer.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetName(System.Int32)">
            <summary>
            Gets the name of the column, given the zero-based column ordinal.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The name of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetOrdinal(System.String)">
            <summary>
            Gets the column ordinal given the name of the column.
            </summary>
            <param name="name">The name of the column.</param>
            <returns>The zero-based column ordinal.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetSchemaTable">
            <summary>
            The VistaDBDataReader class's GetSchemaTable method is similar to using a 
            DataTable FillSchema method.  Each method lets you create a DataTable 
            contains DataColumn objects that correspond to the columns returned by your
             query.
            
            The GetSchemaTable method accepts no parameters and returns a new DataTable
             object.
            <seealso>Class VistaDBDataReader</seealso>
            <seealso>Database Schema</seealso>
            <seealso>VistaDBDataReader GetSchemaTable example</seealso>
            <seealso>VistaDBConnection.GetSchema</seealso>
            </summary>
            <returns>A DataTable that describes the column metadata.</returns>
            <example>
            
            &lt;&lt;code lang=&quot;C#&quot;&gt;&gt;
                    static void Main( string[] args )
                    {
                        using (VistaDBConnection cn =
                                 new VistaDBConnection(&quot;Data 
            Source=|DataDirectory|Database1.vdb5;&quot;))
                        {
                            cn.Open();
            
                            using (VistaDBCommand cmd = new VistaDBCommand(&quot;Select
             * from employees&quot;, cn ) )
                            {
                                using (VistaDBDataReader myReader =
                                       cmd.ExecuteReader(CommandBehavior.KeyInfo))
                                {
                                    //Retrieve column schema into a DataTable.
                                    DataTable schemaTable = myReader.GetSchemaTable();
            
                                    foreach (DataRow myField in schemaTable.Rows)
                                    {
                                        foreach (DataColumn myProperty in 
            schemaTable.Columns)
                                        {
                                            Console.WriteLine(myProperty.ColumnName + 
            &quot; = &quot; +
                                                  myField[myProperty].ToString());
                                        }
                                        Console.WriteLine();
                                    }
                                }
                            }
                        }
                    }
            &lt;&lt;/code&gt;&gt;
            </example>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetString(System.Int32)">
            <summary>
            Gets the value of the specified column as an instance of String.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetValue(System.Int32)">
            <summary>
            Gets the value of the specified column as an instance of Object.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.GetValues(System.Object[])">
            <summary>
            Gets all attribute columns in the collection for the current row.
            </summary>
            <param name="values">An array of Object into which to copy the attribute columns.</param>
            <returns>The number of instances of Object in the array.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.IsDBNull(System.Int32)">
            <summary>
            Gets a value that indicates whether the column contains nonexistent or missing values.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>true if the specified column is equivalent to DBNull; otherwise false.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.NextResult">
            <summary>
            Advances the reader to the next result when reading the results of a batch of statements.
            </summary>
            <returns>This method allows you to process multiple result sets returned when a batch is submitted to the data provider.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.Read">
            <summary>
            Advances the reader to the next record in a result set.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.ExecQuery(System.Int64@)">
            <summary>
            Executes all statements inlcudinng the piped ones in correct order and returns first scalar
            </summary>
            <param name="affectedRows"></param>
            <returns>first scalar</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBDataReader.LockQuery">
            <summary>
            Do not allow VistaDBCommand to dispose this.queryStatements when VistaDBCommand is being disposed itself
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataReader.Depth">
            <summary>
            Gets a value indicating the depth of nesting for the current row.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataReader.FieldCount">
            <summary>
            Gets the number of columns in the current row.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataReader.HasRows">
            <summary>
            Gets a value that indicates whether this VistaDBDataReader contains one or more rows.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataReader.IsClosed">
            <summary>
            Gets a value indicating whether the VistaDBDataReader is closed.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataReader.Item(System.Int32)">
            <summary>
            Gets the value of the specified column as an instance of Object.
            </summary>
            <param name="ordinal">The zero-based column ordinal.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataReader.Item(System.String)">
            <summary>
            Gets the value of the specified column as an instance of Object.
            </summary>
            <param name="name">The name of the column.</param>
            <returns>The value of the specified column.</returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBDataReader.RecordsAffected">
            <summary>
            Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.
            <remarks>
            This will be set to 0 if no rows were affected or the statement failed.  This value shall be set to -1 for SELECT statements according to the IDataReader.RecordsAffected property.
            </remarks>
            </summary>
            <seealso cref="P:System.Data.IDataReader.RecordsAffected"/>
        </member>
        <member name="T:VistaDB.Provider.VistaDBParameterCollection">
            <summary>
            Represents a collection of parameters associated with a VistaDBCommand and their respective mappings to columns in a DataSet. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Add(System.Object)">
            <summary>
            Adds the specified VistaDBParameter object to the VistaDBParameterCollection.
            </summary>
            <param name="value">An Object.</param>
            <returns>The index of the new VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Add(VistaDB.Provider.VistaDBParameter)">
            <summary>
            Adds the specified VistaDBParameter object to the VistaDBParameterCollection.
            </summary>
            <param name="parameter">The VistaDBParameter to add to the collection.</param>
            <returns>The new VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Add(System.String,System.Object)">
            <summary>
            Adds the specified VistaDBParameter object to the VistaDBParameterCollection.
            </summary>
            <param name="parameterName">The name of the VistaDBParameter to add to the collection.</param>
            <param name="value">A Object.</param>
            <returns>The new VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Add(System.String,VistaDB.VistaDBType)">
            <summary>
            Adds a VistaDBParameter to the VistaDBParameterCollection given the parameter name and the data type.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="dataType">One of the VistaDBType values.</param>
            <returns>The new VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Add(System.String,VistaDB.VistaDBType,System.Int32)">
            <summary>
            Adds a VistaDBParameter to the VistaDBParameterCollection, given the specified parameter name and value.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="dataType">One of the VistaDBType values.</param>
            <param name="size">The size as an Int32.</param>
            <returns>The new VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Add(System.String,VistaDB.VistaDBType,System.Int32,System.String)">
            <summary>
            Adds a VistaDBParameter to the VistaDBParameterCollection with the parameter name, the data type, and the column length.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="dataType">One of the VistaDBType values.</param>
            <param name="size">The size as an Int32.</param>
            <param name="sourceColumn">The name of the source column.</param>
            <returns>The new VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.AddWithValue(System.String,System.Object)">
            <summary>
            Adds a VistaDBParameter to the VistaDBParameterCollection with the parameter name and value.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <param name="value">The value to be added.</param>
            <returns>The new VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.AddRange(System.Array)">
            <summary>
            Adds an array of items with the specified values to the VistaDBParameterCollection.
            </summary>
            <param name="values">An array of values of type VistaDBParameter to add to the collection.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Clear">
            <summary>
            Removes all VistaDBParameter values from the VistaDBParameterCollection.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Contains(System.Object)">
            <summary>
            Indicates whether a VistaDBParameter with the specified Value is contained in the collection.
            </summary>
            <param name="value">The Value of the VistaDBParameter to look for in the collection.</param>
            <returns>true if the VistaDBParameter is in the collection; otherwise false.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Contains(System.String)">
            <summary>
            Indicates whether a VistaDBParameter with the specified name exists in the collection.
            </summary>
            <param name="parameterName">The name of the VistaDBParameter to look for in the collection.</param>
            <returns>true if the VistaDBParameter is in the collection; otherwise false.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies an array of items to the collection starting at the specified index.
            </summary>
            <param name="array">The array of items to copy to the collection.</param>
            <param name="index">The index in the collection to copy the items.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.GetEnumerator">
            <summary>
            Exposes the GetEnumerator method, which supports a simple iteration over a collection by a .NET Framework data provider.
            </summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.IndexOf(System.Object)">
            <summary>
            Returns the index of the specified VistaDBParameter object.
            </summary>
            <param name="value">The VistaDBParameter object in the collection.</param>
            <returns>The index of the specified VistaDBParameter object.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.IndexOf(System.String)">
            <summary>
            Returns the index of the VistaDBParameter object with the specified name.
            </summary>
            <param name="parameterName">The name of the VistaDBParameter object in the collection.</param>
            <returns>The index of the VistaDBParameter object with the specified name.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Insert(System.Int32,System.Object)">
            <summary>
            Inserts the specified the index of the VistaDBParameter object with the specified name into the collection at the specified index.
            </summary>
            <param name="index">The index at which to insert the VistaDBParameter object.</param>
            <param name="value">The VistaDBParameter object to insert into the collection.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Insert(System.Int32,VistaDB.Provider.VistaDBParameter)">
            <summary>
            Inserts the specified the index of the VistaDBParameter object with the specified name into the collection at the specified index.
            </summary>
            <param name="index">The index at which to insert the VistaDBParameter object.</param>
            <param name="parameter">The VistaDBParameter object to insert into the collection.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Remove(System.Object)">
            <summary>
            Removes the specified VistaDBParameter object from the collection.
            </summary>
            <param name="value">The VistaDBParameter object to remove.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.Remove(VistaDB.Provider.VistaDBParameter)">
            <summary>
            Removes the specified VistaDBParameter object from the collection.
            </summary>
            <param name="parameter">The VistaDBParameter object to remove.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the VistaDBParameter object at the specified from the collection.
            </summary>
            <param name="index">The index where the VistaDBParameter object is located.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.RemoveAt(System.String)">
            <summary>
            Removes the VistaDBParameter object with the specified name from the collection.
            </summary>
            <param name="parameterName">The name of the VistaDBParameter object to remove.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.GetParameter(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.GetParameter(System.String)">
            <summary>
            
            </summary>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.SetParameter(System.Int32,System.Data.Common.DbParameter)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.SetParameter(System.String,System.Data.Common.DbParameter)">
            <summary>
            
            </summary>
            <param name="parameterName"></param>
            <param name="value"></param>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.Count">
            <summary>
            Specifies the number of parameters in the collection.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.IsFixedSize">
            <summary>
            Specifies whether the collection is a fixed size.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.IsReadOnly">
            <summary>
            Specifies whether the collection is read-only.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.IsSynchronized">
            <summary>
            Specifies whether the collection is synchronized.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.Item(System.Int32)">
            <summary>
            Gets and sets the VistaDBParameter at the specified index.
            </summary>
            <param name="index">The zero-based index of the parameter.</param>
            <returns>The VistaDBParameter at the specified index.</returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.Item(System.String)">
            <summary>
            Gets and sets the VistaDBParameter with the specified name.
            </summary>
            <param name="parameterName">The name of the parameter.</param>
            <returns>The VistaDBParameter with the specified name, or a null reference (Nothing in Visual Basic) if the parameter is not found. </returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.SyncRoot">
            <summary>
            Specifies the Object to be used to synchronize access to the collection.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBParameterCollection.ParameterEnumerator">
            <summary>
            Parameter enumerator
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.ParameterEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection. 
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameterCollection.ParameterEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameterCollection.ParameterEnumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBParameter">
            <summary>
            Represents a parameter to a VistaDBCommand and optionally its mapping to DataSet columns. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameter.#ctor">
            <summary>
            Initializes a new instance of the VistaDBParameter class.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameter.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the VistaDBParameter class that uses 
            the parameter name and a value of the new VistaDBParameter.
            </summary>
            <param name="parameterName">The name of the parameter to map.</param>
            <param name="value">An Object that is the value of the VistaDBParameter.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameter.#ctor(System.String,VistaDB.VistaDBType)">
            <summary>
            Initializes a new instance of the VistaDBParameter class that uses 
            the parameter name and the data type.
            </summary>
            <param name="parameterName">The name of the parameter to map.</param>
            <param name="dataType">One of the VistaDBType values.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameter.#ctor(System.String,VistaDB.VistaDBType,System.Int32)">
            <summary>
            Initializes a new instance of the VistaDBParameter class that uses 
            the parameter name, the VistaDBType, and the size.
            </summary>
            <param name="parameterName">The name of the parameter to map.</param>
            <param name="dataType">One of the VistaDBType values.</param>
            <param name="size">The length of the parameter.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameter.#ctor(System.String,VistaDB.VistaDBType,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the VistaDBParameter class that uses 
            the parameter name, the VistaDBType, the size, and the source column name.
            </summary>
            <param name="parameterName">The name of the parameter to map.</param>
            <param name="dataType">One of the VistaDBType values.</param>
            <param name="size">The length of the parameter.</param>
            <param name="sourceColumn">The name of the source column.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameter.#ctor(System.String,VistaDB.VistaDBType,System.Int32,System.Data.ParameterDirection,System.Boolean,System.String,System.Data.DataRowVersion,System.Object)">
            <summary>
            Initializes a new instance of the VistaDBParameter class that uses 
            the parameter name, the type of the parameter, the size of the parameter, 
            a ParameterDirection, the source column, a DataRowVersion to use, 
            and the value of the parameter.
            </summary>
            <param name="parameterName">The name of the parameter to map.</param>
            <param name="dataType">One of the VistaDBType values.</param>
            <param name="size">The length of the parameter.</param>
            <param name="direction">One of the ParameterDirection values.</param>
            <param name="isNullable">true if the value of the field can be null; otherwise false.</param>
            <param name="sourceColumn">The name of the source column.</param>
            <param name="sourceVersion">One of the DataRowVersion values.</param>
            <param name="value">An Object that is the value of the SqlParameter.</param>
        </member>
        <member name="M:VistaDB.Provider.VistaDBParameter.ResetDbType">
            <summary>
            Resets the DbType property to its original settings.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.DbType">
            <summary>
            Gets or sets the DbType of the parameter.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.Direction">
            <summary>
            Gets or sets a value that indicates whether the parameter is input-only,
            output-only, bidirectional, or a stored procedure return value parameter.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.IsNullable">
            <summary>
            Gets or sets a value that indicates whether the parameter accepts null values.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.ParameterName">
            <summary>
            Gets or sets the name of the VistaDBParameter.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.Size">
            <summary>
            This property is not used.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.SourceColumn">
            <summary>
            Gets or sets the name of the source column mapped to the DataSet and used for loading or returning the Value.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.SourceColumnNullMapping">
            <summary>
            Sets or gets a value which indicates whether the source column is nullable.
            This allows VistaDBCommandBuilder to correctly generate Update statements for nullable columns.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.SourceVersion">
            <summary>
            Gets or sets the DataRowVersion to use when you load Value.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.Value">
            <summary>
            Gets or sets the value of the parameter.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBParameter.VistaDBType">
            <summary>
            Gets or sets the VistaDBType of the parameter.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBProviderFactory">
            <summary>
            Represents a set of methods for creating instances of a VistaDB provider's implementation of the data source classes.
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBProviderFactory.Instance">
            <summary>
            Static instance member which returns an instanced VistaDBProviderFactory class.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.CreateCommand">
            <summary>
            Returns a strongly typed DbCommand instance.
            </summary>
            <returns>A new strongly typed instance of DbCommand. </returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.CreateCommandBuilder">
            <summary>
            Returns a strongly typed DbCommandBuilder instance.
            </summary>
            <returns>A new strongly typed instance of DbCommandBuilder.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.CreateConnection">
            <summary>
            Returns a strongly typed DbConnection instance.
            </summary>
            <returns>A new strongly typed instance of DbConnection.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.CreateConnectionStringBuilder">
            <summary>
            Returns a strongly typed DbConnectionStringBuilder instance.
            </summary>
            <returns>A new strongly typed instance of DbConnectionStringBuilder.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.CreateDataAdapter">
            <summary>
            Returns a strongly typed DbDataAdapter instance.
            </summary>
            <returns>A new strongly typed instance of DbDataAdapter.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.CreateParameter">
            <summary>
            Returns a strongly typed DbParameter instance.
            </summary>
            <returns>A new strongly typed instance of DbParameter.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.CreatePermission(System.Security.Permissions.PermissionState)">
            <summary>
            Returns a new CodeAccessPermission.
            </summary>
            <param name="state">A member of the PermissionState enumeration.</param>
            <returns>A strongly typed instance of CodeAccessPermission.</returns>
        </member>
        <member name="M:VistaDB.Provider.VistaDBProviderFactory.System#IServiceProvider#GetService(System.Type)">
            <summary>
            EntityFramework 4.x - 5.x service provider factory method.
            </summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="P:VistaDB.Provider.VistaDBProviderFactory.CanCreateDataSourceEnumerator">
            <summary>
            Always return false.
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBTransaction">
            <summary>
            Represents a transaction to be made in a VistaDB database. This class cannot be inherited.  
            This class can be initiated through a SQL connection by calling BeginTransaction on a connection object.
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBTransaction.Commit">
            <summary>
            Commit current transaction
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBTransaction.Rollback">
            <summary>
            Rollback current transaction
            </summary>
        </member>
        <member name="M:VistaDB.Provider.VistaDBTransaction.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the System.Data.Common.DbTransaction and optionally releases
            the managed resources. (Will also Rollback() this transaction if not already committed or rolled back.)
            </summary>
            <param name="disposing">If true, this method releases all resources held by any managed objects that
            this VistaDBTransaction references</param>
        </member>
        <member name="P:VistaDB.Provider.VistaDBTransaction.Connection">
            <summary>
            Gets the VistaDBConnection object associated with the transaction, or a null reference (Nothing in Visual Basic) if the transaction is no longer valid.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBTransaction.DbConnection">
            <summary>
            Gets the VistaDBConnection object associated with the transaction, or a null reference (Nothing in Visual Basic) if the transaction is no longer valid.
            </summary>
        </member>
        <member name="P:VistaDB.Provider.VistaDBTransaction.IsolationLevel">
            <summary>
            Isolation level for current transaction
            </summary>
        </member>
        <member name="T:VistaDB.Provider.VistaDBTransaction.TransactionMode">
            <summary>
            Enum for the three possible states of the TransactionMode setting.
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBTransaction.TransactionMode.On">
            <summary>
            Transaction support is on and operates normally
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBTransaction.TransactionMode.Off">
            <summary>
            No transaction support.  Attempting a transaction is an error.
            </summary>
        </member>
        <member name="F:VistaDB.Provider.VistaDBTransaction.TransactionMode.Ignore">
            <summary>
            No transaction support, but all attempts are simply ignored.
            </summary>
        </member>
        <member name="T:VistaDB.CastableEnumerator`2">
            <summary>
            A castable enumerator that can be used to enumerate a type, but output another.
            This is useful in scenarios where we need to enumerate based upon an IVistaDB interface type, 
            but output a concrete type.  
            </summary>
            <example>
            IVistaDBColumnAttributes are enumerable from the Table.TableSchema, but we actually want to return
            concrete Row.Columns from the enumerator.
            </example>
            <typeparam name="T">Type to be enumerated, must be a subtype of K</typeparam>
            <typeparam name="K">Return type from enumeration, but be castable from the T type directly. return( (K)T ) has to work.</typeparam>
        </member>
        <member name="T:VistaDB.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:VistaDB.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:VistaDB.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:VistaDB.SQLResource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:VistaDB.SQLResource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:VistaDB.SQLResource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:VistaDB.SQLResource.DataTypes">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;
            &lt;DocumentElement&gt;
            	&lt;DataTypes&gt;
            		&lt;TypeName&gt;char&lt;/TypeName&gt;
            		&lt;ProviderDbType&gt;1&lt;/ProviderDbType&gt;
            		&lt;ColumnSize&gt;8192&lt;/ColumnSize&gt;
            		&lt;CreateParameters&gt;length&lt;/CreateParameters&gt;
            		&lt;DataType&gt;System.String&lt;/DataType&gt;
            		&lt;CreateFormat&gt;char({0})&lt;/CreateFormat&gt;
            		&lt;IsAutoIncrementable&gt;false&lt;/IsAutoIncrementable&gt;
            		&lt;IsCaseSensitive&gt;false&lt;/IsCaseSensitive&gt;
            		&lt;IsFixedLength&gt;true&lt;/IsFixedLength&gt;
            		&lt;IsFixedPrecisionScale&gt;false&lt;/IsFixedPrecisionScale&gt;
            		&lt;IsLong&gt;false&lt;/IsLo [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:VistaDB.SQLResource.MetaDataCollections">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
            &lt;DocumentElement&gt;
              &lt;MetaDataCollections&gt;
                &lt;CollectionName&gt;MetaDataCollections&lt;/CollectionName&gt;
                &lt;NumberOfRestrictions&gt;0&lt;/NumberOfRestrictions&gt;
                &lt;NumberOfIdentifierParts&gt;0&lt;/NumberOfIdentifierParts&gt;
              &lt;/MetaDataCollections&gt;
              &lt;MetaDataCollections&gt;
                &lt;CollectionName&gt;DataSourceInformation&lt;/CollectionName&gt;
                &lt;NumberOfRestrictions&gt;0&lt;/NumberOfRestrictions&gt;
                &lt;NumberOfIdentifierParts&gt;0&lt;/NumberOfIdentifierParts&gt;
              &lt;/MetaDataCollections&gt;
              &lt;MetaDataC [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:VistaDB.SQLResource.ReservedWords_VDB4">
             <summary>
               Looks up a localized string similar to ADD
            ALL
            ALTER
            AND
            ANY
            AS
            ASC
            AUTHORIZATION
            BACKUP
            BEGIN
            BETWEEN
            BREAK
            BROWSE
            BULK
            BY
            CASCADE
            CASE
            CHECK
            CHECKPOINT
            CLOSE
            CLUSTERED
            COALESCE
            COLLATE
            COLUMN
            COMMIT
            COMPUTE
            CONSTRAINT
            CONTAINS
            CONTAINSTABLE
            CONTINUE
            CONVERT
            CREATE
            CROSS
            CURRENT
            CURRENT_DATE
            CURRENT_TIME
            CURRENT_TIMESTAMP
            CURRENT_USER
            CURSOR
            DATABASE
            DATETIME2
            DATETIMEOFFSET
            DBCC
            DEALLOCATE
            DECLARE
            DEFAULT
            DELETE
            DENY
            DESC
            DISK
            DISTINCT
            DISTRIBUTED
            DOUBLE
            DROP
            DUMP
            ELSE
            END
            ERRLVL
            ESCAPE [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:VistaDB.SQLResource.Restrictions">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
            
            &lt;DocumentElement&gt;
              &lt;Restrictions&gt;
                &lt;CollectionName&gt;Columns&lt;/CollectionName&gt;
                &lt;RestrictionName&gt;Table&lt;/RestrictionName&gt;
                &lt;RestrictionNumber&gt;3&lt;/RestrictionNumber&gt;
              &lt;/Restrictions&gt;
              &lt;Restrictions&gt;
                &lt;CollectionName&gt;Columns&lt;/CollectionName&gt;
                &lt;RestrictionName&gt;Column&lt;/RestrictionName&gt;
                &lt;RestrictionNumber&gt;4&lt;/RestrictionNumber&gt;
              &lt;/Restrictions&gt;
              &lt;Restrictions&gt;
                &lt;CollectionName&gt;Indexes&lt;/CollectionName&gt;
                &lt;RestrictionName&gt;Table&lt;/Restric [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:VistaDB.SQLResource.StopWords_EN">
             <summary>
               Looks up a localized string similar to able
            about
            above
            according
            accordingly
            across
            actually
            after
            afterwards
            again
            against
            ain&apos;t
            all
            allow
            allows
            almost
            alone
            along
            already
            also
            although
            always
            am
            among
            amongst
            an
            and
            another
            any
            anybody
            anyhow
            anyone
            anything
            anyway
            anyways
            anywhere
            apart
            appear
            appreciate
            appropriate
            are
            aren&apos;t
            around
            as
            aside
            ask
            asking
            associated
            at
            available
            away
            awfully
            be
            became
            because
            become
            becomes
            becoming
            been
            before
            beforehand
            behind
            being
            believe
            bel [rest of string was truncated]&quot;;.
             </summary>
        </member>
    </members>
</doc>
